<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>内存初始化之物理内存初始化 - Laumy的技术栈</title>
    <link rel="stylesheet" href="assets/style.css">
    <!-- MathJax支持LaTeX数学公式 -->
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          ignoreHtmlClass: 'tex2jax_ignore',
          processHtmlClass: 'tex2jax_process'
        }
      };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  </head>
  <body>
    <header class="site-header">
      <div class="container">
        <a class="logo" href="./">Laumy的技术栈</a>
        <div class="search">
          <input id="search-input" type="text" placeholder="输入关键词回车搜索">
        </div>
        <div class="theme-toggle" title="切换主题" id="theme-toggle">☾</div>
        <nav class="top-nav">
          <div class="nav-item"><a href="./">首页</a></div>
          <div class="nav-item site-link">
            <a href="https://www.laumy.tech" target="_blank" title="访问主站">主站点:www.laumy.tech</a>
          </div>
        </nav>
      </div>
    </header>

    <main class="container layout">
      <aside class="left-nav">
        
        <div class="card">
          <div class="card-title">文章目录</div>
          <nav id="toc"><ul><li><a href="#__create_page_tables">恒等映射与内核镜像映射__create_page_tables</a><ul><li><a href="#_1">恒等映射</a></li><li><a href="#_2">粗粒度的内核映像映射</a></li></ul></li><li><a href="#fixmap">fixmap映射</a><ul><li><a href="#fixmap_1">fixmap空间分类</a></li><li><a href="#fixmap_2">fixmap初始化</a></li><li><a href="#fixmap_3">fixmap相关函数</a></li><li><a href="#fixmap-io">fixmap io映射</a></li><li><a href="#fixmap-dtb">fixmap DTB映射</a></li></ul></li><li><a href="#memblock">Memblock</a><ul><li><a href="#_3">获取物理内存大小</a></li><li><a href="#_4">管理结构体</a></li><li><a href="#memblock_1">memblock主要接口函数</a></li><li><a href="#arm64-memblock-init">Arm64 memblock init</a></li></ul></li><li><a href="#paging_init">paging_init</a><ul><li><a href="#pgd">构建PGD映射表</a></li><li><a href="#early_pgtable_alloc">early_pgtable_alloc</a></li><li><a href="#-map_kernel">内核镜像细粒度映射-map_kernel</a></li><li><a href="#-map_mem">线性映射-map_mem</a></li><li><a href="#__create_pgd_mapping">__create_pgd_mapping</a></li></ul></li><li><a href="#bootmem_init">bootmem_init</a><ul><li><a href="#sparse_init">sparse_init</a></li><li><a href="#zone_sizes_init">zone_sizes_init</a></li></ul></li><li><a href="#build_all_zonelists">build_all_zonelists</a><ul></ul></li></ul></nav>
        </div>
        
      </aside>

      <section class="content">
        
<article class="card post">
  <h1>内存初始化之物理内存初始化</h1>
  <div class="meta">
    <span class="meta-item">
      <i class="icon">🕒</i>
      2023-07-01
    </span>
    <span class="meta-item">
      <i class="icon">📂</i>
      linux
    </span>
    <span class="meta-item">
      <i class="icon">👤</i>
      laumy
    </span>
  </div>
  <div class="post-content"><h2 id="__create_page_tables">恒等映射与内核镜像映射__create_page_tables</h2>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_0799025c3a2daf03a2a31ced36b88d37.jpg"><img alt="" src="assets/doc/01-linux/内存管理/内存初始化之物理内存初始化（一）/images/wp_editor_md_0799025c3a2daf03a2a31ced36b88d37.jpg"/></a></p>
<ul>
<li>preserve_boot_args：保持启动参数到boot_args[]数组</li>
<li>set_cpu_boot_maode_flag：设置关于cpu boot相关的全局变量</li>
<li>__create_page_tables：创建恒等映射页表，内核映像映射页表</li>
<li>__cpu_setup：为打开mmu做一些cpu相关的初始化</li>
<li>__primary_switch：启动mmu，并跳转start_kernel()函数</li>
</ul>
<h3 id="_1">恒等映射</h3>
<p>（text：__idmap_text_start~__idmap_text_end/data：idmap_pg_dir~idmap_pg_end）</p>
<p>一旦启动MMU就需要使用虚拟地址，现代处理器大多数是多级流水线，处理器会提前预取多条指令到流水线中，打开MMU时，这些指令都是物理地址预取的；在MMU开启后，将以虚拟地址访问，这样就会出错，所以引入了“恒等映射”，即在过渡阶段的代码，虚拟地址和物理地址相等。恒等映射完成后，就启动MMU，进入虚拟地址访问阶段。恒等映射的代码在 __idmap_text_start~__idmap_text_end，可以从System.map文件中查询到。</p>
<div class="codehilite"><pre><span></span><code><span class="n">kernel</span><span class="o">/</span><span class="n">build</span><span class="o">/</span><span class="n">System</span><span class="p">.</span><span class="n">map</span>

<span class="n">ffffffc00899b000</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">__idmap_text_start</span>
<span class="n">ffffffc00899b000</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">init_kernel_el</span>
<span class="n">ffffffc00899b00c</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">init_el1</span>
<span class="n">ffffffc00899b034</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">init_el2</span>
<span class="n">ffffffc00899b1e8</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">__cpu_stick_to_vhe</span>
<span class="n">ffffffc00899b1f8</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">set_cpu_boot_mode_flag</span>
<span class="n">ffffffc00899b21c</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">secondary_holding_pen</span>
<span class="n">ffffffc00899b240</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">pen</span>
<span class="n">ffffffc00899b254</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">secondary_entry</span>
<span class="n">ffffffc00899b260</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">secondary_startup</span>
<span class="n">ffffffc00899b27c</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">__secondary_switched</span>
<span class="n">ffffffc00899b310</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">__secondary_too_slow</span>
<span class="n">ffffffc00899b31c</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">__enable_mmu</span>
<span class="n">ffffffc00899b37c</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">__cpu_secondary_check52bitva</span>
<span class="n">ffffffc00899b380</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">__no_granule_support</span>
<span class="n">ffffffc00899b3a4</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">__relocate_kernel</span>
<span class="n">ffffffc00899b3ec</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">__primary_switch</span>
<span class="n">ffffffc00899b428</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">enter_vhe</span>
<span class="n">ffffffc00899b460</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">cpu_resume</span>
<span class="n">ffffffc00899b488</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">cpu_do_resume</span>
<span class="n">ffffffc00899b52c</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">idmap_cpu_replace_ttbr1</span>
<span class="n">ffffffc00899b560</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">__idmap_kpti_flag</span>
<span class="n">ffffffc00899b564</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">idmap_kpti_install_ng_mappings</span>
<span class="n">ffffffc00899b5a0</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">do_pgd</span>
<span class="n">ffffffc00899b5b8</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">next_pgd</span>
<span class="n">ffffffc00899b5c8</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">skip_pgd</span>
<span class="n">ffffffc00899b608</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">walk_puds</span>
<span class="n">ffffffc00899b610</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">next_pud</span>
<span class="n">ffffffc00899b614</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">walk_pmds</span>
<span class="n">ffffffc00899b61c</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">do_pmd</span>
<span class="n">ffffffc00899b634</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">next_pmd</span>
<span class="n">ffffffc00899b644</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">skip_pmd</span>
<span class="n">ffffffc00899b654</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">walk_ptes</span>
<span class="n">ffffffc00899b65c</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">do_pte</span>
<span class="n">ffffffc00899b680</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">skip_pte</span>
<span class="n">ffffffc00899b690</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">__idmap_kpti_secondary</span>
<span class="n">ffffffc00899b6d8</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">__cpu_setup</span>
<span class="n">ffffffc00899b7dc</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">__idmap_text_end</span>
</code></pre></div>
<p>恒等映射目的就是为__idmap_text_start~__idmap_text_end这段代码创建一个映射页表，使其虚拟地址和物理地址是相等的。在vmlinux.lds.S中，事先已经分配了IDMAP_DIR_SIZE的空间用于存储页表，通常器页表为3个连续的4KB页面，分别对于PGD,PUD,PMD页表，这里没有使用PTE，所以粒度是2MB的大小。</p>
<div class="codehilite"><pre><span></span><code><span class="n">arch</span><span class="o">/</span><span class="n">arm64</span><span class="o">/</span><span class="n">kernel</span><span class="o">/</span><span class="n">vmlinux</span><span class="p">.</span><span class="n">lds</span><span class="p">.</span><span class="n">S</span>

<span class="w">    </span><span class="n">idmap_pg_dir</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.;</span>
<span class="w">    </span><span class="p">.</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">IDMAP_DIR_SIZE</span><span class="p">;</span>
<span class="w">    </span><span class="n">idmap_pg_end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.;</span>
</code></pre></div>
<h3 id="_2">粗粒度的内核映像映射</h3>
<p>（text: kernel_text / data：init_pg_dir~init_pg_end）</p>
<p>之所以要创建第二个页表，是因为cpu刚启动时，物理内存一般都在低地址（不过超过256TB），恒等映射的地址实际也在用户空间，即MMU启用后idmap_pg_dir会填入TTBR0，而内核空间链接地址（虚拟地址）都是在高地址，需要填入TTBR1，因此需要再创建一张表，映射整个内核镜像，且虚拟地址空间是再高地址0xffff xxxx xxxx xxxx</p>
<div class="codehilite"><pre><span></span><code><span class="n">arch</span><span class="o">/</span><span class="n">arm64</span><span class="o">/</span><span class="n">kernel</span><span class="o">/</span><span class="n">head</span><span class="p">.</span><span class="n">S</span>
<span class="cm">/*</span>
<span class="cm">     * Map the kernel image (starting with PHYS_OFFSET).</span>
<span class="cm">     */</span>

<span class="w">    </span><span class="c1">///调用map_memory宏建立整个内核镜像代码段  的映射页表；</span>
<span class="w">    </span><span class="cm">/**************************************************************************</span>
<span class="cm">     * 为什么要建第二张表？</span>
<span class="cm">     * CPU刚启动时，物理内存一般都在低地址(不会超过256T大小)，恒等映射的地址实际在用户空间了，</span>
<span class="cm">     * 即MMU启用后idmap_pg_dir会填入TTBR0;</span>
<span class="cm">     * 而内核空间的链接地址都是在高地址(内核空间在高地址)，需要填入TTBR1；</span>
<span class="cm">     * 因此，这里再建一张表，映射整个内核镜像，且虚拟地址空间是在高地址区0xffffxxxx xxxx xxxx</span>

<span class="cm">     * 注：init_pg_dir和idmap_pg_dir两个页表映射区别：</span>
<span class="cm">     * (1)init_pg_dir映射的虚拟地址在高位0xffff xxxx xxxx xxxx;</span>
<span class="cm">     *   idmap_pg_dir映射的虚拟地址在低位0x0000 xxxx xxxx xxxx;</span>
<span class="cm">     *   MMU启用后，init_pg_dir填入TTBR1,idmap_pg_dir填入TTBR0；</span>
<span class="cm">     * (2)init_pg_dir映射大小是整个内核镜像，idmap_pg_dir映射2M, 只是内存访问过渡，成功开启MMU即可；</span>
<span class="cm">     ***************************************************************************/</span>
<span class="w">    </span><span class="n">adrp</span><span class="w">    </span><span class="n">x0</span><span class="p">,</span><span class="w"> </span><span class="n">init_pg_dir</span>
<span class="w">    </span><span class="n">mov_q</span><span class="w">   </span><span class="n">x5</span><span class="p">,</span><span class="w"> </span><span class="n">KIMAGE_VADDR</span><span class="w">        </span><span class="c1">// compile time __va(_text)</span>
<span class="w">    </span><span class="n">add</span><span class="w"> </span><span class="n">x5</span><span class="p">,</span><span class="w"> </span><span class="n">x5</span><span class="p">,</span><span class="w"> </span><span class="n">x23</span><span class="w">         </span><span class="c1">// add KASLR displacement</span>
<span class="w">    </span><span class="n">mov</span><span class="w"> </span><span class="n">x4</span><span class="p">,</span><span class="w"> </span><span class="n">PTRS_PER_PGD</span>
<span class="w">    </span><span class="n">adrp</span><span class="w">    </span><span class="n">x6</span><span class="p">,</span><span class="w"> </span><span class="n">_end</span><span class="w">            </span><span class="c1">// runtime __pa(_end)</span>
<span class="w">    </span><span class="n">adrp</span><span class="w">    </span><span class="n">x3</span><span class="p">,</span><span class="w"> </span><span class="n">_text</span><span class="w">           </span><span class="c1">// runtime __pa(_text)</span>
<span class="w">    </span><span class="n">sub</span><span class="w"> </span><span class="n">x6</span><span class="p">,</span><span class="w"> </span><span class="n">x6</span><span class="p">,</span><span class="w"> </span><span class="n">x3</span><span class="w">          </span><span class="c1">// _end - _text</span>
<span class="n">add</span><span class="w"> </span><span class="n">x6</span><span class="p">,</span><span class="w"> </span><span class="n">x6</span><span class="p">,</span><span class="w"> </span><span class="n">x5</span><span class="w">          </span><span class="c1">// runtime __va(_end)</span>

<span class="w">    </span><span class="n">map_memory</span><span class="w"> </span><span class="n">x0</span><span class="p">,</span><span class="w"> </span><span class="n">x1</span><span class="p">,</span><span class="w"> </span><span class="n">x5</span><span class="p">,</span><span class="w"> </span><span class="n">x6</span><span class="p">,</span><span class="w"> </span><span class="n">x7</span><span class="p">,</span><span class="w"> </span><span class="n">x3</span><span class="p">,</span><span class="w"> </span><span class="n">x4</span><span class="p">,</span><span class="w"> </span><span class="n">x10</span><span class="p">,</span><span class="w"> </span><span class="n">x11</span><span class="p">,</span><span class="w"> </span><span class="n">x12</span><span class="p">,</span><span class="w"> </span><span class="n">x13</span><span class="p">,</span><span class="w"> </span><span class="n">x14</span>
</code></pre></div>
<h2 id="fixmap">fixmap映射</h2>
<p>先创建好页表，建立好虚拟地址到物理地址的映射关系。</p>
<p>Linux内核要访问物理内存，一旦开启MMU后，就只能通过虚拟地址查询页表找到物理地址进行访问，上一章节中建立恒等映射和粗粒度内核映像映射的页表，因此只能保证内核镜像正常访问。如果要解析DTB，访问设备IO等依然是无法访问的，因为查询不到对应的页表。因此内核引入了fixmap机制，就是事先分配一段虚拟地址空间，然后给定其虚拟地址创建好页表，页表中的表项最后一级指向的物理页帧号先不填充，等到实际要访问那段物理内存后再将其填充，内后通过fixmap这段虚拟地址范围就可以通过查询页表访问到物理内存。 Fixmap最关键要实现的目的就是将一段空间的虚拟地址与物理地址对应上，linux内核通过虚拟地址访问到物理空间，那既然是通过虚拟地址访问到物理地址，那必须构建填充这段虚拟地址到物理地址的页表，这样Linux内核经过MMU利用查找页表找到对应的物理地址进行访问。</p>
<h3 id="fixmap_1">fixmap空间分类</h3>
<p>Fixmap是一段固定范围的虚拟地址，在其在编译的时候就确定好了。下面是添加一段打印可以查看FIXMAP区域的各小段的地址范围。</p>
<div class="codehilite"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="nf">early_fixmap_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">pgd_t</span><span class="w"> </span><span class="o">*</span><span class="n">pgdp</span><span class="p">;</span>
<span class="w">    </span><span class="n">p4d_t</span><span class="w"> </span><span class="o">*</span><span class="n">p4dp</span><span class="p">,</span><span class="w"> </span><span class="n">p4d</span><span class="p">;</span>
<span class="w">    </span><span class="n">pud_t</span><span class="w"> </span><span class="o">*</span><span class="n">pudp</span><span class="p">;</span>
<span class="w">    </span><span class="n">pmd_t</span><span class="w"> </span><span class="o">*</span><span class="n">pmdp</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FIXADDR_START</span><span class="p">;</span>

<span class="w">    </span><span class="n">pgdp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pgd_offset_k</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
<span class="w">    </span><span class="n">p4dp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p4d_offset</span><span class="p">(</span><span class="n">pgdp</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">);</span>
<span class="w">    </span><span class="n">printk</span><span class="p">(</span><span class="err">\</span><span class="s">"FIX_HOLE             :0x%lx</span><span class="se">\\</span><span class="s">n</span><span class="se">\"</span><span class="s">,__fix_to_virt(FIX_HOLE));</span>
<span class="w">    </span><span class="n">printk</span><span class="p">(</span><span class="err">\</span><span class="s">"FIX_FDT_END          :0x%lx</span><span class="se">\\</span><span class="s">n</span><span class="se">\"</span><span class="s">,__fix_to_virt(FIX_FDT_END));</span>
<span class="w">    </span><span class="n">printk</span><span class="p">(</span><span class="err">\</span><span class="s">"FIX_FDT              :0x%lx</span><span class="se">\\</span><span class="s">n</span><span class="se">\"</span><span class="s">,__fix_to_virt(FIX_FDT));</span>
<span class="w">    </span><span class="n">printk</span><span class="p">(</span><span class="err">\</span><span class="s">"FIX_EARLYCON_MEM_BASE:0x%lx</span><span class="se">\\</span><span class="s">n</span><span class="se">\"</span><span class="s">,__fix_to_virt(FIX_EARLYCON_MEM_BASE));</span>
<span class="w">    </span><span class="n">printk</span><span class="p">(</span><span class="err">\</span><span class="s">"FIX_BTMAP_END        :0x%lx</span><span class="se">\\</span><span class="s">n</span><span class="se">\"</span><span class="s">,__fix_to_virt(FIX_BTMAP_END));</span>
<span class="w">    </span><span class="n">printk</span><span class="p">(</span><span class="err">\</span><span class="s">"FIX_BTMAP_BEGIN      :0x%lx</span><span class="se">\\</span><span class="s">n</span><span class="se">\"</span><span class="s">,__fix_to_virt(FIX_BTMAP_BEGIN));</span>
<span class="w">    </span><span class="n">printk</span><span class="p">(</span><span class="err">\</span><span class="s">"FIX_PTE              :0x%lx</span><span class="se">\\</span><span class="s">n</span><span class="se">\"</span><span class="s">,__fix_to_virt(FIX_PTE));</span>
<span class="w">    </span><span class="n">printk</span><span class="p">(</span><span class="err">\</span><span class="s">"FIX_PMD              :0x%lx</span><span class="se">\\</span><span class="s">n</span><span class="se">\"</span><span class="s">,__fix_to_virt(FIX_PMD));</span>
<span class="w">    </span><span class="n">printk</span><span class="p">(</span><span class="err">\</span><span class="s">"FIX_PUD              :0x%lx</span><span class="se">\\</span><span class="s">n</span><span class="se">\"</span><span class="s">,__fix_to_virt(FIX_PUD));</span>
<span class="w">    </span><span class="n">printk</span><span class="p">(</span><span class="err">\</span><span class="s">"FIX_PGD              :0x%lx</span><span class="se">\\</span><span class="s">n</span><span class="se">\"</span><span class="s">,__fix_to_virt(FIX_PGD));</span>
<span class="w">    </span><span class="n">printk</span><span class="p">(</span><span class="err">\</span><span class="s">"FIXADDR_START~TOP    :0x%lx - 0x%lx   (%6ld KB)</span><span class="se">\\</span><span class="s">n</span><span class="se">\"</span><span class="s">,</span>
<span class="w">            </span><span class="n">FIXADDR_START</span><span class="p">,</span><span class="n">FIXADDR_TOP</span><span class="p">,(</span><span class="n">FIXADDR_TOP</span><span class="o">-</span><span class="n">FIXADDR_START</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span>
<span class="w">    </span><span class="p">.......</span>
<span class="p">}</span>
</code></pre></div>
<div class="codehilite"><pre><span></span><code><span class="p">[</span><span class="w">    </span><span class="mf">0.000000</span><span class="p">]</span><span class="w"> </span><span class="n">FIX_HOLE</span><span class="w">             </span><span class="o">:</span><span class="mh">0xfffffffdfe000000</span><span class="w"> </span><span class="c1">//0x000007FFFFFFEFF0</span>
<span class="p">[</span><span class="w">    </span><span class="mf">0.000000</span><span class="p">]</span><span class="w"> </span><span class="n">FIX_FDT_END</span><span class="w">          </span><span class="o">:</span><span class="mh">0xfffffffdfdfff000</span>
<span class="p">[</span><span class="w">    </span><span class="mf">0.000000</span><span class="p">]</span><span class="w"> </span><span class="n">FIX_FDT</span><span class="w">               </span><span class="o">:</span><span class="mh">0xfffffffdfdc00000</span><span class="w"> </span><span class="c1">//0x000007FFFFFFEFEE</span>
<span class="p">[</span><span class="w">    </span><span class="mf">0.000000</span><span class="p">]</span><span class="w"> </span><span class="n">FIX_EARLYCON_MEM_BASE</span><span class="o">:</span><span class="mh">0xfffffffdfdbff000</span>
<span class="p">[</span><span class="w">    </span><span class="mf">0.000000</span><span class="p">]</span><span class="w"> </span><span class="n">FIX_BTMAP_END</span><span class="w">        </span><span class="o">:</span><span class="mh">0xfffffffdfdbf9000</span><span class="w"> </span>
<span class="p">[</span><span class="w">    </span><span class="mf">0.000000</span><span class="p">]</span><span class="w"> </span><span class="n">FIX_BTMAP_BEGIN</span><span class="w">      </span><span class="o">:</span><span class="mh">0xfffffffdfda3a000</span>
<span class="p">[</span><span class="w">    </span><span class="mf">0.000000</span><span class="p">]</span><span class="w"> </span><span class="n">FIX_PTE</span><span class="w">              </span><span class="o">:</span><span class="mh">0xfffffffdfda39000</span>
<span class="p">[</span><span class="w">    </span><span class="mf">0.000000</span><span class="p">]</span><span class="w"> </span><span class="n">FIX_PMD</span><span class="w">              </span><span class="o">:</span><span class="mh">0xfffffffdfda38000</span>
<span class="p">[</span><span class="w">    </span><span class="mf">0.000000</span><span class="p">]</span><span class="w"> </span><span class="n">FIX_PUD</span><span class="w">              </span><span class="o">:</span><span class="mh">0xfffffffdfda37000</span>
<span class="p">[</span><span class="w">    </span><span class="mf">0.000000</span><span class="p">]</span><span class="w"> </span><span class="n">FIX_PGD</span><span class="w">              </span><span class="o">:</span><span class="mh">0xfffffffdfda36000</span><span class="w"> </span><span class="c1">//0x000007FFFFFFEFED</span>
<span class="p">[</span><span class="w">    </span><span class="mf">0.000000</span><span class="p">]</span><span class="w"> </span><span class="n">FIXADDR_START</span><span class="o">~</span><span class="n">TOP</span><span class="w">    </span><span class="o">:</span><span class="mh">0xfffffffdfdbf9000</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mh">0xfffffffdfe000000</span><span class="w">   </span><span class="p">(</span><span class="w">  </span><span class="mi">4124</span><span class="w"> </span><span class="n">KB</span><span class="p">)</span>
</code></pre></div>
<p>上面0xfffffffdfdbf9000 - 0xfffffffdfe000000这段虚拟地址范围就是fixed map区域，这段区域可以通过FIXADDR_START和FIXADDR_TOP来确定。Fixmap虚拟地址平均分成两个部分，两个部分permanent fixed addresses和temporary fixed addresses。permanent fixed addresses是永久映射，temporary fixed addresses是临时映射。永久映射是指在建立的映射关系在kernel阶段不会改变，仅供特定模块一直使用。临时映射就是模块使用前创建映射，使用后解除映射。fixmap区域又被继续细分，分配给不同模块使用。kernel中定义枚举类型作为index，根据index可以计算在fixmap区域的虚拟地址。</p>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_23663a9fb10854c6c0043aad12af115c.jpg"><img alt="" src="assets/doc/01-linux/内存管理/内存初始化之物理内存初始化（一）/images/wp_editor_md_23663a9fb10854c6c0043aad12af115c.jpg"/></a></p>
<div class="codehilite"><pre><span></span><code><span class="n">arch</span><span class="o">/</span><span class="n">arm64</span><span class="o">/</span><span class="n">include</span><span class="o">/</span><span class="k">asm</span><span class="o">/</span><span class="n">fixmap</span><span class="p">.</span><span class="n">h</span>
<span class="k">enum</span><span class="w"> </span><span class="n">fixed_addresses</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">FIX_HOLE</span><span class="p">,</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Reserve a virtual window for the FDT that is 2 MB larger than the</span>
<span class="cm">     * maximum supported size, and put it at the top of the fixmap region.</span>
<span class="cm">     * The additional space ensures that any FDT that does not exceed</span>
<span class="cm">     * MAX_FDT_SIZE can be mapped regardless of whether it crosses any</span>
<span class="cm">     * 2 MB alignment boundaries.</span>
<span class="cm">     *</span>
<span class="cm">     * Keep this at the top so it remains 2 MB aligned.</span>
<span class="cm">     */</span>
<span class="cp">#define FIX_FDT_SIZE        (MAX_FDT_SIZE + SZ_2M)</span>
<span class="w">    </span><span class="n">FIX_FDT_END</span><span class="p">,</span>
<span class="w">    </span><span class="n">FIX_FDT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FIX_FDT_END</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">FIX_FDT_SIZE</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">PAGE_SIZE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">    </span><span class="n">FIX_EARLYCON_MEM_BASE</span><span class="p">,</span>
<span class="w">    </span><span class="n">FIX_TEXT_POKE0</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_ACPI_APEI_GHES</span>
<span class="w">    </span><span class="cm">/* Used for GHES mapping from assorted contexts */</span>
<span class="w">    </span><span class="n">FIX_APEI_GHES_IRQ</span><span class="p">,</span>
<span class="w">    </span><span class="n">FIX_APEI_GHES_SEA</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_ARM_SDE_INTERFACE</span>
<span class="w">    </span><span class="n">FIX_APEI_GHES_SDEI_NORMAL</span><span class="p">,</span>
<span class="w">    </span><span class="n">FIX_APEI_GHES_SDEI_CRITICAL</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_ACPI_APEI_GHES */</span>

<span class="cp">#ifdef CONFIG_UNMAP_KERNEL_AT_EL0</span>
<span class="w">    </span><span class="n">FIX_ENTRY_TRAMP_TEXT3</span><span class="p">,</span>
<span class="w">    </span><span class="n">FIX_ENTRY_TRAMP_TEXT2</span><span class="p">,</span>
<span class="w">    </span><span class="n">FIX_ENTRY_TRAMP_TEXT1</span><span class="p">,</span>
<span class="w">    </span><span class="n">FIX_ENTRY_TRAMP_DATA</span><span class="p">,</span>
<span class="cp">#define TRAMP_VALIAS        (__fix_to_virt(FIX_ENTRY_TRAMP_TEXT1))</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_UNMAP_KERNEL_AT_EL0 */</span>
<span class="w">    </span><span class="n">__end_of_permanent_fixed_addresses</span><span class="p">,</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Temporary boot-time mappings, used by early_ioremap(),</span>
<span class="cm">     * before ioremap() is functional.</span>
<span class="cm">     */</span>
<span class="cp">#define NR_FIX_BTMAPS       (SZ_256K / PAGE_SIZE)</span>
<span class="cp">#define FIX_BTMAPS_SLOTS    7</span>
<span class="cp">#define TOTAL_FIX_BTMAPS    (NR_FIX_BTMAPS * FIX_BTMAPS_SLOTS)</span>

<span class="w">    </span><span class="n">FIX_BTMAP_END</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__end_of_permanent_fixed_addresses</span><span class="p">,</span>
<span class="w">    </span><span class="n">FIX_BTMAP_BEGIN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FIX_BTMAP_END</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">TOTAL_FIX_BTMAPS</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Used for kernel page table creation, so unmapped memory may be used</span>
<span class="cm">     * for tables.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="n">FIX_PTE</span><span class="p">,</span>
<span class="w">    </span><span class="n">FIX_PMD</span><span class="p">,</span>
<span class="w">    </span><span class="n">FIX_PUD</span><span class="p">,</span>
<span class="w">    </span><span class="n">FIX_PGD</span><span class="p">,</span>

<span class="w">    </span><span class="n">__end_of_fixed_addresses</span>
<span class="p">};</span>

<span class="cp">#define FIXADDR_SIZE    (__end_of_permanent_fixed_addresses &lt;&lt; PAGE_SHIFT)</span>
<span class="cp">#define FIXADDR_START   (FIXADDR_TOP - FIXADDR_SIZE)</span>
</code></pre></div>
<h3 id="fixmap_2">fixmap初始化</h3>
<p>前面描述了，fixmap就是让一段固定的虚拟地址空间与一段物理空间建立映射，以便linux内核通过虚拟地址才能访问到对应物理地址的空间数据，虚拟地址到物理地址的转换是通过mmu查询页表得来的，因此需要构建填充虚拟地址到物理地址转换的页表。在linux内核中，页表存储通过定义了3个全局数组bm_pud,bm_pmd,bt_pte来存储。因此early_fixmap_init的目的来填充这几个数组（页表）。</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="n">pte_t</span><span class="w"> </span><span class="n">bm_pte</span><span class="p">[</span><span class="n">PTRS_PER_PTE</span><span class="p">]</span><span class="w"> </span><span class="n">__page_aligned_bss</span><span class="p">;</span>
<span class="k">static</span><span class="w"> </span><span class="n">pmd_t</span><span class="w"> </span><span class="n">bm_pmd</span><span class="p">[</span><span class="n">PTRS_PER_PMD</span><span class="p">]</span><span class="w"> </span><span class="n">__page_aligned_bss</span><span class="w"> </span><span class="n">__maybe_unused</span><span class="p">;</span>
<span class="k">static</span><span class="w"> </span><span class="n">pud_t</span><span class="w"> </span><span class="n">bm_pud</span><span class="p">[</span><span class="n">PTRS_PER_PUD</span><span class="p">]</span><span class="w"> </span><span class="n">__page_aligned_bss</span><span class="w"> </span><span class="n">__maybe_unused</span><span class="p">;</span>

<span class="n">没有建立PGD</span><span class="err">，</span><span class="n">PGD在swapper_pg_dir中</span><span class="err">，</span><span class="n">在内核镜像的数据段</span>

<span class="n">PTRS_PER_PTE</span><span class="o">/</span><span class="n">PMD</span><span class="o">/</span><span class="n">PUD为页表entry的数目</span>
<span class="cp">#define PTRS_PER_PTE        (1 &lt;&lt; (PAGE_SHIFT - 3))</span>
</code></pre></div>
<div class="codehilite"><pre><span></span><code><span class="n">arch</span><span class="o">/</span><span class="n">arm64</span><span class="o">/</span><span class="n">mm</span><span class="o">/</span><span class="n">mmu</span><span class="p">.</span><span class="n">c</span>
<span class="kt">void</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="n">early_fixmap_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">pgd_t</span><span class="w"> </span><span class="o">*</span><span class="n">pgd</span><span class="p">;</span>
<span class="n">p4d_t</span><span class="w"> </span><span class="o">*</span><span class="n">p4dp</span><span class="p">,</span><span class="w"> </span><span class="n">p4d</span><span class="p">;</span>
<span class="w">    </span><span class="n">pud_t</span><span class="w"> </span><span class="o">*</span><span class="n">pud</span><span class="p">;</span>
<span class="w">    </span><span class="n">pmd_t</span><span class="w"> </span><span class="o">*</span><span class="n">pmd</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FIXADDR_START</span><span class="p">;</span><span class="w"> </span><span class="err">（</span><span class="mi">1</span><span class="err">）</span><span class="n">FIXADDR_START定义了fixedmap区域的起始地址</span><span class="err">。</span>
<span class="w">    </span><span class="n">pgdp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pgd_offset_k</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span><span class="w"> </span>
<span class="n">p4dp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p4d_offset</span><span class="p">(</span><span class="n">pgdp</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">);</span><span class="c1">//3级页表中p4dp=pgd</span>
<span class="n">p4d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">READ_ONCE</span><span class="p">(</span><span class="o">*</span><span class="n">p4dp</span><span class="p">);</span><span class="c1">//读表项中的内容</span>
<span class="err">（</span><span class="mi">2</span><span class="err">）</span><span class="n">获取addr对应的pgd全局页表表项地址</span><span class="err">，</span><span class="n">页表是swapper_pg_dir的空间</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">CONFIG_PGTABLE_LEVELS</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">        </span><span class="o">!</span><span class="p">(</span><span class="n">pgd_none</span><span class="p">(</span><span class="o">*</span><span class="n">pgd</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">pgd_page_paddr</span><span class="p">(</span><span class="o">*</span><span class="n">pgd</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">__pa_symbol</span><span class="p">(</span><span class="n">bm_pud</span><span class="p">)))</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">pud</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pud_offset_kimg</span><span class="p">(</span><span class="n">pgd</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">         </span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="n">因为是3级页表p4d_node</span><span class="o">=</span><span class="mi">0</span><span class="err">，</span><span class="n">因此不会进入这里</span><span class="err">，</span><span class="n">也就是不会使用bm_pud</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p4d_none</span><span class="p">(</span><span class="n">p4d</span><span class="p">))</span>
<span class="w">            </span><span class="n">__p4d_populate</span><span class="p">(</span><span class="n">p4dp</span><span class="p">,</span><span class="w"> </span><span class="n">__pa_symbol</span><span class="p">(</span><span class="n">bm_pud</span><span class="p">),</span><span class="w"> </span><span class="n">P4D_TYPE_TABLE</span><span class="p">);</span><span class="w"> </span>
<span class="w">        </span><span class="n">pud</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fixmap_pud</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
<span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="n">获取addr在PUD页表项中的偏移地址</span><span class="err">，</span><span class="n">这里是3级页表</span><span class="err">，</span><span class="n">所以pud</span><span class="o">=</span><span class="n">pgdp</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pud_none</span><span class="p">(</span><span class="o">*</span><span class="n">pud</span><span class="p">))</span>
<span class="w">        </span><span class="n">__pud_populate</span><span class="p">(</span><span class="n">pud</span><span class="p">,</span><span class="w"> </span><span class="n">__pa_symbol</span><span class="p">(</span><span class="n">bm_pmd</span><span class="p">),</span><span class="w"> </span><span class="n">PMD_TYPE_TABLE</span><span class="p">);</span><span class="w"> </span>
<span class="w">       </span><span class="err">（</span><span class="mi">5</span><span class="err">）</span><span class="n">将bm_pmd的物理地址写到pgd页表对应表项中</span>
<span class="w">    </span><span class="n">pmd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fixmap_pmd</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
<span class="w">    </span><span class="err">（</span><span class="mi">6</span><span class="err">）</span><span class="n">获取addr在对应页表中表项的地址</span><span class="err">（</span><span class="n">虚拟地址</span><span class="err">）。</span>
<span class="w">    </span><span class="n">__pmd_populate</span><span class="p">(</span><span class="n">pmd</span><span class="p">,</span><span class="w"> </span><span class="n">__pa_symbol</span><span class="p">(</span><span class="n">bm_pte</span><span class="p">),</span><span class="w"> </span><span class="n">PMD_TYPE_TABLE</span><span class="p">);</span><span class="w"> </span>
<span class="err">（</span><span class="mi">7</span><span class="err">）</span><span class="n">将bm_pte的物理地址写到pmd页表中</span><span class="err">。</span>
<span class="p">}</span>
</code></pre></div>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_a43f5a5f0c5c2ac250675dd7c3dbf93e.jpg"><img alt="" src="assets/doc/01-linux/内存管理/内存初始化之物理内存初始化（一）/images/wp_editor_md_a43f5a5f0c5c2ac250675dd7c3dbf93e.jpg"/></a></p>
<p>TIPS:当使用3级页表时，内核如何判断是否需要创建PUD页表？</p>
<div class="codehilite"><pre><span></span><code><span class="n">arch</span><span class="o">/</span><span class="n">arm64</span><span class="o">/</span><span class="n">include</span><span class="o">/</span><span class="k">asm</span><span class="o">/</span><span class="n">pgtable</span><span class="o">-</span><span class="n">types</span><span class="p">.</span><span class="n">h</span>

<span class="cp">#if CONFIG_PGTABLE_LEVELS == 2</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;asm-generic/pgtable-nopmd.h&gt;</span>
<span class="cp">#elif CONFIG_PGTABLE_LEVELS == 3</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;asm-generic/pgtable-nopud.h&gt;</span>
<span class="cp">#elif CONFIG_PGTABLE_LEVELS == 4</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;asm-generic/pgtable-nop4d.h&gt;</span>
<span class="cp">#endif</span>
</code></pre></div>
<p>从上可知，页表是3级页表时，包含的pud相关的头文件时#include <asm-generic pgtable-nopud.h=""></asm-generic></p>
<div class="codehilite"><pre><span></span><code><span class="n">include</span><span class="o">/</span><span class="k">asm</span><span class="o">-</span><span class="n">generic</span><span class="o">/</span><span class="n">pgtable</span><span class="o">-</span><span class="n">nopud</span><span class="p">.</span><span class="n">h</span>

<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">p4d_none</span><span class="p">(</span><span class="n">p4d_t</span><span class="w"> </span><span class="n">p4d</span><span class="p">)</span><span class="w">       </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="c1">//直接返回0</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">p4d_bad</span><span class="p">(</span><span class="n">p4d_t</span><span class="w"> </span><span class="n">p4d</span><span class="p">)</span><span class="w">        </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">p4d_present</span><span class="p">(</span><span class="n">p4d_t</span><span class="w"> </span><span class="n">p4d</span><span class="p">)</span><span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">p4d_clear</span><span class="p">(</span><span class="n">p4d_t</span><span class="w"> </span><span class="o">*</span><span class="n">p4d</span><span class="p">)</span><span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="p">}</span>
<span class="cp">#define p4d_populate(mm, p4d, pud)      do { } while (0)</span>
<span class="cp">#define p4d_populate_safe(mm, p4d, pud)     do { } while (0)</span>
<span class="cp">#define set_p4d(p4dptr, p4dval) set_pud((pud_t *)(p4dptr), (pud_t) { p4dval })</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="n">pud_t</span><span class="w"> </span><span class="o">*</span><span class="n">pud_offset</span><span class="p">(</span><span class="n">p4d_t</span><span class="w"> </span><span class="o">*</span><span class="n">p4d</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">address</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">pud_t</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">p4d</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#define pud_offset pud_offset</span>
<span class="cp">#define pud_val(x)              (p4d_val((x).p4d))</span>
<span class="cp">#define __pud(x)                ((pud_t) { __p4d(x) })</span>
<span class="cp">#define p4d_page(p4d)               (pud_page((pud_t){ p4d }))</span>
<span class="cp">#define p4d_pgtable(p4d)            ((pud_t *)(pud_pgtable((pud_t){ p4d })))</span>
<span class="cp">#define pud_alloc_one(mm, address)      NULL</span>
<span class="cp">#define pud_free(mm, x)             do { } while (0)</span>
<span class="cp">#define pud_free_tlb(tlb, x, a)             do { } while (0)</span>
<span class="cp">#undef  pud_addr_end</span>
<span class="cp">#define pud_addr_end(addr, end)         (end)</span>
</code></pre></div>
<p>实际上，early_fixmap_init只是建立了一个映射的框架，实际的物理地址和虚拟地址的映射关系是没有填充的，这个需要实际使用的时候再去填充对应的pte entry。 bm_pud/bm_pmd/bm_pte是全局数组（全局数据段），该阶段访问这几个全局数组的虚拟地址能够可以通过mmu转化为物理地址，因为这几个变量是属于内核映像中，在上一章节中内核镜像中的所有包括数据段、代码段等都可以进行访问了，因此这几个全局数组的虚拟地址是不需要映射的。</p>
<h3 id="fixmap_3">fixmap相关函数</h3>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_15bdb7e35e942367df40075724cada93.jpg"><img alt="" src="assets/doc/01-linux/内存管理/内存初始化之物理内存初始化（一）/images/wp_editor_md_15bdb7e35e942367df40075724cada93.jpg"/></a></p>
<div class="codehilite"><pre><span></span><code><span class="cp">#define pte_offset_phys(dir,addr)   (pmd_page_paddr(READ_ONCE(*(dir))) + pte_index(addr) * sizeof(pte_t))</span>
<span class="c1">//查找虚拟地址对应PTE的物理地址（基地址），也就是对应PMD条目中的值。</span>

<span class="cp">#define pte_set_fixmap(addr)        ((pte_t *)set_fixmap_offset(FIX_PTE, addr))</span>
<span class="c1">//获取addr（物理地址）对应的虚拟地址，其虚拟地址在FIX_PTE这个范围（建立映射）。</span>

<span class="cp">#define pte_set_fixmap_offset(pmd, addr)    pte_set_fixmap(pte_offset_phys(pmd, addr))</span>
<span class="c1">//获取addr在PTE页表项的虚拟地址，其虚拟地址范围在FIX_PTE这个范围（建立映射）。</span>

<span class="cp">#define pte_clear_fixmap()      clear_fixmap(FIX_PTE)</span>
<span class="c1">//清除FIX_PTE虚拟地址的映射</span>

<span class="cp">#define pmd_set_fixmap(addr)        ((pmd_t *)set_fixmap_offset(FIX_PMD, addr))</span>
<span class="cp">#define pmd_set_fixmap_offset(pud, addr)    pmd_set_fixmap(pmd_offset_phys(pud, addr))</span>
<span class="cp">#define pmd_clear_fixmap()      clear_fixmap(FIX_PMD)</span>

<span class="cp">#define pud_set_fixmap(addr)        ((pud_t *)set_fixmap_offset(FIX_PUD, addr))</span>
<span class="cp">#define pud_set_fixmap_offset(p4d, addr)    pud_set_fixmap(pud_offset_phys(p4d, addr))</span>
<span class="cp">#define pud_clear_fixmap()      clear_fixmap(FIX_PUD)</span>

<span class="cp">#define pgd_set_fixmap(addr)    ((pgd_t *)set_fixmap_offset(FIX_PGD, addr))</span>
<span class="cp">#define pgd_clear_fixmap()  clear_fixmap(FIX_PGD)</span>
</code></pre></div>
<h3 id="fixmap-io">fixmap io映射</h3>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">__iomem</span><span class="w"> </span><span class="o">*</span><span class="n">prev_map</span><span class="p">[</span><span class="n">FIX_BTMAPS_SLOTS</span><span class="p">]</span><span class="w"> </span><span class="n">__initdata</span><span class="p">;</span>
<span class="k">static</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">prev_size</span><span class="p">[</span><span class="n">FIX_BTMAPS_SLOTS</span><span class="p">]</span><span class="w"> </span><span class="n">__initdata</span><span class="p">;</span>
<span class="k">static</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">slot_virt</span><span class="p">[</span><span class="n">FIX_BTMAPS_SLOTS</span><span class="p">]</span><span class="w"> </span><span class="n">__initdata</span><span class="p">;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="nf">early_ioremap_setup</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">FIX_BTMAPS_SLOTS</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">prev_map</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">FIX_BTMAPS_SLOTS</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="n">slot_virt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__fix_to_virt</span><span class="p">(</span><span class="n">FIX_BTMAP_BEGIN</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">NR_FIX_BTMAPS</span><span class="o">*</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Ioremap的空间存放再slot_vir数组中，其虚拟地址空间每一个跨度为NR_FIX_BITMAPS。</p>
<p>实际进行IO映射的时候，会调用到__early_ioremap函数，在该函数中回去填充pte entry，这样虚拟地址和io设备的物理地址就匹配上了。</p>
<h3 id="fixmap-dtb">fixmap DTB映射</h3>
<div class="codehilite"><pre><span></span><code><span class="n">arch</span><span class="o">/</span><span class="n">arm64</span><span class="o">/</span><span class="n">kernel</span><span class="o">/</span><span class="n">setup</span><span class="p">.</span><span class="n">c</span>

<span class="n">setup_machine_fdt</span><span class="o">-&gt;</span>

<span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">__init</span><span class="w"> </span><span class="n">fixmap_remap_fdt</span><span class="p">(</span><span class="n">phys_addr_t</span><span class="w"> </span><span class="n">dt_phys</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">pgprot_t</span><span class="w"> </span><span class="n">prot</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">u64</span><span class="w"> </span><span class="n">dt_virt_base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__fix_to_virt</span><span class="p">(</span><span class="n">FIX_FDT</span><span class="p">);</span><span class="w"> </span><span class="c1">//从FIXMAP中获取设备树的虚拟地址</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">offset</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">dt_virt</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Check whether the physical FDT address is set and meets the minimum</span>
<span class="cm">     * alignment requirement. Since we are relying on MIN_FDT_ALIGN to be</span>
<span class="cm">     * at least 8 bytes so that we can always access the magic and size</span>
<span class="cm">     * fields of the FDT header after mapping the first chunk, double check</span>
<span class="cm">     * here if that is indeed the case.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">MIN_FDT_ALIGN</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">dt_phys</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">dt_phys</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">MIN_FDT_ALIGN</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Make sure that the FDT region can be mapped without the need to</span>
<span class="cm">     * allocate additional translation table pages, so that it is safe</span>
<span class="cm">     * to call create_mapping_noalloc() this early.</span>
<span class="cm">     *</span>
<span class="cm">     * On 64k pages, the FDT will be mapped using PTEs, so we need to</span>
<span class="cm">     * be in the same PMD as the rest of the fixmap.</span>
<span class="cm">     * On 4k pages, we\'ll use section mappings for the FDT so we only</span>
<span class="cm">     * have to be in the same PUD.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">dt_virt_base</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">SZ_2M</span><span class="p">);</span>

<span class="w">    </span><span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">__fix_to_virt</span><span class="p">(</span><span class="n">FIX_FDT_END</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">SWAPPER_TABLE_SHIFT</span><span class="w"> </span><span class="o">!=</span>
<span class="w">             </span><span class="n">__fix_to_virt</span><span class="p">(</span><span class="n">FIX_BTMAP_BEGIN</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">SWAPPER_TABLE_SHIFT</span><span class="p">);</span>

<span class="w">    </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dt_phys</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">SWAPPER_BLOCK_SIZE</span><span class="p">;</span>
<span class="w">    </span><span class="n">dt_virt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">dt_virt_base</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">offset</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* map the first chunk so we can read the size from the header */</span>
<span class="w">    </span><span class="n">create_mapping_noalloc</span><span class="p">(</span><span class="n">round_down</span><span class="p">(</span><span class="n">dt_phys</span><span class="p">,</span><span class="w"> </span><span class="n">SWAPPER_BLOCK_SIZE</span><span class="p">),</span>
<span class="w">            </span><span class="n">dt_virt_base</span><span class="p">,</span><span class="w"> </span><span class="n">SWAPPER_BLOCK_SIZE</span><span class="p">,</span><span class="w"> </span><span class="n">prot</span><span class="p">);</span>
<span class="w">    </span><span class="c1">//根据提供的物理地址和虚拟地址设置页表entry，建立dbt物理地址到fixmap中虚拟地址的映射</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fdt_magic</span><span class="p">(</span><span class="n">dt_virt</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">FDT_MAGIC</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="c1">//获取dtb文件大小</span>
<span class="o">*</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fdt_totalsize</span><span class="p">(</span><span class="n">dt_virt</span><span class="p">);</span>
<span class="c1">//DTB的大小不能超过2M</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">size</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">MAX_FDT_SIZE</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="c1">//如果DTB文件结尾的地址空间超过了上面建立的2M地址范围，需要紧接这再映射2M地址空间。</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">*</span><span class="n">size</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">SWAPPER_BLOCK_SIZE</span><span class="p">)</span>
<span class="w">        </span><span class="n">create_mapping_noalloc</span><span class="p">(</span><span class="n">round_down</span><span class="p">(</span><span class="n">dt_phys</span><span class="p">,</span><span class="w"> </span><span class="n">SWAPPER_BLOCK_SIZE</span><span class="p">),</span><span class="w"> </span><span class="n">dt_virt_base</span><span class="p">,</span>
<span class="w">                   </span><span class="n">round_up</span><span class="p">(</span><span class="n">offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">*</span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">SWAPPER_BLOCK_SIZE</span><span class="p">),</span><span class="w"> </span><span class="n">prot</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">dt_virt</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>TIPS：如何打开linux内核pr_debug相关的打印</p>
<div class="codehilite"><pre><span></span><code><span class="n">打开pr_debug的打印</span>

<span class="err">（</span><span class="mi">1</span><span class="err">）</span><span class="n">将Default</span><span class="w"> </span><span class="n">console</span><span class="w"> </span><span class="n">loglevel</span><span class="w"> </span><span class="n">设置到8</span>
<span class="w"> </span><span class="n">Kernel</span><span class="w"> </span><span class="n">hacking</span><span class="w"> </span>
<span class="o">&gt;</span><span class="w"> </span><span class="n">printk</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">dmesg</span><span class="w"> </span><span class="n">options</span>
<span class="p">(</span><span class="mi">8</span><span class="p">)</span><span class="n">Default</span><span class="w"> </span><span class="n">console</span><span class="w"> </span><span class="n">loglevel</span><span class="w"> </span><span class="p">(</span><span class="mi">1-15</span><span class="p">)</span>

<span class="err">（</span><span class="mi">2</span><span class="err">）</span><span class="n">在对应的模块上编译添加</span><span class="o">-</span><span class="n">DDEBUG宏</span>
<span class="n">diff</span><span class="w"> </span><span class="o">--</span><span class="n">git</span><span class="w"> </span><span class="n">a</span><span class="o">/</span><span class="n">drivers</span><span class="o">/</span><span class="n">of</span><span class="o">/</span><span class="n">Makefile</span><span class="w"> </span><span class="n">b</span><span class="o">/</span><span class="n">drivers</span><span class="o">/</span><span class="n">of</span><span class="o">/</span><span class="n">Makefile</span>
<span class="n">index</span><span class="w"> </span><span class="n">e0360a44306e</span><span class="p">.</span><span class="mf">.25</span><span class="n">bc584536b3</span><span class="w"> </span><span class="mi">100644</span>
<span class="o">---</span><span class="w"> </span><span class="n">a</span><span class="o">/</span><span class="n">drivers</span><span class="o">/</span><span class="n">of</span><span class="o">/</span><span class="n">Makefile</span>
<span class="o">+++</span><span class="w"> </span><span class="n">b</span><span class="o">/</span><span class="n">drivers</span><span class="o">/</span><span class="n">of</span><span class="o">/</span><span class="n">Makefile</span>
<span class="o">+</span><span class="n">ccflags</span><span class="o">-</span><span class="n">y</span><span class="w"> </span><span class="o">:=-</span><span class="n">DDEBUG</span>
</code></pre></div>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_ed6d752d1d9e8e158c2bd68dd3305e77.jpg"><img alt="" src="assets/doc/01-linux/内存管理/内存初始化之物理内存初始化（一）/images/wp_editor_md_ed6d752d1d9e8e158c2bd68dd3305e77.jpg"/></a></p>
<h2 id="memblock">Memblock</h2>
<p>Linux内核使用伙伴系统管理内存，在伙伴系统之前，内核通过memblock来管理。在系统启动阶段，使用memblock记录理内存的使用情况，可以分成好几块。 - 永久分配给系统内核：内核镜像占用的部分，如代码、数据段等；设备树DTB等 - 预留给外设的连续内存：如GPU/Camera/多核共享等需要预留大量连续内存。 - 其他部分：以上的剩余部分内存，需要进行内存管理。</p>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_f5ab56223e97582a9c49b7282b87bb9d.jpg"><img alt="" src="assets/doc/01-linux/内存管理/内存初始化之物理内存初始化（一）/images/wp_editor_md_f5ab56223e97582a9c49b7282b87bb9d.jpg"/></a></p>
<p>Memblock将以上内存按功能划分为若干内存区，使用不同的类型存放在memory和reserved两个集合中，memory即动态内存，reserved即静态分配的内存。</p>
<h3 id="_3">获取物理内存大小</h3>
<p>在设备树中，使用节点名称为memory来描述内存信息，如果系统中有多个内存范围，那么device tree中可能会创建多个内存节点，或者一个单独的内存节点通过reg属性指定内存的访问。</p>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_bc46cb00223ef61f78821936b736e7f2.jpg"><img alt="" src="assets/doc/01-linux/内存管理/内存初始化之物理内存初始化（一）/images/wp_editor_md_bc46cb00223ef61f78821936b736e7f2.jpg"/></a></p>
<p>假设一个64位系统具有以下的物理内存块： - RAM:起始地址0x0,长度0x80000000(2GB) - RAM：起始地址0x100000000,长度0x100000000(4GB) 方法一</p>
<div class="codehilite"><pre><span></span><code><span class="n">memory</span><span class="err">@</span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">　   </span><span class="n">device_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">\</span><span class="s">"memory</span><span class="se">\"</span><span class="s">; </span>
<span class="w">　   </span><span class="n">reg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mh">0x000000000</span><span class="w"> </span><span class="mh">0x00000000</span><span class="w"> </span><span class="mh">0x00000000</span><span class="w"> </span><span class="mh">0x80000000</span><span class="w"> </span>
<span class="w">　           </span><span class="mh">0x000000001</span><span class="w"> </span><span class="mh">0x00000000</span><span class="w"> </span><span class="mh">0x00000001</span><span class="w"> </span><span class="mh">0x00000000</span><span class="o">&gt;</span><span class="p">;</span><span class="w"> </span>
<span class="p">};</span>
<span class="n">第一个整数</span><span class="err">（</span><span class="mh">0x00000000</span><span class="err">）：</span><span class="n">表示物理地址的高32位</span><span class="err">。</span>
<span class="n">第二个整数</span><span class="err">（</span><span class="mh">0x00000000</span><span class="err">）：</span><span class="n">表示物理地址的低32位</span><span class="err">。</span><span class="n">在这个例子中</span><span class="err">，</span><span class="n">物理地址为0x00000000</span><span class="err">。</span>
<span class="n">第三个整数</span><span class="err">（</span><span class="mh">0x00000000</span><span class="err">）：</span><span class="n">表示大小的高32位</span><span class="err">。</span>
<span class="n">第四个整数</span><span class="err">（</span><span class="mh">0x80000000</span><span class="err">）：</span><span class="n">表示大小的低32位</span><span class="err">。</span><span class="n">在这个例子中</span><span class="err">，</span><span class="n">大小为0x80000000</span><span class="err">，</span><span class="n">即2GB</span><span class="err">。</span>
<span class="n">第五个整数</span><span class="err">（</span><span class="mh">0x00000001</span><span class="err">）：</span><span class="n">表示物理地址的高32位</span><span class="err">。</span>
<span class="n">第六个整数</span><span class="err">（</span><span class="mh">0x00000000</span><span class="err">）：</span><span class="n">表示物理地址的低32位</span><span class="err">。</span><span class="n">在这个例子中</span><span class="err">，</span><span class="n">物理地址为0x100000000</span><span class="err">。</span>
<span class="n">第七个整数</span><span class="err">（</span><span class="mh">0x00000001</span><span class="err">）：</span><span class="n">表示大小的高32位</span><span class="err">。</span>
<span class="n">第八个整数</span><span class="err">（</span><span class="mh">0x00000000</span><span class="err">）：</span><span class="n">表示大小的低32位</span><span class="err">。</span><span class="n">在这个例子中</span><span class="err">，</span><span class="n">大小为0x100000000</span><span class="err">，</span><span class="n">即4GB</span><span class="err">。</span>
</code></pre></div>
<p>方法二</p>
<div class="codehilite"><pre><span></span><code><span class="n">memory</span><span class="err">@</span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">　   </span><span class="n">device_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">\</span><span class="s">"memory</span><span class="se">\"</span><span class="s">; </span>
<span class="w">　   </span><span class="n">reg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mh">0x000000000</span><span class="w"> </span><span class="mh">0x00000000</span><span class="w"> </span><span class="mh">0x00000000</span><span class="w"> </span><span class="mh">0x80000000</span><span class="o">&gt;</span><span class="p">;</span><span class="w"> </span>
<span class="p">};</span><span class="w"> </span>
<span class="n">memory</span><span class="err">@</span><span class="mi">100000000</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">　   </span><span class="n">device_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">\</span><span class="s">"memory</span><span class="se">\"</span><span class="s">; </span>
<span class="w">　   </span><span class="n">reg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mh">0x000000001</span><span class="w"> </span><span class="mh">0x00000000</span><span class="w"> </span><span class="mh">0x00000001</span><span class="w"> </span><span class="mh">0x00000000</span><span class="o">&gt;</span><span class="p">;</span><span class="w"> </span>
<span class="p">};</span>
</code></pre></div>
<p>有些平台中在设备树中有时并没有去描述该节点，那是因为在uboot启动的时候会创建或改写该节点，实际的物理内存大小可能在boot0阶段就探测到了。</p>
<div class="codehilite"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">fdt_fixup_memory_banks</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">blob</span><span class="p">,</span><span class="w"> </span><span class="n">u64</span><span class="w"> </span><span class="n">start</span><span class="p">[],</span><span class="w"> </span><span class="n">u64</span><span class="w"> </span><span class="n">size</span><span class="p">[],</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">banks</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">err</span><span class="p">,</span><span class="w"> </span><span class="n">nodeoffset</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="n">u8</span><span class="w"> </span><span class="n">tmp</span><span class="p">[</span><span class="n">MEMORY_BANKS_MAX</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">16</span><span class="p">];</span><span class="w"> </span><span class="cm">/* Up to 64-bit address + 64-bit size */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">banks</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">MEMORY_BANKS_MAX</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="err">\</span><span class="s">"%s: num banks %d exceeds hardcoded limit %d.</span><span class="se">\"</span>
<span class="w">               </span><span class="err">\</span><span class="s">" Recompile with higher MEMORY_BANKS_MAX?</span><span class="se">\\</span><span class="s">n</span><span class="se">\"</span><span class="s">,</span>
<span class="w">               </span><span class="n">__FUNCTION__</span><span class="p">,</span><span class="w"> </span><span class="n">banks</span><span class="p">,</span><span class="w"> </span><span class="n">MEMORY_BANKS_MAX</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fdt_check_header</span><span class="p">(</span><span class="n">blob</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="err">\</span><span class="s">"%s: %s</span><span class="se">\\</span><span class="s">n</span><span class="se">\"</span><span class="s">, __FUNCTION__, fdt_strerror(err));</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">err</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cm">/* find or create \"/memory\" node. */</span>
<span class="w">    </span><span class="n">nodeoffset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fdt_find_or_add_subnode</span><span class="p">(</span><span class="n">blob</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="err">\</span><span class="s">"memory</span><span class="se">\"</span><span class="s">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">nodeoffset</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">nodeoffset</span><span class="p">;</span>
<span class="w">    </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fdt_setprop</span><span class="p">(</span><span class="n">blob</span><span class="p">,</span><span class="w"> </span><span class="n">nodeoffset</span><span class="p">,</span><span class="w"> </span><span class="err">\</span><span class="s">"device_type</span><span class="se">\"</span><span class="s">, </span><span class="se">\"</span><span class="s">memory</span><span class="se">\"</span><span class="s">,</span>
<span class="w">            </span><span class="k">sizeof</span><span class="p">(</span><span class="err">\</span><span class="s">"memory</span><span class="se">\"</span><span class="s">));</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="err">\</span><span class="s">"WARNING: could not set %s %s.</span><span class="se">\\</span><span class="s">n</span><span class="se">\"</span><span class="s">, </span><span class="se">\"</span><span class="s">device_type</span><span class="se">\"</span><span class="s">,</span>
<span class="w">                </span><span class="n">fdt_strerror</span><span class="p">(</span><span class="n">err</span><span class="p">));</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">err</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">banks</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">start</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">size</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">banks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">banks</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">banks</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">start</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">size</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="n">banks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fdt_pack_reg</span><span class="p">(</span><span class="n">blob</span><span class="p">,</span><span class="w"> </span><span class="n">tmp</span><span class="p">,</span><span class="w"> </span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">banks</span><span class="p">);</span>
<span class="w">    </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fdt_setprop</span><span class="p">(</span><span class="n">blob</span><span class="p">,</span><span class="w"> </span><span class="n">nodeoffset</span><span class="p">,</span><span class="w"> </span><span class="err">\</span><span class="s">"reg</span><span class="se">\"</span><span class="s">, tmp, len);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="err">\</span><span class="s">"WARNING: could not set %s %s.</span><span class="se">\\</span><span class="s">n</span><span class="se">\"</span><span class="s">,</span>
<span class="w">                </span><span class="err">\</span><span class="s">"reg</span><span class="se">\"</span><span class="s">, fdt_strerror(err));</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">err</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
</code></pre></div>
<p>所以，在设备树中找不到描述，可以在系统启动阶段在uboot阶段查看内存节点。</p>
<div class="codehilite"><pre><span></span><code><span class="o">=&gt;</span><span class="w"> </span><span class="n">fdt</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="o">/</span><span class="n">memory</span>
<span class="n">memory</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">reg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x00000000</span><span class="w"> </span><span class="mh">0x40000000</span><span class="w"> </span><span class="mh">0x00000000</span><span class="w"> </span><span class="mh">0x80000000</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">        </span><span class="n">device_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">\</span><span class="s">"memory</span><span class="se">\"</span><span class="s">;</span>
<span class="p">};</span>
<span class="n">物理地址起始</span><span class="err">：</span><span class="mh">0x40000000</span><span class="w"> </span>
<span class="n">物理内存大小</span><span class="err">：</span><span class="mh">0x80000000</span><span class="err">（</span><span class="mi">2</span><span class="n">GB</span><span class="err">）</span>
</code></pre></div>
<p>内核调用early_init_dt_scan_nodes扫描DTB，然后将物理内存同故宫memblock_add添加到memblock中进行管理。</p>
<div class="codehilite"><pre><span></span><code><span class="n">drivers</span><span class="o">/</span><span class="n">os</span><span class="o">/</span><span class="n">fdt</span><span class="p">.</span><span class="n">c</span>

<span class="kt">void</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="n">early_init_dt_scan_nodes</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">rc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* Initialize {size,address}-cells info */</span>
<span class="w">    </span><span class="n">of_scan_flat_dt</span><span class="p">(</span><span class="n">early_init_dt_scan_root</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* Retrieve various information from the /chosen node */</span>
<span class="w">    </span><span class="n">rc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">of_scan_flat_dt</span><span class="p">(</span><span class="n">early_init_dt_scan_chosen</span><span class="p">,</span><span class="w"> </span><span class="n">boot_command_line</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span>
<span class="w">        </span><span class="n">pr_warn</span><span class="p">(</span><span class="err">\</span><span class="s">"No chosen node found, continuing without</span><span class="se">\\</span><span class="s">n</span><span class="se">\"</span><span class="s">);</span>

<span class="w">    </span><span class="cm">/* Setup memory, calling early_init_dt_add_memory_arch */</span>
<span class="w">    </span><span class="n">of_scan_flat_dt</span><span class="p">(</span><span class="n">early_init_dt_scan_memory</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="w">      </span><span class="n">early_init_dt_add_memory_arch</span><span class="p">(</span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>
<span class="w">        </span><span class="n">memblock_add</span><span class="p">(</span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>
<span class="c1">//从设备树中读取到物理内存的地址和大小，添加到memblock中</span>

<span class="w">    </span><span class="cm">/* Handle linux,usable-memory-range property */</span>
<span class="w">    </span><span class="n">early_init_dt_check_for_usable_mem_range</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="_4">管理结构体</h3>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_a869009d572cf7995e9b217791b39879.jpg"><img alt="" src="assets/doc/01-linux/内存管理/内存初始化之物理内存初始化（一）/images/wp_editor_md_a869009d572cf7995e9b217791b39879.jpg"/></a></p>
<ul>
<li>第一层：struct memblock，定义一个全局变量，用来维护所有的物理内存；</li>
<li>第二层：struct memblock_type，系统中内存类型，包括可分配使用的内存和保留的内存；</li>
<li>第三层：struct memblock_region，描述具体内存区域，包含在struct memblock_type中的regions数组中，最多存放128个。</li>
</ul>
<div class="codehilite"><pre><span></span><code><span class="n">mm</span><span class="o">/</span><span class="n">memblock</span><span class="p">.</span><span class="n">c</span>

<span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">memblock_region</span><span class="w"> </span><span class="n">memblock_memory_init_regions</span><span class="p">[</span><span class="n">INIT_MEMBLOCK_REGIONS</span><span class="p">]</span><span class="w"> </span><span class="n">__initdata_memblock</span><span class="p">;</span>
<span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">memblock_region</span><span class="w"> </span><span class="n">memblock_reserved_init_regions</span><span class="p">[</span><span class="n">INIT_MEMBLOCK_RESERVED_REGIONS</span><span class="p">]</span><span class="w"> </span><span class="n">__initdata_memblock</span><span class="p">;</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">memblock</span><span class="w"> </span><span class="n">memblock</span><span class="w"> </span><span class="n">__initdata_memblock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">memory</span><span class="p">.</span><span class="n">regions</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">memblock_memory_init_regions</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">memory</span><span class="p">.</span><span class="n">cnt</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">    </span><span class="cm">/* empty dummy entry */</span>
<span class="w">    </span><span class="p">.</span><span class="n">memory</span><span class="p">.</span><span class="n">max</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">INIT_MEMBLOCK_REGIONS</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">memory</span><span class="p">.</span><span class="n">name</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="err">\</span><span class="s">"memory</span><span class="se">\"</span><span class="s">,</span>

<span class="w">    </span><span class="p">.</span><span class="n">reserved</span><span class="p">.</span><span class="n">regions</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">memblock_reserved_init_regions</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">reserved</span><span class="p">.</span><span class="n">cnt</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">    </span><span class="cm">/* empty dummy entry */</span>
<span class="w">    </span><span class="p">.</span><span class="n">reserved</span><span class="p">.</span><span class="n">max</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="n">INIT_MEMBLOCK_RESERVED_REGIONS</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">reserved</span><span class="p">.</span><span class="n">name</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="err">\</span><span class="s">"reserved</span><span class="se">\"</span><span class="s">,</span>

<span class="w">    </span><span class="p">.</span><span class="n">bottom_up</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">current_limit</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">MEMBLOCK_ALLOC_ANYWHERE</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div>
<p>定义了memblock全局变量，因此是不需要初始化的，在定义的时候就进行了初始化。regions指向的也是静态全局的数组，数组的大小为INIT_MEMBLOCK_REGIONS（128），在实际代码中，可以看到，当超过这个数组时，这个数组将会进行动态扩大。</p>
<h3 id="memblock_1">memblock主要接口函数</h3>
<p>Memblock系统提供一些列接口供内核模块使用，包括内存区块的添加、预留、内存申请等功能。 - memblock_add:将内存块添加到可用内存集合，添加新的内存块区域到memblock.memory中。 - memblock_reserve:将内存块添加到预留内存集合 - memblock_phys_alloc:用于申请memblock中的物理内存 - memblock_remove:删除内存块区域 - memblock_alloc:分配内存 - memblock_free:释放内存</p>
<h4 id="memblock_add">memblock_add</h4>
<p>memblock_add函数将物理内存区块添加到可用内存集合中，结构管理图如下</p>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_47d2c5ceb64eb74d8a7a5f45335b5149.jpg"><img alt="" src="assets/doc/01-linux/内存管理/内存初始化之物理内存初始化（一）/images/wp_editor_md_47d2c5ceb64eb74d8a7a5f45335b5149.jpg"/></a></p>
<h4 id="memblock_reserve">memblock_reserve</h4>
<p>与memblock_add类似</p>
<h4 id="memblock_alloc">memblock_alloc</h4>
<div class="codehilite"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">memblock_alloc</span><span class="p">(</span><span class="n">phys_addr_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">phys_addr_t</span><span class="w"> </span><span class="n">align</span><span class="p">)</span>
<span class="w"> </span><span class="n">memblock_alloc_try_nid</span>
<span class="w">  </span><span class="n">memblock_alloc_internal</span>
<span class="w">   </span><span class="n">memblock_alloc_range_nid</span>
<span class="n">memblock_find_in_range_node</span>
<span class="n">phys_to_virt</span><span class="p">(</span><span class="n">alloc</span><span class="p">)</span><span class="w"> </span>
</code></pre></div>
<p>最终调用memblock_find_in_range_node实现物理内存的分配。memblock_phys_alloc函数与该函数类似，区别是memblock_alloc在分配后会会调用phys_to_virt将物理地址转化为虚拟地址，而memblock_phys_alloc不会。</p>
<h3 id="arm64-memblock-init">Arm64 memblock init</h3>
<p>物理内存都添加到系统之后，会调用arm64_memblock_init对整个物理内存进行整理，主要的工作就是remove掉一些no-map区域（不归内核管理），同时保留一些关键区域，如内核镜像区，dtb中reserved的内存节点。 <a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_1ada4f67a7860c6a54b457c46a606fc6.jpg"><img alt="" src="assets/doc/01-linux/内存管理/内存初始化之物理内存初始化（一）/images/wp_editor_md_1ada4f67a7860c6a54b457c46a606fc6.jpg"/></a></p>
<p>上图中，浅绿色的就是reserved部分，不能被分配使用，而剩下的部分就可以通过调用上小章节中的函数去使用内存了。</p>
<p>小结： （1）系统通过memblock以数组memory type的方式记录物理内存空间，数组中每一个内存区域描述了一段内存信息，包括base，size，node id等。 （2）在memblock信息中，已经被使用或者被内核定义需要保留的区域，会存储在reserved 数组中。 （3）memory type数组中并不是代表整个内核系统的内存空间，因为股份驱动会保留一段内存区域供自己单独使用，其在dts中具有no-map熟悉的reserved-memory节点，不会由内核创建地址映射。 （4）可以通过内核调试节点/sys/kernel/debug/memblockk进行查询相关信息</p>
<h2 id="paging_init">paging_init</h2>
<p>上一章节中，物理内存通过该memblock模块添加进了系统，但是此时仍然只有DTB和image所在的两端物理内存可以访问，其他物理内存还访问不了，因为其还没有建立其页表。即使可以通过memblock_alloc分配物理内存，但是也不能访问，因为其虚拟地址对应的页表没有生成，只有是创建了页表才能通过虚拟地址转化访问物理地址。</p>
<div class="codehilite"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="nf">paging_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">pgd_t</span><span class="w"> </span><span class="o">*</span><span class="n">pgdp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pgd_set_fixmap</span><span class="p">(</span><span class="n">__pa_symbol</span><span class="p">(</span><span class="n">swapper_pg_dir</span><span class="p">));</span>
<span class="c1">//（1）获取一页内存用于构建PGD映射表，返回的是虚拟地址。</span>
<span class="n">map_kernel</span><span class="p">(</span><span class="n">pgdp</span><span class="p">);</span>
<span class="c1">//（2）完成内核的映射，包括text,data,bss段等。</span>
<span class="n">map_mem</span><span class="p">(</span><span class="n">pgdp</span><span class="p">);</span>
<span class="c1">//（3）将memblock子系统添加到物理内存进行映射</span>
<span class="w">    </span><span class="n">pgd_clear_fixmap</span><span class="p">();</span>
<span class="n">cpu_replace_ttbr1</span><span class="p">(</span><span class="n">lm_alias</span><span class="p">(</span><span class="n">swapper_pg_dir</span><span class="p">));</span>
<span class="c1">//（4）切换页表，新建立页表内容替换swapper_pg_dir</span>
<span class="w">    </span><span class="n">init_mm</span><span class="p">.</span><span class="n">pgd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">swapper_pg_dir</span><span class="p">;</span>
<span class="w">    </span><span class="n">memblock_free</span><span class="p">(</span><span class="n">__pa_symbol</span><span class="p">(</span><span class="n">init_pg_dir</span><span class="p">),</span>
<span class="w">              </span><span class="n">__pa_symbol</span><span class="p">(</span><span class="n">init_pg_end</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">__pa_symbol</span><span class="p">(</span><span class="n">init_pg_dir</span><span class="p">));</span>
<span class="w">    </span><span class="c1">//（5）新的映射更新完成，释放掉临时空间</span>
<span class="w">    </span><span class="n">memblock_allow_resize</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="pgd">构建PGD映射表</h3>
<p>页目录直接使用的是swapper_pg_dir，一个条目映射的空间本身就很大，一个entry对应范围有512GB。</p>
<div class="codehilite"><pre><span></span><code><span class="n">arch</span><span class="o">/</span><span class="n">arm64</span><span class="o">/</span><span class="n">include</span><span class="o">/</span><span class="k">asm</span><span class="o">/</span><span class="n">fixmap</span><span class="p">.</span><span class="n">h</span>
<span class="k">enum</span><span class="w"> </span><span class="n">fixed_addresses</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">......</span>
<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Used for kernel page table creation, so unmapped memory may be used</span>
<span class="cm">     * for tables.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="n">FIX_PTE</span><span class="p">,</span>
<span class="w">    </span><span class="n">FIX_PMD</span><span class="p">,</span>
<span class="w">    </span><span class="n">FIX_PUD</span><span class="p">,</span>
<span class="n">FIX_PGD</span><span class="p">,</span>
<span class="p">......</span>
<span class="p">};</span>

<span class="n">pgd_t</span><span class="w"> </span><span class="o">*</span><span class="n">pgdp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pgd_set_fixmap</span><span class="p">(</span><span class="n">__pa_symbol</span><span class="p">(</span><span class="n">swapper_pg_dir</span><span class="p">));</span>
<span class="w"> </span><span class="cp">#define pgd_set_fixmap(addr)    ((pgd_t *)set_fixmap_offset(FIX_PGD, addr))</span>

<span class="w">  </span><span class="cp">#define set_fixmap_offset(idx, phys) \\</span>
<span class="cp">__set_fixmap_offset(idx, phys, FIXMAP_PAGE_NORMAL)</span>

<span class="w">   </span><span class="cp">#define __set_fixmap_offset(idx, phys, flags)               \\</span>
<span class="cp">({                                  \\</span>
<span class="cp">     unsigned long ________addr;                 \\</span>
<span class="cp">    __set_fixmap(idx, phys, flags);                 \\</span>
<span class="cp">     ________addr = fix_to_virt(idx) + ((phys) &amp; (PAGE_SIZE - 1));   \\</span>
<span class="cp">     ________addr;                           \\</span>
<span class="cp">})</span>
</code></pre></div>
<div class="codehilite"><pre><span></span><code><span class="n">arch</span><span class="o">/</span><span class="n">arm64</span><span class="o">/</span><span class="n">kernel</span><span class="o">/</span><span class="n">vmlinux</span><span class="p">.</span><span class="n">lds</span><span class="p">.</span><span class="n">S</span>
<span class="w">    </span><span class="n">swapper_pg_dir</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">.;</span>
<span class="p">.</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">PAGE_SIZE</span><span class="p">;</span>

<span class="n">swapper_pg_dir是实现分配的一段空间</span><span class="err">，</span><span class="n">处于内核镜像的data段</span><span class="err">。</span>
</code></pre></div>
<p>通过__pa_symbol先将swapper_pg_dir转化为物理地址，然后与FIX_PGD地址范围进行映射，后续就可以通过虚拟地址FIX_PGD这段访问访问到swapper_pg_dir这块物理空间。</p>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_298d61f904629b7e9dc7780f3cb7d71c.jpg"><img alt="" src="assets/doc/01-linux/内存管理/内存初始化之物理内存初始化（一）/images/wp_editor_md_298d61f904629b7e9dc7780f3cb7d71c.jpg"/></a></p>
<h3 id="early_pgtable_alloc">early_pgtable_alloc</h3>
<p>对内核各个段、以及memblock管理的物理内存建立映射，在上一章节中已经获取到了PGD全局目录页表，但是接下来的PUD,PMD,PTE对应的页表是需要进行动态分配的，空间的分配可以使用memblock提供的函数进行分配，但是如何进行访问填充页表了？memblock分配空间内核是没法直接访问的，因为没有创建页表，没法通过查表的方式进行查找到物理地址。这个时候前面fixmap就发挥作用了，在fixmap章节中，已经创建了虚拟地址到物理地址的页表，有一段实际的虚拟地址对应的物理地址是待填充的，那就是FIX_PTE~FIX_PGD，所以就可以利用这段空间将memblock分配到的物理地址与FIX_PTE~FIX_PGD对应上，这样内核就可以通过虚拟地址进行访问了，就可以填充页表内容。</p>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_0d80fb38225d4efc6a0cf49ece64f8b4.jpg"><img alt="" src="assets/doc/01-linux/内存管理/内存初始化之物理内存初始化（一）/images/wp_editor_md_0d80fb38225d4efc6a0cf49ece64f8b4.jpg"/></a></p>
<p>内核访问物理内存使用的都是虚拟地址，而硬件模块比如MMU等访问内存使用的是物理地址，不需要从虚拟地址到物理地址转换（否则就陷入循环了）。虚拟地址转为物理地址需要查找页表找到对应的物理地址，而这个页表需要进行填充（建立映射关系），因此内核在填充页表的时候，也是使用的虚拟地址访问。只要把各级页表填充好之后就可以了，最终MMU在翻译的时候就访问的是物理地址。</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="n">phys_addr_t</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="n">early_pgtable_alloc</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">shift</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">phys_addr_t</span><span class="w"> </span><span class="n">phys</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
<span class="w">    </span><span class="n">phys</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">memblock_phys_alloc_range</span><span class="p">(</span><span class="n">PAGE_SIZE</span><span class="p">,</span><span class="w"> </span><span class="n">PAGE_SIZE</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">                     </span><span class="n">MEMBLOCK_ALLOC_NOLEAKTRACE</span><span class="p">);</span>
<span class="w">    </span><span class="c1">//（1）先分配一块物理内存</span>
<span class="w">  </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pte_set_fixmap</span><span class="p">(</span><span class="n">phys</span><span class="p">);</span>
<span class="c1">//（2）将当前的物理内存与fixmap的虚拟地址进行映射，映射完成后，内核即可访问这段内存，用的是PTE这段，PGD,PUD,PMD用在哪里？</span>
<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">PAGE_SIZE</span><span class="p">);</span>
<span class="w">    </span><span class="n">pte_clear_fixmap</span><span class="p">();</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">phys</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>从上可以看出分配一个页表需要PAGE_SIZE的大小，也就等于一个物理页帧大小4KB。页表有512个条目，每个条目占用8字节。</p>
<h3 id="-map_kernel">内核镜像细粒度映射-map_kernel</h3>
<p>Map_kernel主要完成内核中各个段的映射，包括text、rodata、init、data、bss等各个段。</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="nf">map_kernel</span><span class="p">(</span><span class="n">pgd_t</span><span class="w"> </span><span class="o">*</span><span class="n">pgdp</span><span class="p">)</span>
<span class="w">    </span><span class="n">map_kernel_segment</span><span class="p">(</span><span class="n">pgdp</span><span class="p">,</span><span class="w"> </span><span class="n">_stext</span><span class="p">,</span><span class="w"> </span><span class="n">_etext</span><span class="p">,</span><span class="w"> </span><span class="n">text_prot</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vmlinux_text</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">               </span><span class="n">VM_NO_GUARD</span><span class="p">);</span>
<span class="w">    </span><span class="n">map_kernel_segment</span><span class="p">(</span><span class="n">pgdp</span><span class="p">,</span><span class="w"> </span><span class="n">__start_rodata</span><span class="p">,</span><span class="w"> </span><span class="n">__inittext_begin</span><span class="p">,</span><span class="w"> </span><span class="n">PAGE_KERNEL</span><span class="p">,</span>
<span class="w">               </span><span class="o">&amp;</span><span class="n">vmlinux_rodata</span><span class="p">,</span><span class="w"> </span><span class="n">NO_CONT_MAPPINGS</span><span class="p">,</span><span class="w"> </span><span class="n">VM_NO_GUARD</span><span class="p">);</span>
<span class="w">    </span><span class="n">map_kernel_segment</span><span class="p">(</span><span class="n">pgdp</span><span class="p">,</span><span class="w"> </span><span class="n">__inittext_begin</span><span class="p">,</span><span class="w"> </span><span class="n">__inittext_end</span><span class="p">,</span><span class="w"> </span><span class="n">text_prot</span><span class="p">,</span>
<span class="w">               </span><span class="o">&amp;</span><span class="n">vmlinux_inittext</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">VM_NO_GUARD</span><span class="p">);</span><span class="w"> </span><span class="c1">//.init</span>
<span class="w">    </span><span class="n">map_kernel_segment</span><span class="p">(</span><span class="n">pgdp</span><span class="p">,</span><span class="w"> </span><span class="n">__initdata_begin</span><span class="p">,</span><span class="w"> </span><span class="n">__initdata_end</span><span class="p">,</span><span class="w"> </span><span class="n">PAGE_KERNEL</span><span class="p">,</span>
<span class="w">               </span><span class="o">&amp;</span><span class="n">vmlinux_initdata</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">VM_NO_GUARD</span><span class="p">);</span><span class="c1">//.data</span>
<span class="w">    </span><span class="n">map_kernel_segment</span><span class="p">(</span><span class="n">pgdp</span><span class="p">,</span><span class="w"> </span><span class="n">_data</span><span class="p">,</span><span class="w"> </span><span class="n">_end</span><span class="p">,</span><span class="w"> </span><span class="n">PAGE_KERNEL</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vmlinux_data</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="c1">//.bss</span>
</code></pre></div>
<p>启动日志</p>
<div class="codehilite"><pre><span></span><code><span class="p">[</span><span class="w">    </span><span class="mf">0.000000</span><span class="p">]</span><span class="w"> </span><span class="n">Virtual</span><span class="w"> </span><span class="n">kernel</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="n">layout</span><span class="o">:</span>
<span class="p">[</span><span class="w">    </span><span class="mf">0.000000</span><span class="p">]</span><span class="w">     </span><span class="n">modules</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mh">0xffffffc000000000</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mh">0xffffffc008000000</span><span class="w">   </span><span class="p">(</span><span class="w">   </span><span class="mi">128</span><span class="w"> </span><span class="n">MB</span><span class="p">)</span>
<span class="p">[</span><span class="w">    </span><span class="mf">0.000000</span><span class="p">]</span><span class="w">     </span><span class="n">vmalloc</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mh">0xffffffc008000000</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mh">0xfffffffdf0000000</span><span class="w">   </span><span class="p">(</span><span class="w">   </span><span class="mi">247</span><span class="w"> </span><span class="n">GB</span><span class="p">)</span>
<span class="p">[</span><span class="w">    </span><span class="mf">0.000000</span><span class="p">]</span><span class="w">       </span><span class="p">.</span><span class="n">text</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mh">0xffffffc008080000</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mh">0xffffffc008a30000</span><span class="w">   </span><span class="p">(</span><span class="w">  </span><span class="mi">9920</span><span class="w"> </span><span class="n">KB</span><span class="p">)</span>
<span class="p">[</span><span class="w">    </span><span class="mf">0.000000</span><span class="p">]</span><span class="w">     </span><span class="p">.</span><span class="n">rodata</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mh">0xffffffc008a30000</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mh">0xffffffc008d70000</span><span class="w">   </span><span class="p">(</span><span class="w">  </span><span class="mi">3328</span><span class="w"> </span><span class="n">KB</span><span class="p">)</span>
<span class="p">[</span><span class="w">    </span><span class="mf">0.000000</span><span class="p">]</span><span class="w">       </span><span class="p">.</span><span class="n">init</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mh">0xffffffc008d70000</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mh">0xffffffc008ef0000</span><span class="w">   </span><span class="p">(</span><span class="w">  </span><span class="mi">1536</span><span class="w"> </span><span class="n">KB</span><span class="p">)</span>
<span class="p">[</span><span class="w">    </span><span class="mf">0.000000</span><span class="p">]</span><span class="w">       </span><span class="p">.</span><span class="n">data</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mh">0xffffffc008ef0000</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mh">0xffffffc00900f008</span><span class="w">   </span><span class="p">(</span><span class="w">  </span><span class="mi">1149</span><span class="w"> </span><span class="n">KB</span><span class="p">)</span>
<span class="p">[</span><span class="w">    </span><span class="mf">0.000000</span><span class="p">]</span><span class="w">        </span><span class="p">.</span><span class="n">bss</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mh">0xffffffc00900f008</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mh">0xffffffc009069920</span><span class="w">   </span><span class="p">(</span><span class="w">   </span><span class="mi">363</span><span class="w"> </span><span class="n">KB</span><span class="p">)</span>
<span class="p">[</span><span class="w">    </span><span class="mf">0.000000</span><span class="p">]</span><span class="w">     </span><span class="n">fixed</span><span class="w">   </span><span class="o">:</span><span class="w"> </span><span class="mh">0xfffffffdfdbf9000</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mh">0xfffffffdfe000000</span><span class="w">   </span><span class="p">(</span><span class="w">  </span><span class="mi">4124</span><span class="w"> </span><span class="n">KB</span><span class="p">)</span>
<span class="p">[</span><span class="w">    </span><span class="mf">0.000000</span><span class="p">]</span><span class="w">     </span><span class="n">PCI</span><span class="w"> </span><span class="n">I</span><span class="o">/</span><span class="n">O</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mh">0xfffffffdfe800000</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mh">0xfffffffdff800000</span><span class="w">   </span><span class="p">(</span><span class="w">    </span><span class="mi">16</span><span class="w"> </span><span class="n">MB</span><span class="p">)</span>
<span class="p">[</span><span class="w">    </span><span class="mf">0.000000</span><span class="p">]</span><span class="w">     </span><span class="n">vmemmap</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mh">0xfffffffe00000000</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mh">0xffffffff00000000</span><span class="w">   </span><span class="p">(</span><span class="w">     </span><span class="mi">4</span><span class="w"> </span><span class="n">GB</span><span class="w"> </span><span class="n">maximum</span><span class="p">)</span>
<span class="p">[</span><span class="w">    </span><span class="mf">0.000000</span><span class="p">]</span><span class="w">               </span><span class="mh">0xfffffffe00000000</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mh">0xfffffffe02000000</span><span class="w">   </span><span class="p">(</span><span class="w">    </span><span class="mi">32</span><span class="w"> </span><span class="n">MB</span><span class="w"> </span><span class="n">actual</span><span class="p">)</span>
<span class="p">[</span><span class="w">    </span><span class="mf">0.000000</span><span class="p">]</span><span class="w">     </span><span class="n">memory</span><span class="w">  </span><span class="o">:</span><span class="w"> </span><span class="mh">0xffffff8000000000</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mh">0xffffff8080000000</span><span class="w">   </span><span class="p">(</span><span class="w">  </span><span class="mi">2048</span><span class="w"> </span><span class="n">MB</span><span class="p">)</span>
<span class="p">[</span><span class="w">    </span><span class="mf">0.000000</span><span class="p">]</span><span class="w">     </span><span class="n">PAGE_OFFSET</span><span class="w">  </span><span class="o">:</span><span class="w"> </span><span class="mh">0xffffff8000000000</span>
<span class="p">[</span><span class="w">    </span><span class="mf">0.000000</span><span class="p">]</span><span class="w">     </span><span class="n">PHYS_OFFSET</span><span class="w">  </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="n">x</span><span class="w">        </span><span class="mi">40000000</span>
<span class="p">[</span><span class="w">    </span><span class="mf">0.000000</span><span class="p">]</span><span class="w">     </span><span class="n">KIMAGE_VADDR</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mh">0xffffffc008000000</span><span class="w">  </span>
</code></pre></div>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="nf">map_kernel_segment</span><span class="p">(</span><span class="n">pgd_t</span><span class="w"> </span><span class="o">*</span><span class="n">pgdp</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">va_start</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">va_end</span><span class="p">,</span>
<span class="w">                      </span><span class="n">pgprot_t</span><span class="w"> </span><span class="n">prot</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">vm_struct</span><span class="w"> </span><span class="o">*</span><span class="n">vma</span><span class="p">,</span>
<span class="w">                      </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">vm_flags</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">phys_addr_t</span><span class="w"> </span><span class="n">pa_start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__pa_symbol</span><span class="p">(</span><span class="n">va_start</span><span class="p">);</span><span class="w"> </span><span class="c1">//将虚拟地址转为物理地址</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">va_end</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">va_start</span><span class="p">;</span>

<span class="w">    </span><span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PAGE_ALIGNED</span><span class="p">(</span><span class="n">pa_start</span><span class="p">));</span>
<span class="w">    </span><span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PAGE_ALIGNED</span><span class="p">(</span><span class="n">size</span><span class="p">));</span>

<span class="w">    </span><span class="n">__create_pgd_mapping</span><span class="p">(</span><span class="n">pgdp</span><span class="p">,</span><span class="w"> </span><span class="n">pa_start</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">)</span><span class="n">va_start</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">prot</span><span class="p">,</span>
<span class="w">                 </span><span class="n">early_pgtable_alloc</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vm_flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">VM_NO_GUARD</span><span class="p">))</span>
<span class="w">        </span><span class="n">size</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">PAGE_SIZE</span><span class="p">;</span>

<span class="w">    </span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">addr</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">va_start</span><span class="p">;</span>
<span class="w">    </span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">phys_addr</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">pa_start</span><span class="p">;</span>
<span class="w">    </span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">size</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">size</span><span class="p">;</span>
<span class="w">    </span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">flags</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">VM_MAP</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">vm_flags</span><span class="p">;</span>
<span class="w">    </span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">caller</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__builtin_return_address</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="w">    </span><span class="n">vm_area_add_early</span><span class="p">(</span><span class="n">vma</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_b18c2463b591ae314ded0293f324b1aa.jpg"><img alt="" src="assets/doc/01-linux/内存管理/内存初始化之物理内存初始化（一）/images/wp_editor_md_b18c2463b591ae314ded0293f324b1aa.jpg"/></a></p>
<h3 id="-map_mem">线性映射-map_mem</h3>
<p>完成对物理内存的映射，这部分的物理内存是同故宫memblock_add添加系统中的，函数中将会遍历memblock中的各个块，然后调用__map_memblock来完成实际的映射操作。</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="nf">map_mem</span><span class="p">(</span><span class="n">pgd_t</span><span class="w"> </span><span class="o">*</span><span class="n">pgdp</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="p">......</span>
<span class="n">memblock_mark_nomap</span><span class="p">(</span><span class="n">kernel_start</span><span class="p">,</span><span class="w"> </span><span class="n">kernel_end</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">kernel_start</span><span class="p">);</span>
<span class="c1">//（1）不对设置了MEMBLOCK_NOMAP的标志映射</span>

<span class="w">  </span><span class="cm">/* map all the memory banks */</span>
<span class="w">    </span><span class="n">for_each_mem_range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">end</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">start</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">end</span><span class="p">)</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="cm">/*</span>
<span class="cm">         * The linear map must allow allocation tags reading/writing</span>
<span class="cm">         * if MTE is present. Otherwise, it has the same attributes as</span>
<span class="cm">         * PAGE_KERNEL.</span>
<span class="cm">         */</span>
<span class="w">        </span><span class="n">__map_memblock</span><span class="p">(</span><span class="n">pgdp</span><span class="p">,</span><span class="w"> </span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="p">,</span><span class="w"> </span><span class="n">pgprot_tagged</span><span class="p">(</span><span class="n">PAGE_KERNEL</span><span class="p">),</span>
<span class="w">                   </span><span class="n">flags</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="c1">//（2）遍历memblock中的各个块并完成内存的映射</span>
<span class="p">}</span>
</code></pre></div>
<p>遍历memblock.memory进行逐一映射。</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="nf">map_mem</span><span class="p">(</span><span class="n">pgd_t</span><span class="w"> </span><span class="o">*</span><span class="n">pgdp</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="p">......</span>
<span class="n">memblock_mark_nomap</span><span class="p">(</span><span class="n">kernel_start</span><span class="p">,</span><span class="w"> </span><span class="n">kernel_end</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">kernel_start</span><span class="p">);</span>
<span class="c1">//（1）不对设置了MEMBLOCK_NOMAP的标志映射</span>

<span class="w">  </span><span class="cm">/* map all the memory banks */</span>
<span class="w">    </span><span class="n">for_each_mem_range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">end</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">start</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">end</span><span class="p">)</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="cm">/*</span>
<span class="cm">         * The linear map must allow allocation tags reading/writing</span>
<span class="cm">         * if MTE is present. Otherwise, it has the same attributes as</span>
<span class="cm">         * PAGE_KERNEL.</span>
<span class="cm">         */</span>
<span class="w">        </span><span class="n">__map_memblock</span><span class="p">(</span><span class="n">pgdp</span><span class="p">,</span><span class="w"> </span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="p">,</span><span class="w"> </span><span class="n">pgprot_tagged</span><span class="p">(</span><span class="n">PAGE_KERNEL</span><span class="p">),</span>
<span class="w">                   </span><span class="n">flags</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="c1">//（2）遍历memblock中的各个块并完成内存的映射</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="nf">__map_memblock</span><span class="p">(</span><span class="n">pgd_t</span><span class="w"> </span><span class="o">*</span><span class="n">pgdp</span><span class="p">,</span><span class="w"> </span><span class="n">phys_addr_t</span><span class="w"> </span><span class="n">start</span><span class="p">,</span>
<span class="w">                  </span><span class="n">phys_addr_t</span><span class="w"> </span><span class="n">end</span><span class="p">,</span><span class="w"> </span><span class="n">pgprot_t</span><span class="w"> </span><span class="n">prot</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">__create_pgd_mapping</span><span class="p">(</span><span class="n">pgdp</span><span class="p">,</span><span class="w"> </span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">__phys_to_virt</span><span class="p">(</span><span class="n">start</span><span class="p">),</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start</span><span class="p">,</span>
<span class="w">                 </span><span class="n">prot</span><span class="p">,</span><span class="w"> </span><span class="n">early_pgtable_alloc</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">Start是要映射的物理地址</span><span class="err">，</span><span class="n">__phys_to_virt</span><span class="p">(</span><span class="n">start</span><span class="p">)</span><span class="n">是要映射的虚拟地址</span><span class="err">，</span><span class="n">由此可见</span><span class="err">，</span><span class="n">这段空间是进行的线性映射</span><span class="err">。</span>
</code></pre></div>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_d72d6060b232c98f975ac6a73a875895.jpg"><img alt="" src="assets/doc/01-linux/内存管理/内存初始化之物理内存初始化（一）/images/wp_editor_md_d72d6060b232c98f975ac6a73a875895.jpg"/></a></p>
<h3 id="__create_pgd_mapping">__create_pgd_mapping</h3>
<p>map_kernel与map_mem最终都会调用__create_pgd_mapping进行映射。</p>
<p><a href="http://8.134.108.235/wp-content/uploads/2023/11/wp_editor_md_3322c2565dfff87c8655ca5612a64302.jpg"><img alt="" src="images/wp_editor_md_3322c2565dfff87c8655ca5612a64302.jpg"/></a></p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">__create_pgd_mapping</span><span class="p">(</span><span class="n">pgd_t</span><span class="w"> </span><span class="o">*</span><span class="n">pgdir</span><span class="p">,</span><span class="w"> </span><span class="n">phys_addr_t</span><span class="w"> </span><span class="n">phys</span><span class="p">,</span>
<span class="w">                 </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">virt</span><span class="p">,</span><span class="w"> </span><span class="n">phys_addr_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span>
<span class="w">                 </span><span class="n">pgprot_t</span><span class="w"> </span><span class="n">prot</span><span class="p">,</span>
<span class="w">                 </span><span class="n">phys_addr_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">pgtable_alloc</span><span class="p">)(</span><span class="kt">int</span><span class="p">),</span>
<span class="w">                 </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="p">,</span><span class="w"> </span><span class="n">next</span><span class="p">;</span>
<span class="n">pgd_t</span><span class="w"> </span><span class="o">*</span><span class="n">pgdp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pgd_offset_pgd</span><span class="p">(</span><span class="n">pgdir</span><span class="p">,</span><span class="w"> </span><span class="n">virt</span><span class="p">);</span><span class="w"> </span>
<span class="c1">//获取要映射地址virt在PGD页表目录的表项对应的地址（虚拟地址），接下来将会进行填充内容（下一级页表的物理地址）。</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * If the virtual and physical address don\'t have the same offset</span>
<span class="cm">     * within a page, we cannot map the region as the caller expects.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">WARN_ON</span><span class="p">((</span><span class="n">phys</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">virt</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">))</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="c1">//让物理内存由原理的按字节计算位置改为按页计算位置</span>
<span class="w">    </span><span class="n">phys</span><span class="w"> </span><span class="o">&amp;=</span><span class="w"> </span><span class="n">PAGE_MASK</span><span class="p">;</span>
<span class="w">    </span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">virt</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">PAGE_MASK</span><span class="p">;</span>
<span class="w">    </span><span class="n">end</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">virt</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">size</span><span class="p">);</span><span class="c1">//按PAGE对齐的方式算，结束地址多少。</span>

<span class="w">    </span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pgd_addr_end</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="p">);</span>
<span class="c1">//找到当前PGD的结束地址，一般来说PGD entry只有一个，所以这里的循环只会有依次。原因是一个PGD有512个条目，每个条目表示512GB（2^39）的虚拟地址空间。</span>

<span class="w">        </span><span class="n">alloc_init_pud</span><span class="p">(</span><span class="n">pgdp</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">next</span><span class="p">,</span><span class="w"> </span><span class="n">phys</span><span class="p">,</span><span class="w"> </span><span class="n">prot</span><span class="p">,</span><span class="w"> </span><span class="n">pgtable_alloc</span><span class="p">,</span>
<span class="w">                   </span><span class="n">flags</span><span class="p">);</span><span class="w"> </span><span class="c1">//初始化该PGD条目对应的PUD</span>
<span class="w">        </span><span class="n">phys</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">next</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">addr</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">pgdp</span><span class="o">++</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">next</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">end</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="alloc_init_pud">alloc_init_pud</h4>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">alloc_init_pud</span><span class="p">(</span><span class="n">pgd_t</span><span class="w"> </span><span class="o">*</span><span class="n">pgdp</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">end</span><span class="p">,</span>
<span class="w">               </span><span class="n">phys_addr_t</span><span class="w"> </span><span class="n">phys</span><span class="p">,</span><span class="w"> </span><span class="n">pgprot_t</span><span class="w"> </span><span class="n">prot</span><span class="p">,</span>
<span class="w">               </span><span class="n">phys_addr_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">pgtable_alloc</span><span class="p">)(</span><span class="kt">int</span><span class="p">),</span>
<span class="w">               </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">next</span><span class="p">;</span>
<span class="w">    </span><span class="n">pud_t</span><span class="w"> </span><span class="o">*</span><span class="n">pudp</span><span class="p">;</span>
<span class="n">p4d_t</span><span class="w"> </span><span class="o">*</span><span class="n">p4dp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p4d_offset</span><span class="p">(</span><span class="n">pgdp</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">);</span><span class="w"> </span>
<span class="c1">//获取第四级页表中页表项的地址，MR527是三级页表，所以p4dp=pgdp。</span>
<span class="w">    </span><span class="n">p4d_t</span><span class="w"> </span><span class="n">p4d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">READ_ONCE</span><span class="p">(</span><span class="o">*</span><span class="n">p4dp</span><span class="p">);</span><span class="w"> </span><span class="c1">//读取表项中的内容，实际读的就是PGD目录（3级）</span>
<span class="w">    </span><span class="c1">//判断表项内容是否为空，如果为空需要进行PUD，这里表项不为空，因为是3级页表，所以不需要创建PUD</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p4d_none</span><span class="p">(</span><span class="n">p4d</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">p4dval_t</span><span class="w"> </span><span class="n">p4dval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">P4D_TYPE_TABLE</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">P4D_TABLE_UXN</span><span class="p">;</span>
<span class="w">        </span><span class="n">phys_addr_t</span><span class="w"> </span><span class="n">pud_phys</span><span class="p">;</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">NO_EXEC_MAPPINGS</span><span class="p">)</span>
<span class="w">            </span><span class="n">p4dval</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">P4D_TABLE_PXN</span><span class="p">;</span>
<span class="w">        </span><span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">pgtable_alloc</span><span class="p">);</span>
<span class="w">        </span><span class="n">pud_phys</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pgtable_alloc</span><span class="p">(</span><span class="n">PUD_SHIFT</span><span class="p">);</span>
<span class="w">        </span><span class="n">__p4d_populate</span><span class="p">(</span><span class="n">p4dp</span><span class="p">,</span><span class="w"> </span><span class="n">pud_phys</span><span class="p">,</span><span class="w"> </span><span class="n">p4dval</span><span class="p">);</span>
<span class="w">        </span><span class="n">p4d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">READ_ONCE</span><span class="p">(</span><span class="o">*</span><span class="n">p4dp</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">BUG_ON</span><span class="p">(</span><span class="n">p4d_bad</span><span class="p">(</span><span class="n">p4d</span><span class="p">));</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * No need for locking during early boot. And it doesn\'t work as</span>
<span class="cm">     * expected with KASLR enabled.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">system_state</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">SYSTEM_BOOTING</span><span class="p">)</span>
<span class="w">        </span><span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fixmap_lock</span><span class="p">);</span>
<span class="n">pudp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pud_set_fixmap_offset</span><span class="p">(</span><span class="n">p4dp</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">);</span>
<span class="c1">//计算所在PUD（PGD）偏移表项的地址（虚拟地址），其地址（虚拟）空间在fixmap范围内FIX_PUD（FIX_PGD）范围内，因为要访问其物理空间，需要查询页表，所以使用之前创建好的页表，填充映射好后，可以直接访问。</span>
<span class="w">    </span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">pud_t</span><span class="w"> </span><span class="n">old_pud</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">READ_ONCE</span><span class="p">(</span><span class="o">*</span><span class="n">pudp</span><span class="p">);</span>

<span class="w">        </span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pud_addr_end</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="p">);</span>
<span class="c1">//PUD起始和结束位置，大小是1GB。空间比较大，只循环一次。</span>
<span class="w">        </span><span class="cm">/*</span>
<span class="cm">         * For 4K granule only, attempt to put down a 1GB block</span>
<span class="cm">         */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">use_1G_block</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">next</span><span class="p">,</span><span class="w"> </span><span class="n">phys</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">            </span><span class="p">(</span><span class="n">flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">NO_BLOCK_MAPPINGS</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">pud_set_huge</span><span class="p">(</span><span class="n">pudp</span><span class="p">,</span><span class="w"> </span><span class="n">phys</span><span class="p">,</span><span class="w"> </span><span class="n">prot</span><span class="p">);</span>

<span class="w">            </span><span class="cm">/*</span>
<span class="cm">             * After the PUD entry has been populated once, we</span>
<span class="cm">             * only allow updates to the permission attributes.</span>
<span class="cm">             */</span>
<span class="w">            </span><span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">pgattr_change_is_safe</span><span class="p">(</span><span class="n">pud_val</span><span class="p">(</span><span class="n">old_pud</span><span class="p">),</span>
<span class="w">                              </span><span class="n">READ_ONCE</span><span class="p">(</span><span class="n">pud_val</span><span class="p">(</span><span class="o">*</span><span class="n">pudp</span><span class="p">))));</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">alloc_init_cont_pmd</span><span class="p">(</span><span class="n">pudp</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">next</span><span class="p">,</span><span class="w"> </span><span class="n">phys</span><span class="p">,</span><span class="w"> </span><span class="n">prot</span><span class="p">,</span>
<span class="w">                        </span><span class="n">pgtable_alloc</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span><span class="c1">//循环在各个PUD映射表现建立对应PMD页表</span>

<span class="w">            </span><span class="n">BUG_ON</span><span class="p">(</span><span class="n">pud_val</span><span class="p">(</span><span class="n">old_pud</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">                   </span><span class="n">pud_val</span><span class="p">(</span><span class="n">old_pud</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">READ_ONCE</span><span class="p">(</span><span class="n">pud_val</span><span class="p">(</span><span class="o">*</span><span class="n">pudp</span><span class="p">)));</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">phys</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">next</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">addr</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">pudp</span><span class="o">++</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">next</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">end</span><span class="p">);</span>

<span class="w">    </span><span class="n">pud_clear_fixmap</span><span class="p">();</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">system_state</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">SYSTEM_BOOTING</span><span class="p">)</span>
<span class="w">        </span><span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fixmap_lock</span><span class="p">);</span>
<span class="p">}</span><span class="w">   </span>
</code></pre></div>
<h4 id="alloc_init_cont_pmd">alloc_init_cont_pmd</h4>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">alloc_init_cont_pmd</span><span class="p">(</span><span class="n">pud_t</span><span class="w"> </span><span class="o">*</span><span class="n">pudp</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span>
<span class="w">                </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">end</span><span class="p">,</span><span class="w"> </span><span class="n">phys_addr_t</span><span class="w"> </span><span class="n">phys</span><span class="p">,</span>
<span class="w">                </span><span class="n">pgprot_t</span><span class="w"> </span><span class="n">prot</span><span class="p">,</span>
<span class="w">                </span><span class="n">phys_addr_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">pgtable_alloc</span><span class="p">)(</span><span class="kt">int</span><span class="p">),</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">next</span><span class="p">;</span>
<span class="w">    </span><span class="n">pud_t</span><span class="w"> </span><span class="n">pud</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">READ_ONCE</span><span class="p">(</span><span class="o">*</span><span class="n">pudp</span><span class="p">);</span><span class="c1">//获取PUD页表中addr对应的表项内容，也就是PMD页表地址</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Check for initial section mappings in the pgd/pud.</span>
<span class="cm">     */</span>
<span class="n">BUG_ON</span><span class="p">(</span><span class="n">pud_sect</span><span class="p">(</span><span class="n">pud</span><span class="p">));</span>
<span class="c1">//如果PUD页表为空，则分配一个页表，页表中的表项为创建512个。页表大小一个为4K，每个表项占8字节。</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pud_none</span><span class="p">(</span><span class="n">pud</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">pudval_t</span><span class="w"> </span><span class="n">pudval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PUD_TYPE_TABLE</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">PUD_TABLE_UXN</span><span class="p">;</span>
<span class="w">        </span><span class="n">phys_addr_t</span><span class="w"> </span><span class="n">pmd_phys</span><span class="p">;</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">NO_EXEC_MAPPINGS</span><span class="p">)</span>
<span class="w">            </span><span class="n">pudval</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">PUD_TABLE_PXN</span><span class="p">;</span>
<span class="w">        </span><span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">pgtable_alloc</span><span class="p">);</span>
<span class="w">        </span><span class="n">pmd_phys</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pgtable_alloc</span><span class="p">(</span><span class="n">PMD_SHIFT</span><span class="p">);</span>
<span class="w">        </span><span class="n">__pud_populate</span><span class="p">(</span><span class="n">pudp</span><span class="p">,</span><span class="w"> </span><span class="n">pmd_phys</span><span class="p">,</span><span class="w"> </span><span class="n">pudval</span><span class="p">);</span><span class="c1">//将PMD页表的物理地址填充到映射地址对应的PUD（实际上是PGD，3级页表）表项中</span>
<span class="w">        </span><span class="n">pud</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">READ_ONCE</span><span class="p">(</span><span class="o">*</span><span class="n">pudp</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">BUG_ON</span><span class="p">(</span><span class="n">pud_bad</span><span class="p">(</span><span class="n">pud</span><span class="p">));</span>

<span class="w">    </span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">pgprot_t</span><span class="w"> </span><span class="n">__prot</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prot</span><span class="p">;</span>

<span class="w">        </span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pmd_cont_addr_end</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="p">);</span>
<span class="c1">//一个PMD entry映射范围是2M，所以计算需要多少个entry。但是如果是连续的物理内存，init_pmd不是只初始化一个entry，而是一下初始化多个entry，多少个entry由CONT_PMDS。所以这里的地址范围next的距离将是CONT_PMDS*PMD_SIZE。</span>

<span class="w">        </span><span class="cm">/* use a contiguous mapping if the range is suitably aligned */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">((((</span><span class="n">addr</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">next</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">phys</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="n">CONT_PMD_MASK</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">            </span><span class="p">(</span><span class="n">flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">NO_CONT_MAPPINGS</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">            </span><span class="n">__prot</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__pgprot</span><span class="p">(</span><span class="n">pgprot_val</span><span class="p">(</span><span class="n">prot</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">PTE_CONT</span><span class="p">);</span>

<span class="w">        </span><span class="n">init_pmd</span><span class="p">(</span><span class="n">pudp</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">next</span><span class="p">,</span><span class="w"> </span><span class="n">phys</span><span class="p">,</span><span class="w"> </span><span class="n">__prot</span><span class="p">,</span><span class="w"> </span><span class="n">pgtable_alloc</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span>
<span class="w">        </span><span class="c1">//初始化PMD页表，创建下一级页表，同时将其物理地址填充到表项中。</span>
<span class="w">        </span><span class="n">phys</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">next</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">addr</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">next</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">end</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="init_pmd">init_pmd</h4>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">init_pmd</span><span class="p">(</span><span class="n">pud_t</span><span class="w"> </span><span class="o">*</span><span class="n">pudp</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">end</span><span class="p">,</span>
<span class="w">             </span><span class="n">phys_addr_t</span><span class="w"> </span><span class="n">phys</span><span class="p">,</span><span class="w"> </span><span class="n">pgprot_t</span><span class="w"> </span><span class="n">prot</span><span class="p">,</span>
<span class="w">             </span><span class="n">phys_addr_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">pgtable_alloc</span><span class="p">)(</span><span class="kt">int</span><span class="p">),</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">next</span><span class="p">;</span>
<span class="w">    </span><span class="n">pmd_t</span><span class="w"> </span><span class="o">*</span><span class="n">pmdp</span><span class="p">;</span>

<span class="n">pmdp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pmd_set_fixmap_offset</span><span class="p">(</span><span class="n">pudp</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">);</span>
<span class="c1">//获取映射地址addr对应PMD页表项的地址（虚拟地址），其地址范围在FIX_PMD中，因为访问物理内存也需要查询页表，那就将其物理地址映射到FIXMAP范围，就可以进行直接访问虚拟地址了。</span>
<span class="w">    </span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">pmd_t</span><span class="w"> </span><span class="n">old_pmd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">READ_ONCE</span><span class="p">(</span><span class="o">*</span><span class="n">pmdp</span><span class="p">);</span><span class="c1">//遍历PMD表项，</span>

<span class="w">        </span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pmd_addr_end</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="p">);</span>
<span class="w">       </span><span class="c1">//每个PMD的映射范围是2M，遍历需要多少个PTE。</span>
<span class="w">        </span><span class="cm">/* try section mapping first */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(((</span><span class="n">addr</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">next</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">phys</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="n">PMD_MASK</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">            </span><span class="p">(</span><span class="n">flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">NO_BLOCK_MAPPINGS</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">pmd_set_huge</span><span class="p">(</span><span class="n">pmdp</span><span class="p">,</span><span class="w"> </span><span class="n">phys</span><span class="p">,</span><span class="w"> </span><span class="n">prot</span><span class="p">);</span>

<span class="w">            </span><span class="cm">/*</span>
<span class="cm">             * After the PMD entry has been populated once, we</span>
<span class="cm">             * only allow updates to the permission attributes.</span>
<span class="cm">             */</span>
<span class="w">            </span><span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">pgattr_change_is_safe</span><span class="p">(</span><span class="n">pmd_val</span><span class="p">(</span><span class="n">old_pmd</span><span class="p">),</span>
<span class="w">                              </span><span class="n">READ_ONCE</span><span class="p">(</span><span class="n">pmd_val</span><span class="p">(</span><span class="o">*</span><span class="n">pmdp</span><span class="p">))));</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">alloc_init_cont_pte</span><span class="p">(</span><span class="n">pmdp</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">next</span><span class="p">,</span><span class="w"> </span><span class="n">phys</span><span class="p">,</span><span class="w"> </span><span class="n">prot</span><span class="p">,</span>
<span class="w">                        </span><span class="n">pgtable_alloc</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span>

<span class="w">            </span><span class="n">BUG_ON</span><span class="p">(</span><span class="n">pmd_val</span><span class="p">(</span><span class="n">old_pmd</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">                   </span><span class="n">pmd_val</span><span class="p">(</span><span class="n">old_pmd</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">READ_ONCE</span><span class="p">(</span><span class="n">pmd_val</span><span class="p">(</span><span class="o">*</span><span class="n">pmdp</span><span class="p">)));</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">phys</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">next</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">addr</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">pmdp</span><span class="o">++</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">next</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">end</span><span class="p">);</span>

<span class="w">    </span><span class="n">pmd_clear_fixmap</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">alloc_init_cont_pte</span><span class="p">(</span><span class="n">pmd_t</span><span class="w"> </span><span class="o">*</span><span class="n">pmdp</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span>
<span class="w">                </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">end</span><span class="p">,</span><span class="w"> </span><span class="n">phys_addr_t</span><span class="w"> </span><span class="n">phys</span><span class="p">,</span>
<span class="w">                </span><span class="n">pgprot_t</span><span class="w"> </span><span class="n">prot</span><span class="p">,</span>
<span class="w">                </span><span class="n">phys_addr_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">pgtable_alloc</span><span class="p">)(</span><span class="kt">int</span><span class="p">),</span>
<span class="w">                </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">next</span><span class="p">;</span>
<span class="w">    </span><span class="n">pmd_t</span><span class="w"> </span><span class="n">pmd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">READ_ONCE</span><span class="p">(</span><span class="o">*</span><span class="n">pmdp</span><span class="p">);</span><span class="c1">//获得PTE映射表的头地址</span>

<span class="w">    </span><span class="n">BUG_ON</span><span class="p">(</span><span class="n">pmd_sect</span><span class="p">(</span><span class="n">pmd</span><span class="p">));</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pmd_none</span><span class="p">(</span><span class="n">pmd</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="c1">//如果没有该表则创建一个</span>
<span class="w">        </span><span class="n">pmdval_t</span><span class="w"> </span><span class="n">pmdval</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PMD_TYPE_TABLE</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">PMD_TABLE_UXN</span><span class="p">;</span>
<span class="w">        </span><span class="n">phys_addr_t</span><span class="w"> </span><span class="n">pte_phys</span><span class="p">;</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">NO_EXEC_MAPPINGS</span><span class="p">)</span>
<span class="w">            </span><span class="n">pmdval</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">PMD_TABLE_PXN</span><span class="p">;</span>
<span class="w">        </span><span class="n">pte_phys</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pgtable_alloc</span><span class="p">(</span><span class="n">PAGE_SHIFT</span><span class="p">);</span>
<span class="w">        </span><span class="n">__pmd_populate</span><span class="p">(</span><span class="n">pmdp</span><span class="p">,</span><span class="w"> </span><span class="n">pte_phys</span><span class="p">,</span><span class="w"> </span><span class="n">pmdval</span><span class="p">);</span>
<span class="w">        </span><span class="n">pmd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">READ_ONCE</span><span class="p">(</span><span class="o">*</span><span class="n">pmdp</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">pgprot_t</span><span class="w"> </span><span class="n">__prot</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prot</span><span class="p">;</span>

<span class="w">        </span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pte_cont_addr_end</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="p">);</span>
<span class="c1">//一个PTE entry映射范围是4K，所以计算需要多少个entry。但是如果是连续的物理内存，init_pmd不是只初始化一个entry，而是一下初始化多个entry，多少个entry由CONT_PTES。所以这里的地址范围next的距离将是CONT_PTES*PTE_SIZE。</span>

<span class="w">        </span><span class="cm">/* use a contiguous mapping if the range is suitably aligned */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">((((</span><span class="n">addr</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">next</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">phys</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="n">CONT_PTE_MASK</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">            </span><span class="p">(</span><span class="n">flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">NO_CONT_MAPPINGS</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">            </span><span class="n">__prot</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__pgprot</span><span class="p">(</span><span class="n">pgprot_val</span><span class="p">(</span><span class="n">prot</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">PTE_CONT</span><span class="p">);</span>

<span class="w">        </span><span class="n">init_pte</span><span class="p">(</span><span class="n">pmdp</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">next</span><span class="p">,</span><span class="w"> </span><span class="n">phys</span><span class="p">,</span><span class="w"> </span><span class="n">__prot</span><span class="p">);</span><span class="c1">//初始化每一个PTE的表项记录，对应物理页帧</span>

<span class="w">        </span><span class="n">phys</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">next</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">addr</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">next</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">end</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="init_pte">init_pte</h4>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">init_pte</span><span class="p">(</span><span class="n">pmd_t</span><span class="w"> </span><span class="o">*</span><span class="n">pmdp</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">end</span><span class="p">,</span>
<span class="w">             </span><span class="n">phys_addr_t</span><span class="w"> </span><span class="n">phys</span><span class="p">,</span><span class="w"> </span><span class="n">pgprot_t</span><span class="w"> </span><span class="n">prot</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">pte_t</span><span class="w"> </span><span class="o">*</span><span class="n">ptep</span><span class="p">;</span>

<span class="w">    </span><span class="n">ptep</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pte_set_fixmap_offset</span><span class="p">(</span><span class="n">pmdp</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">);</span><span class="c1">//根据addr找到对应的PTE Entry位置</span>
<span class="w">    </span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">pte_t</span><span class="w"> </span><span class="n">old_pte</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">READ_ONCE</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">);</span>
<span class="c1">//读这个entry的值，一般来说新建的entry是没有valid的值的</span>

<span class="w">        </span><span class="n">set_pte</span><span class="p">(</span><span class="n">ptep</span><span class="p">,</span><span class="w"> </span><span class="n">pfn_pte</span><span class="p">(</span><span class="n">__phys_to_pfn</span><span class="p">(</span><span class="n">phys</span><span class="p">),</span><span class="w"> </span><span class="n">prot</span><span class="p">));</span>
<span class="w">        </span><span class="c1">//将物理地址转换为页帧，然后写入PTE</span>
<span class="w">        </span><span class="cm">/*</span>
<span class="cm">         * After the PTE entry has been populated once, we</span>
<span class="cm">         * only allow updates to the permission attributes.</span>
<span class="cm">         */</span>
<span class="w">        </span><span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">pgattr_change_is_safe</span><span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="n">old_pte</span><span class="p">),</span>
<span class="w">                          </span><span class="n">READ_ONCE</span><span class="p">(</span><span class="n">pte_val</span><span class="p">(</span><span class="o">*</span><span class="n">ptep</span><span class="p">))));</span>

<span class="w">        </span><span class="n">phys</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">PAGE_SIZE</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">ptep</span><span class="o">++</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">PAGE_SIZE</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">end</span><span class="p">);</span>

<span class="w">    </span><span class="n">pte_clear_fixmap</span><span class="p">();</span>
<span class="p">}</span><span class="w"> </span>
</code></pre></div>
<h4 id="debug">内核debug日志</h4>
<div class="codehilite"><pre><span></span><code><span class="n">内核debug日志</span>

<span class="nl">map_kernel_segment</span><span class="p">:</span><span class="n">pgdp</span><span class="o">:</span><span class="n">fffffffdfda36000</span><span class="p">,[</span><span class="n">va_start</span><span class="o">:</span><span class="n">ffffffc008a30000</span><span class="p">,</span><span class="n">va_end</span><span class="o">:</span><span class="n">ffffffc008d70000</span><span class="p">]</span><span class="w"> </span><span class="n">paging_init</span><span class="o">+</span><span class="mh">0x14c</span><span class="o">/</span><span class="mh">0x524</span>
<span class="nl">__create_pgd_mapping</span><span class="p">:</span><span class="n">pgdp</span><span class="o">:</span><span class="mh">0xfffffffdfda36800</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="n">pgd_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">alloc_init_pud</span><span class="p">,</span><span class="mi">333</span><span class="o">:</span><span class="w"> </span><span class="n">pgdp</span><span class="o">:</span><span class="mh">0xfffffffdfda36800</span><span class="p">,</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">alloc_init_cont_pmd</span><span class="p">,</span><span class="mi">274</span><span class="o">:</span><span class="w"> </span><span class="n">pudp</span><span class="o">:</span><span class="mh">0xfffffffdfda36800</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="n">pud_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">init_pmd</span><span class="p">,</span><span class="mi">235</span><span class="o">:</span><span class="w"> </span><span class="n">pmdp</span><span class="o">:</span><span class="mh">0xfffffffdfda38228</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="n">pmd_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="o">:</span><span class="mh">0xffffffc008a30000</span><span class="p">,</span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008d70000</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">alloc_init_cont_pte</span><span class="p">,</span><span class="mi">193</span><span class="o">:</span><span class="w"> </span><span class="n">pmdp</span><span class="o">:</span><span class="mh">0xfffffffdfda38228</span><span class="p">,</span><span class="n">addr</span><span class="o">:</span><span class="mh">0xffffffc008a30000</span><span class="p">,</span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008c00000</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">init_pte</span><span class="p">,</span><span class="mi">179</span><span class="o">:</span><span class="w"> </span><span class="n">ptep</span><span class="o">:</span><span class="mh">0xfffffffdfda39200</span><span class="p">,</span><span class="n">size</span><span class="w"> </span><span class="n">pte_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008a40000</span><span class="p">,</span><span class="n">number</span><span class="o">:</span><span class="mi">16</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">init_pte</span><span class="p">,</span><span class="mi">179</span><span class="o">:</span><span class="w"> </span><span class="n">ptep</span><span class="o">:</span><span class="mh">0xfffffffdfda39280</span><span class="p">,</span><span class="n">size</span><span class="w"> </span><span class="n">pte_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008a50000</span><span class="p">,</span><span class="n">number</span><span class="o">:</span><span class="mi">16</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">init_pte</span><span class="p">,</span><span class="mi">179</span><span class="o">:</span><span class="w"> </span><span class="n">ptep</span><span class="o">:</span><span class="mh">0xfffffffdfda39300</span><span class="p">,</span><span class="n">size</span><span class="w"> </span><span class="n">pte_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008a60000</span><span class="p">,</span><span class="n">number</span><span class="o">:</span><span class="mi">16</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">init_pte</span><span class="p">,</span><span class="mi">179</span><span class="o">:</span><span class="w"> </span><span class="n">ptep</span><span class="o">:</span><span class="mh">0xfffffffdfda39380</span><span class="p">,</span><span class="n">size</span><span class="w"> </span><span class="n">pte_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008a70000</span><span class="p">,</span><span class="n">number</span><span class="o">:</span><span class="mi">16</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">init_pte</span><span class="p">,</span><span class="mi">179</span><span class="o">:</span><span class="w"> </span><span class="n">ptep</span><span class="o">:</span><span class="mh">0xfffffffdfda39400</span><span class="p">,</span><span class="n">size</span><span class="w"> </span><span class="n">pte_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008a80000</span><span class="p">,</span><span class="n">number</span><span class="o">:</span><span class="mi">16</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">init_pte</span><span class="p">,</span><span class="mi">179</span><span class="o">:</span><span class="w"> </span><span class="n">ptep</span><span class="o">:</span><span class="mh">0xfffffffdfda39480</span><span class="p">,</span><span class="n">size</span><span class="w"> </span><span class="n">pte_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008a90000</span><span class="p">,</span><span class="n">number</span><span class="o">:</span><span class="mi">16</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">init_pte</span><span class="p">,</span><span class="mi">179</span><span class="o">:</span><span class="w"> </span><span class="n">ptep</span><span class="o">:</span><span class="mh">0xfffffffdfda39500</span><span class="p">,</span><span class="n">size</span><span class="w"> </span><span class="n">pte_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008aa0000</span><span class="p">,</span><span class="n">number</span><span class="o">:</span><span class="mi">16</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">init_pte</span><span class="p">,</span><span class="mi">179</span><span class="o">:</span><span class="w"> </span><span class="n">ptep</span><span class="o">:</span><span class="mh">0xfffffffdfda39580</span><span class="p">,</span><span class="n">size</span><span class="w"> </span><span class="n">pte_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008ab0000</span><span class="p">,</span><span class="n">number</span><span class="o">:</span><span class="mi">16</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">init_pte</span><span class="p">,</span><span class="mi">179</span><span class="o">:</span><span class="w"> </span><span class="n">ptep</span><span class="o">:</span><span class="mh">0xfffffffdfda39600</span><span class="p">,</span><span class="n">size</span><span class="w"> </span><span class="n">pte_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008ac0000</span><span class="p">,</span><span class="n">number</span><span class="o">:</span><span class="mi">16</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">init_pte</span><span class="p">,</span><span class="mi">179</span><span class="o">:</span><span class="w"> </span><span class="n">ptep</span><span class="o">:</span><span class="mh">0xfffffffdfda39680</span><span class="p">,</span><span class="n">size</span><span class="w"> </span><span class="n">pte_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008ad0000</span><span class="p">,</span><span class="n">number</span><span class="o">:</span><span class="mi">16</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">init_pte</span><span class="p">,</span><span class="mi">179</span><span class="o">:</span><span class="w"> </span><span class="n">ptep</span><span class="o">:</span><span class="mh">0xfffffffdfda39700</span><span class="p">,</span><span class="n">size</span><span class="w"> </span><span class="n">pte_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008ae0000</span><span class="p">,</span><span class="n">number</span><span class="o">:</span><span class="mi">16</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">init_pte</span><span class="p">,</span><span class="mi">179</span><span class="o">:</span><span class="w"> </span><span class="n">ptep</span><span class="o">:</span><span class="mh">0xfffffffdfda39780</span><span class="p">,</span><span class="n">size</span><span class="w"> </span><span class="n">pte_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008af0000</span><span class="p">,</span><span class="n">number</span><span class="o">:</span><span class="mi">16</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">init_pte</span><span class="p">,</span><span class="mi">179</span><span class="o">:</span><span class="w"> </span><span class="n">ptep</span><span class="o">:</span><span class="mh">0xfffffffdfda39800</span><span class="p">,</span><span class="n">size</span><span class="w"> </span><span class="n">pte_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008b00000</span><span class="p">,</span><span class="n">number</span><span class="o">:</span><span class="mi">16</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">init_pte</span><span class="p">,</span><span class="mi">179</span><span class="o">:</span><span class="w"> </span><span class="n">ptep</span><span class="o">:</span><span class="mh">0xfffffffdfda39880</span><span class="p">,</span><span class="n">size</span><span class="w"> </span><span class="n">pte_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008b10000</span><span class="p">,</span><span class="n">number</span><span class="o">:</span><span class="mi">16</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">init_pte</span><span class="p">,</span><span class="mi">179</span><span class="o">:</span><span class="w"> </span><span class="n">ptep</span><span class="o">:</span><span class="mh">0xfffffffdfda39900</span><span class="p">,</span><span class="n">size</span><span class="w"> </span><span class="n">pte_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008b20000</span><span class="p">,</span><span class="n">number</span><span class="o">:</span><span class="mi">16</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">init_pte</span><span class="p">,</span><span class="mi">179</span><span class="o">:</span><span class="w"> </span><span class="n">ptep</span><span class="o">:</span><span class="mh">0xfffffffdfda39980</span><span class="p">,</span><span class="n">size</span><span class="w"> </span><span class="n">pte_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008b30000</span><span class="p">,</span><span class="n">number</span><span class="o">:</span><span class="mi">16</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">init_pte</span><span class="p">,</span><span class="mi">179</span><span class="o">:</span><span class="w"> </span><span class="n">ptep</span><span class="o">:</span><span class="mh">0xfffffffdfda39a00</span><span class="p">,</span><span class="n">size</span><span class="w"> </span><span class="n">pte_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008b40000</span><span class="p">,</span><span class="n">number</span><span class="o">:</span><span class="mi">16</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">init_pte</span><span class="p">,</span><span class="mi">179</span><span class="o">:</span><span class="w"> </span><span class="n">ptep</span><span class="o">:</span><span class="mh">0xfffffffdfda39a80</span><span class="p">,</span><span class="n">size</span><span class="w"> </span><span class="n">pte_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008b50000</span><span class="p">,</span><span class="n">number</span><span class="o">:</span><span class="mi">16</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">init_pte</span><span class="p">,</span><span class="mi">179</span><span class="o">:</span><span class="w"> </span><span class="n">ptep</span><span class="o">:</span><span class="mh">0xfffffffdfda39b00</span><span class="p">,</span><span class="n">size</span><span class="w"> </span><span class="n">pte_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008b60000</span><span class="p">,</span><span class="n">number</span><span class="o">:</span><span class="mi">16</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">init_pte</span><span class="p">,</span><span class="mi">179</span><span class="o">:</span><span class="w"> </span><span class="n">ptep</span><span class="o">:</span><span class="mh">0xfffffffdfda39b80</span><span class="p">,</span><span class="n">size</span><span class="w"> </span><span class="n">pte_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008b70000</span><span class="p">,</span><span class="n">number</span><span class="o">:</span><span class="mi">16</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">init_pte</span><span class="p">,</span><span class="mi">179</span><span class="o">:</span><span class="w"> </span><span class="n">ptep</span><span class="o">:</span><span class="mh">0xfffffffdfda39c00</span><span class="p">,</span><span class="n">size</span><span class="w"> </span><span class="n">pte_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008b80000</span><span class="p">,</span><span class="n">number</span><span class="o">:</span><span class="mi">16</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">init_pte</span><span class="p">,</span><span class="mi">179</span><span class="o">:</span><span class="w"> </span><span class="n">ptep</span><span class="o">:</span><span class="mh">0xfffffffdfda39c80</span><span class="p">,</span><span class="n">size</span><span class="w"> </span><span class="n">pte_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008b90000</span><span class="p">,</span><span class="n">number</span><span class="o">:</span><span class="mi">16</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">init_pte</span><span class="p">,</span><span class="mi">179</span><span class="o">:</span><span class="w"> </span><span class="n">ptep</span><span class="o">:</span><span class="mh">0xfffffffdfda39d00</span><span class="p">,</span><span class="n">size</span><span class="w"> </span><span class="n">pte_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008ba0000</span><span class="p">,</span><span class="n">number</span><span class="o">:</span><span class="mi">16</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">init_pte</span><span class="p">,</span><span class="mi">179</span><span class="o">:</span><span class="w"> </span><span class="n">ptep</span><span class="o">:</span><span class="mh">0xfffffffdfda39d80</span><span class="p">,</span><span class="n">size</span><span class="w"> </span><span class="n">pte_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008bb0000</span><span class="p">,</span><span class="n">number</span><span class="o">:</span><span class="mi">16</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">init_pte</span><span class="p">,</span><span class="mi">179</span><span class="o">:</span><span class="w"> </span><span class="n">ptep</span><span class="o">:</span><span class="mh">0xfffffffdfda39e00</span><span class="p">,</span><span class="n">size</span><span class="w"> </span><span class="n">pte_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008bc0000</span><span class="p">,</span><span class="n">number</span><span class="o">:</span><span class="mi">16</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">init_pte</span><span class="p">,</span><span class="mi">179</span><span class="o">:</span><span class="w"> </span><span class="n">ptep</span><span class="o">:</span><span class="mh">0xfffffffdfda39e80</span><span class="p">,</span><span class="n">size</span><span class="w"> </span><span class="n">pte_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008bd0000</span><span class="p">,</span><span class="n">number</span><span class="o">:</span><span class="mi">16</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">init_pte</span><span class="p">,</span><span class="mi">179</span><span class="o">:</span><span class="w"> </span><span class="n">ptep</span><span class="o">:</span><span class="mh">0xfffffffdfda39f00</span><span class="p">,</span><span class="n">size</span><span class="w"> </span><span class="n">pte_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008be0000</span><span class="p">,</span><span class="n">number</span><span class="o">:</span><span class="mi">16</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">init_pte</span><span class="p">,</span><span class="mi">179</span><span class="o">:</span><span class="w"> </span><span class="n">ptep</span><span class="o">:</span><span class="mh">0xfffffffdfda39f80</span><span class="p">,</span><span class="n">size</span><span class="w"> </span><span class="n">pte_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008bf0000</span><span class="p">,</span><span class="n">number</span><span class="o">:</span><span class="mi">16</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">init_pte</span><span class="p">,</span><span class="mi">179</span><span class="o">:</span><span class="w"> </span><span class="n">ptep</span><span class="o">:</span><span class="mh">0xfffffffdfda3a000</span><span class="p">,</span><span class="n">size</span><span class="w"> </span><span class="n">pte_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008c00000</span><span class="p">,</span><span class="n">number</span><span class="o">:</span><span class="mi">16</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">alloc_init_cont_pte</span><span class="p">,</span><span class="mi">193</span><span class="o">:</span><span class="w"> </span><span class="n">pmdp</span><span class="o">:</span><span class="mh">0xfffffffdfda38230</span><span class="p">,</span><span class="n">addr</span><span class="o">:</span><span class="mh">0xffffffc008c00000</span><span class="p">,</span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008d70000</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="nl">memblock_reserve</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mh">0x00000000bfffc000-0x00000000bfffcfff</span><span class="p">]</span><span class="w"> </span><span class="n">memblock_alloc_range_nid</span><span class="o">+</span><span class="mh">0xec</span><span class="o">/</span><span class="mh">0x154</span>
<span class="nl">memblock_add_range</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="mh">0x00000000bfffc000</span><span class="p">]</span><span class="w"> </span><span class="n">memblock_reserve</span><span class="o">+</span><span class="mh">0xac</span><span class="o">/</span><span class="mh">0x160</span>
<span class="nl">memblock_insert_region</span><span class="p">:</span><span class="n">name</span><span class="o">:</span><span class="n">reserved</span><span class="w"> </span><span class="p">[</span><span class="mh">0x00000000bfffc000</span><span class="p">]</span><span class="w"> </span><span class="n">size</span><span class="o">:</span><span class="mi">1000</span><span class="p">,</span><span class="n">memblock_add_range</span><span class="p">.</span><span class="n">constprop</span><span class="mf">.0</span><span class="p">.</span><span class="n">isra</span><span class="mf">.0</span><span class="o">+</span><span class="mh">0x19c</span><span class="o">/</span><span class="mh">0x214</span>
<span class="n">alloc_init_cont_pte</span><span class="p">,</span><span class="mi">204</span><span class="o">:</span><span class="w"> </span><span class="n">pte_phys</span><span class="o">:</span><span class="mh">0xbfffc000</span><span class="p">,</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">init_pte</span><span class="p">,</span><span class="mi">179</span><span class="o">:</span><span class="w"> </span><span class="n">ptep</span><span class="o">:</span><span class="mh">0xfffffffdfda39080</span><span class="p">,</span><span class="n">size</span><span class="w"> </span><span class="n">pte_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008c10000</span><span class="p">,</span><span class="n">number</span><span class="o">:</span><span class="mi">16</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">init_pte</span><span class="p">,</span><span class="mi">179</span><span class="o">:</span><span class="w"> </span><span class="n">ptep</span><span class="o">:</span><span class="mh">0xfffffffdfda39100</span><span class="p">,</span><span class="n">size</span><span class="w"> </span><span class="n">pte_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008c20000</span><span class="p">,</span><span class="n">number</span><span class="o">:</span><span class="mi">16</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">init_pte</span><span class="p">,</span><span class="mi">179</span><span class="o">:</span><span class="w"> </span><span class="n">ptep</span><span class="o">:</span><span class="mh">0xfffffffdfda39180</span><span class="p">,</span><span class="n">size</span><span class="w"> </span><span class="n">pte_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008c30000</span><span class="p">,</span><span class="n">number</span><span class="o">:</span><span class="mi">16</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">init_pte</span><span class="p">,</span><span class="mi">179</span><span class="o">:</span><span class="w"> </span><span class="n">ptep</span><span class="o">:</span><span class="mh">0xfffffffdfda39200</span><span class="p">,</span><span class="n">size</span><span class="w"> </span><span class="n">pte_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008c40000</span><span class="p">,</span><span class="n">number</span><span class="o">:</span><span class="mi">16</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">init_pte</span><span class="p">,</span><span class="mi">179</span><span class="o">:</span><span class="w"> </span><span class="n">ptep</span><span class="o">:</span><span class="mh">0xfffffffdfda39280</span><span class="p">,</span><span class="n">size</span><span class="w"> </span><span class="n">pte_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008c50000</span><span class="p">,</span><span class="n">number</span><span class="o">:</span><span class="mi">16</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">init_pte</span><span class="p">,</span><span class="mi">179</span><span class="o">:</span><span class="w"> </span><span class="n">ptep</span><span class="o">:</span><span class="mh">0xfffffffdfda39300</span><span class="p">,</span><span class="n">size</span><span class="w"> </span><span class="n">pte_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008c60000</span><span class="p">,</span><span class="n">number</span><span class="o">:</span><span class="mi">16</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">init_pte</span><span class="p">,</span><span class="mi">179</span><span class="o">:</span><span class="w"> </span><span class="n">ptep</span><span class="o">:</span><span class="mh">0xfffffffdfda39380</span><span class="p">,</span><span class="n">size</span><span class="w"> </span><span class="n">pte_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008c70000</span><span class="p">,</span><span class="n">number</span><span class="o">:</span><span class="mi">16</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">init_pte</span><span class="p">,</span><span class="mi">179</span><span class="o">:</span><span class="w"> </span><span class="n">ptep</span><span class="o">:</span><span class="mh">0xfffffffdfda39400</span><span class="p">,</span><span class="n">size</span><span class="w"> </span><span class="n">pte_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008c80000</span><span class="p">,</span><span class="n">number</span><span class="o">:</span><span class="mi">16</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">init_pte</span><span class="p">,</span><span class="mi">179</span><span class="o">:</span><span class="w"> </span><span class="n">ptep</span><span class="o">:</span><span class="mh">0xfffffffdfda39480</span><span class="p">,</span><span class="n">size</span><span class="w"> </span><span class="n">pte_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008c90000</span><span class="p">,</span><span class="n">number</span><span class="o">:</span><span class="mi">16</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">init_pte</span><span class="p">,</span><span class="mi">179</span><span class="o">:</span><span class="w"> </span><span class="n">ptep</span><span class="o">:</span><span class="mh">0xfffffffdfda39500</span><span class="p">,</span><span class="n">size</span><span class="w"> </span><span class="n">pte_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008ca0000</span><span class="p">,</span><span class="n">number</span><span class="o">:</span><span class="mi">16</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">init_pte</span><span class="p">,</span><span class="mi">179</span><span class="o">:</span><span class="w"> </span><span class="n">ptep</span><span class="o">:</span><span class="mh">0xfffffffdfda39580</span><span class="p">,</span><span class="n">size</span><span class="w"> </span><span class="n">pte_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008cb0000</span><span class="p">,</span><span class="n">number</span><span class="o">:</span><span class="mi">16</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">init_pte</span><span class="p">,</span><span class="mi">179</span><span class="o">:</span><span class="w"> </span><span class="n">ptep</span><span class="o">:</span><span class="mh">0xfffffffdfda39600</span><span class="p">,</span><span class="n">size</span><span class="w"> </span><span class="n">pte_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008cc0000</span><span class="p">,</span><span class="n">number</span><span class="o">:</span><span class="mi">16</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">init_pte</span><span class="p">,</span><span class="mi">179</span><span class="o">:</span><span class="w"> </span><span class="n">ptep</span><span class="o">:</span><span class="mh">0xfffffffdfda39680</span><span class="p">,</span><span class="n">size</span><span class="w"> </span><span class="n">pte_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008cd0000</span><span class="p">,</span><span class="n">number</span><span class="o">:</span><span class="mi">16</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">init_pte</span><span class="p">,</span><span class="mi">179</span><span class="o">:</span><span class="w"> </span><span class="n">ptep</span><span class="o">:</span><span class="mh">0xfffffffdfda39700</span><span class="p">,</span><span class="n">size</span><span class="w"> </span><span class="n">pte_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008ce0000</span><span class="p">,</span><span class="n">number</span><span class="o">:</span><span class="mi">16</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">init_pte</span><span class="p">,</span><span class="mi">179</span><span class="o">:</span><span class="w"> </span><span class="n">ptep</span><span class="o">:</span><span class="mh">0xfffffffdfda39780</span><span class="p">,</span><span class="n">size</span><span class="w"> </span><span class="n">pte_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008cf0000</span><span class="p">,</span><span class="n">number</span><span class="o">:</span><span class="mi">16</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">init_pte</span><span class="p">,</span><span class="mi">179</span><span class="o">:</span><span class="w"> </span><span class="n">ptep</span><span class="o">:</span><span class="mh">0xfffffffdfda39800</span><span class="p">,</span><span class="n">size</span><span class="w"> </span><span class="n">pte_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008d00000</span><span class="p">,</span><span class="n">number</span><span class="o">:</span><span class="mi">16</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">init_pte</span><span class="p">,</span><span class="mi">179</span><span class="o">:</span><span class="w"> </span><span class="n">ptep</span><span class="o">:</span><span class="mh">0xfffffffdfda39880</span><span class="p">,</span><span class="n">size</span><span class="w"> </span><span class="n">pte_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008d10000</span><span class="p">,</span><span class="n">number</span><span class="o">:</span><span class="mi">16</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">init_pte</span><span class="p">,</span><span class="mi">179</span><span class="o">:</span><span class="w"> </span><span class="n">ptep</span><span class="o">:</span><span class="mh">0xfffffffdfda39900</span><span class="p">,</span><span class="n">size</span><span class="w"> </span><span class="n">pte_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008d20000</span><span class="p">,</span><span class="n">number</span><span class="o">:</span><span class="mi">16</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">init_pte</span><span class="p">,</span><span class="mi">179</span><span class="o">:</span><span class="w"> </span><span class="n">ptep</span><span class="o">:</span><span class="mh">0xfffffffdfda39980</span><span class="p">,</span><span class="n">size</span><span class="w"> </span><span class="n">pte_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008d30000</span><span class="p">,</span><span class="n">number</span><span class="o">:</span><span class="mi">16</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">init_pte</span><span class="p">,</span><span class="mi">179</span><span class="o">:</span><span class="w"> </span><span class="n">ptep</span><span class="o">:</span><span class="mh">0xfffffffdfda39a00</span><span class="p">,</span><span class="n">size</span><span class="w"> </span><span class="n">pte_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008d40000</span><span class="p">,</span><span class="n">number</span><span class="o">:</span><span class="mi">16</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">init_pte</span><span class="p">,</span><span class="mi">179</span><span class="o">:</span><span class="w"> </span><span class="n">ptep</span><span class="o">:</span><span class="mh">0xfffffffdfda39a80</span><span class="p">,</span><span class="n">size</span><span class="w"> </span><span class="n">pte_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008d50000</span><span class="p">,</span><span class="n">number</span><span class="o">:</span><span class="mi">16</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">init_pte</span><span class="p">,</span><span class="mi">179</span><span class="o">:</span><span class="w"> </span><span class="n">ptep</span><span class="o">:</span><span class="mh">0xfffffffdfda39b00</span><span class="p">,</span><span class="n">size</span><span class="w"> </span><span class="n">pte_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008d60000</span><span class="p">,</span><span class="n">number</span><span class="o">:</span><span class="mi">16</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
<span class="n">init_pte</span><span class="p">,</span><span class="mi">179</span><span class="o">:</span><span class="w"> </span><span class="n">ptep</span><span class="o">:</span><span class="mh">0xfffffffdfda39b80</span><span class="p">,</span><span class="n">size</span><span class="w"> </span><span class="n">pte_t</span><span class="o">:</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="o">:</span><span class="mh">0xffffffc008d70000</span><span class="p">,</span><span class="n">number</span><span class="o">:</span><span class="mi">16</span><span class="w"> </span><span class="n">map_kernel_segment</span><span class="o">+</span><span class="mh">0xf4</span><span class="o">/</span><span class="mh">0x160</span>
</code></pre></div>
<p>number表示在函数中调用一次init_pte调用set_pte的此次，为16次。</p>
<h2 id="bootmem_init">bootmem_init</h2>
<p>完成了linux物理内存框架的初始化，包括Node, Zone, Page Frame以及对应的数据结构等。</p>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_3dc9de3996ef2284d9b13d36376b4fe1.jpg"><img alt="" src="assets/doc/01-linux/内存管理/内存初始化之物理内存初始化（一）/images/wp_editor_md_3dc9de3996ef2284d9b13d36376b4fe1.jpg"/></a></p>
<div class="codehilite"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="nf">bootmem_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">min</span><span class="p">,</span><span class="w"> </span><span class="n">max</span><span class="p">;</span>

<span class="w">    </span><span class="n">min</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PFN_UP</span><span class="p">(</span><span class="n">memblock_start_of_DRAM</span><span class="p">());</span>
<span class="w">    </span><span class="n">max</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PFN_DOWN</span><span class="p">(</span><span class="n">memblock_end_of_DRAM</span><span class="p">());</span>

<span class="w">    </span><span class="n">early_memtest</span><span class="p">(</span><span class="n">min</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">PAGE_SHIFT</span><span class="p">,</span><span class="w"> </span><span class="n">max</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">PAGE_SHIFT</span><span class="p">);</span>

<span class="w">    </span><span class="n">max_pfn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max_low_pfn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">;</span>
<span class="w">    </span><span class="n">min_low_pfn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">min</span><span class="p">;</span>

<span class="w">    </span><span class="n">arch_numa_init</span><span class="p">();</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * must be done after arch_numa_init() which calls numa_init() to</span>
<span class="cm">     * initialize node_online_map that gets used in hugetlb_cma_reserve()</span>
<span class="cm">     * while allocating required CMA size across online nodes.</span>
<span class="cm">     */</span>
<span class="cp">#if defined(CONFIG_HUGETLB_PAGE) &amp;&amp; defined(CONFIG_CMA)</span>
<span class="w">    </span><span class="n">arm64_hugetlb_cma_reserve</span><span class="p">();</span>
<span class="cp">#endif</span>

<span class="w">    </span><span class="n">dma_pernuma_cma_reserve</span><span class="p">();</span>

<span class="w">    </span><span class="n">kvm_hyp_reserve</span><span class="p">();</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * sparse_init() tries to allocate memory from memblock, so must be</span>
<span class="cm">     * done after the fixed reservations</span>
<span class="cm">     */</span>
<span class="n">sparse_init</span><span class="p">();</span>

<span class="w">    </span><span class="n">zone_sizes_init</span><span class="p">(</span><span class="n">min</span><span class="p">,</span><span class="w"> </span><span class="n">max</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Reserve the CMA area after arm64_dma_phys_limit was initialised.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="n">dma_contiguous_reserve</span><span class="p">(</span><span class="n">arm64_dma_phys_limit</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * request_standard_resources() depends on crashkernel\'s memory being</span>
<span class="cm">     * reserved, so do it here.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">IS_ENABLED</span><span class="p">(</span><span class="n">CONFIG_ZONE_DMA</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">IS_ENABLED</span><span class="p">(</span><span class="n">CONFIG_ZONE_DMA32</span><span class="p">))</span>
<span class="w">        </span><span class="n">reserve_crashkernel</span><span class="p">();</span>

<span class="w">    </span><span class="n">memblock_dump_all</span><span class="p">();</span>
</code></pre></div>
<h3 id="sparse_init">sparse_init</h3>
<p>Linux内核使用通常有三种内存模型，前面两种基本不再使用，目前常用的就是Sparse memory model，sparse init就是对该模型的初始化，主要的目的就是将memblock.memory添加到struct mem_section进行管理。</p>
<h4 id="memory_present">memory_present</h4>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="nf">memblocks_present</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">nid</span><span class="p">;</span>

<span class="w">    </span><span class="n">for_each_mem_pfn_range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">MAX_NUMNODES</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">end</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">nid</span><span class="p">)</span>
<span class="w">        </span><span class="n">memory_present</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span><span class="w"> </span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="p">);</span>
<span class="w">    </span><span class="c1">//从memblock.memory进行遍历可用内存，每块memory返回的是PFN的范围start~end，每个PFN大小4KB。</span>
<span class="p">}</span>

<span class="cm">/* Record a memory area against a node. */</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="nf">memory_present</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">nid</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">pfn</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_SPARSEMEM_EXTREME</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">mem_section</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">align</span><span class="p">;</span>

<span class="w">        </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">mem_section</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">NR_SECTION_ROOTS</span><span class="p">;</span>
<span class="w">        </span><span class="n">align</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">INTERNODE_CACHE_SHIFT</span><span class="p">);</span>
<span class="w">        </span><span class="n">mem_section</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">memblock_alloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">align</span><span class="p">);</span>
<span class="w">        </span><span class="c1">//分配NR_SECTION_ROOTS个数组指针，用于指向struct mem_section的实例。</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">mem_section</span><span class="p">)</span>
<span class="w">            </span><span class="n">panic</span><span class="p">(</span><span class="err">\</span><span class="s">"%s: Failed to allocate %lu bytes align=0x%lx</span><span class="se">\\</span><span class="s">n</span><span class="se">\"</span><span class="s">,</span>
<span class="w">                  </span><span class="n">__func__</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">align</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="cp">#endif</span>

<span class="w">    </span><span class="n">start</span><span class="w"> </span><span class="o">&amp;=</span><span class="w"> </span><span class="n">PAGE_SECTION_MASK</span><span class="p">;</span>
<span class="w">    </span><span class="n">mminit_validate_memmodel_limits</span><span class="p">(</span><span class="o">&amp;</span><span class="n">start</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">end</span><span class="p">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">pfn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">start</span><span class="p">;</span><span class="w"> </span><span class="n">pfn</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">end</span><span class="p">;</span><span class="w"> </span><span class="n">pfn</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">PAGES_PER_SECTION</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">section</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pfn_to_section_nr</span><span class="p">(</span><span class="n">pfn</span><span class="p">);</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">mem_section</span><span class="w"> </span><span class="o">*</span><span class="n">ms</span><span class="p">;</span>

<span class="w">        </span><span class="n">sparse_index_init</span><span class="p">(</span><span class="n">section</span><span class="p">,</span><span class="w"> </span><span class="n">nid</span><span class="p">);</span>
<span class="w">           </span><span class="o">-&gt;</span><span class="n">section</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sparse_index_alloc</span><span class="p">(</span><span class="n">nid</span><span class="p">);</span>
<span class="w">        </span><span class="c1">//为存在的mem_section分配一个实例,并添加到mem_sction中。</span>
<span class="w">        </span><span class="n">set_section_nid</span><span class="p">(</span><span class="n">section</span><span class="p">,</span><span class="w"> </span><span class="n">nid</span><span class="p">);</span>

<span class="w">        </span><span class="n">ms</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__nr_to_section</span><span class="p">(</span><span class="n">section</span><span class="p">);</span>
<span class="w">        </span><span class="c1">//获取该section的指针</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">section_mem_map</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">section_mem_map</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sparse_encode_early_nid</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span><span class="w"> </span><span class="o">|</span>
<span class="w">                            </span><span class="n">SECTION_IS_ONLINE</span><span class="p">;</span>
<span class="w">            </span><span class="n">__section_mark_present</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span><span class="w"> </span><span class="n">section</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="c1">//设置该section的online标志和node id值</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_de4b23f4cb7caf0de027860f16b8ab25.jpg"><img alt="" src="assets/doc/01-linux/内存管理/内存初始化之物理内存初始化（一）/images/wp_editor_md_de4b23f4cb7caf0de027860f16b8ab25.jpg"/></a></p>
<p>物理内存空间按照seciton来组织的，每个section内部其memory是连续的。一个section包含多个page，在内核中由PAGES_PER_SECTION来决定，linux 5.15内核3级页表中为32768，因此内存的范围是32768*4KB=128MB，也就是说一个section最大的内存范围是128MB。</p>
<p>PFN找到对应的page，可以通过PFN-&gt;section-&gt;page。 page找到PFN，page-&gt;section index-&gt;memory_section-&gt;section_mem_map-&gt;PFN</p>
<h4 id="sparse_init_nid">sparse_init_nid</h4>
<p>内存添加到mem_section后，就进行遍历present的section，然后为其分配对应的section结构以及对应的struct page结构体。</p>
<div class="codehilite"><pre><span></span><code><span class="n">for_each_present_section_nr</span><span class="p">(</span><span class="n">pnum_begin</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">pnum_end</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">nid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sparse_early_nid</span><span class="p">(</span><span class="n">__nr_to_section</span><span class="p">(</span><span class="n">pnum_end</span><span class="p">));</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">nid</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">nid_begin</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">map_count</span><span class="o">++</span><span class="p">;</span>
<span class="w">            </span><span class="k">continue</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="cm">/* Init node with sections in range [pnum_begin, pnum_end) */</span>
<span class="w">        </span><span class="n">sparse_init_nid</span><span class="p">(</span><span class="n">nid_begin</span><span class="p">,</span><span class="w"> </span><span class="n">pnum_begin</span><span class="p">,</span><span class="w"> </span><span class="n">pnum_end</span><span class="p">,</span><span class="w"> </span><span class="n">map_count</span><span class="p">);</span>
<span class="w">        </span><span class="n">nid_begin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nid</span><span class="p">;</span>
<span class="w">        </span><span class="n">pnum_begin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pnum_end</span><span class="p">;</span>
<span class="w">        </span><span class="n">map_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w">              </span>
</code></pre></div>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="nf">sparse_init_nid</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">nid</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">pnum_begin</span><span class="p">,</span>
<span class="w">                   </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">pnum_end</span><span class="p">,</span>
<span class="w">                   </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">map_count</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">mem_section_usage</span><span class="w"> </span><span class="o">*</span><span class="n">usage</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">pnum</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">page</span><span class="w"> </span><span class="o">*</span><span class="n">map</span><span class="p">;</span>
<span class="w">    </span><span class="c1">//（1）为mem_section中的mem_section_usage分配内存，用于存储内存段的使用情况</span>
<span class="w">    </span><span class="n">usage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sparse_early_usemaps_alloc_pgdat_section</span><span class="p">(</span><span class="n">NODE_DATA</span><span class="p">(</span><span class="n">nid</span><span class="p">),</span>
<span class="w">            </span><span class="n">mem_section_usage_size</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">map_count</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">usage</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">pr_err</span><span class="p">(</span><span class="err">\</span><span class="s">"%s: node[%d] usemap allocation failed</span><span class="se">\"</span><span class="s">, __func__, nid);</span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">failed</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//（2）为struct page结构体分配内存，一个section最大指向128MB的空间，将分配128*1024/4个数量。</span>
<span class="w">    </span><span class="n">sparse_buffer_init</span><span class="p">(</span><span class="n">map_count</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">section_map_size</span><span class="p">(),</span><span class="w"> </span><span class="n">nid</span><span class="p">);</span>
<span class="w">    </span><span class="n">for_each_present_section_nr</span><span class="p">(</span><span class="n">pnum_begin</span><span class="p">,</span><span class="w"> </span><span class="n">pnum</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">pfn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">section_nr_to_pfn</span><span class="p">(</span><span class="n">pnum</span><span class="p">);</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pnum</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">pnum_end</span><span class="p">)</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>

<span class="w">        </span><span class="n">map</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__populate_section_memmap</span><span class="p">(</span><span class="n">pfn</span><span class="p">,</span><span class="w"> </span><span class="n">PAGES_PER_SECTION</span><span class="p">,</span>
<span class="w">                </span><span class="n">nid</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="w">        </span><span class="c1">//获取该section对应的page 结构体地址，如果使能了vmemmap模型，则地址范围在vmememap区域中，需要建立vmmemap到page frame的页表。</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">map</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">pr_err</span><span class="p">(</span><span class="err">\</span><span class="s">"%s: node[%d] memory map backing failed. Some memory will not be available.</span><span class="se">\"</span><span class="s">,</span>
<span class="w">                   </span><span class="n">__func__</span><span class="p">,</span><span class="w"> </span><span class="n">nid</span><span class="p">);</span>
<span class="w">            </span><span class="n">pnum_begin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pnum</span><span class="p">;</span>
<span class="w">            </span><span class="n">sparse_buffer_fini</span><span class="p">();</span>
<span class="w">            </span><span class="k">goto</span><span class="w"> </span><span class="n">failed</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">check_usemap_section_nr</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span><span class="w"> </span><span class="n">usage</span><span class="p">);</span>
<span class="w">        </span><span class="n">sparse_init_one_section</span><span class="p">(</span><span class="n">__nr_to_section</span><span class="p">(</span><span class="n">pnum</span><span class="p">),</span><span class="w"> </span><span class="n">pnum</span><span class="p">,</span><span class="w"> </span><span class="n">map</span><span class="p">,</span><span class="w"> </span><span class="n">usage</span><span class="p">,</span>
<span class="w">                </span><span class="n">SECTION_IS_EARLY</span><span class="p">);</span>
<span class="w">        </span><span class="c1">//设置section对应的page结构体指针及其标志</span>
<span class="w">        </span><span class="n">usage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">usage</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">mem_section_usage_size</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">sparse_buffer_fini</span><span class="p">();</span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span>
<span class="nl">failed</span><span class="p">:</span>
<span class="w">    </span><span class="cm">/* We failed to allocate, mark all the following pnums as not present */</span>
<span class="w">    </span><span class="n">for_each_present_section_nr</span><span class="p">(</span><span class="n">pnum_begin</span><span class="p">,</span><span class="w"> </span><span class="n">pnum</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">mem_section</span><span class="w"> </span><span class="o">*</span><span class="n">ms</span><span class="p">;</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pnum</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">pnum_end</span><span class="p">)</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="n">ms</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__nr_to_section</span><span class="p">(</span><span class="n">pnum</span><span class="p">);</span>
<span class="w">        </span><span class="n">ms</span><span class="o">-&gt;</span><span class="n">section_mem_map</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span><span class="w"> </span>
</code></pre></div>
<p>虚拟地址空间vmmepmap区域，是内核中page数据的虚拟地址，针对sparse内存模型，内核申请的page返回的地址在该区域。</p>
<h3 id="zone_sizes_init">zone_sizes_init</h3>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="nf">zone_sizes_init</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">min</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">max</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">max_zone_pfns</span><span class="p">[</span><span class="n">MAX_NR_ZONES</span><span class="p">]</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">__maybe_unused</span><span class="w"> </span><span class="n">acpi_zone_dma_bits</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">__maybe_unused</span><span class="w"> </span><span class="n">dt_zone_dma_bits</span><span class="p">;</span>
<span class="n">phys_addr_t</span><span class="w"> </span><span class="n">__maybe_unused</span><span class="w"> </span><span class="n">dma32_phys_limit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max_zone_phys</span><span class="p">(</span><span class="mi">32</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_ZONE_DMA</span>
<span class="w">    </span><span class="n">acpi_zone_dma_bits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fls64</span><span class="p">(</span><span class="n">acpi_iort_dma_get_max_cpu_address</span><span class="p">());</span>
<span class="w">    </span><span class="n">dt_zone_dma_bits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fls64</span><span class="p">(</span><span class="n">of_dma_get_max_cpu_address</span><span class="p">(</span><span class="nb">NULL</span><span class="p">));</span>
<span class="w">    </span><span class="n">zone_dma_bits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">min3</span><span class="p">(</span><span class="mi">32U</span><span class="p">,</span><span class="w"> </span><span class="n">dt_zone_dma_bits</span><span class="p">,</span><span class="w"> </span><span class="n">acpi_zone_dma_bits</span><span class="p">);</span>
<span class="w">    </span><span class="n">arm64_dma_phys_limit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max_zone_phys</span><span class="p">(</span><span class="n">zone_dma_bits</span><span class="p">);</span>
<span class="n">max_zone_pfns</span><span class="p">[</span><span class="n">ZONE_DMA</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PFN_DOWN</span><span class="p">(</span><span class="n">arm64_dma_phys_limit</span><span class="p">);</span>
<span class="c1">//跟进实际物理内存计算ZONE_DMA区的最大PFN数量</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_ZONE_DMA32</span>
<span class="n">max_zone_pfns</span><span class="p">[</span><span class="n">ZONE_DMA32</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">disable_dma32</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">PFN_DOWN</span><span class="p">(</span><span class="n">dma32_phys_limit</span><span class="p">);</span>
<span class="c1">//计算ZONE_DMA_32区的最大PFN数量</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">arm64_dma_phys_limit</span><span class="p">)</span>
<span class="w">        </span><span class="n">arm64_dma_phys_limit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dma32_phys_limit</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="w">    </span><span class="n">max_zone_pfns</span><span class="p">[</span><span class="n">ZONE_NORMAL</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">;</span>
<span class="c1">//计算ZONE_NORMAL区的最大PFN数量</span>
<span class="w">    </span><span class="n">printk</span><span class="p">(</span><span class="err">\</span><span class="s">"%s,%d:dma:%lu, dma32:%lu, Normal:%lu %pS</span><span class="se">\\</span><span class="s">n</span><span class="se">\"</span><span class="s">, __func__,__LINE__,</span>
<span class="w">        </span><span class="n">max_zone_pfns</span><span class="p">[</span><span class="n">ZONE_DMA</span><span class="p">],</span><span class="w"> </span><span class="n">max_zone_pfns</span><span class="p">[</span><span class="n">ZONE_DMA32</span><span class="p">],</span><span class="w"> </span><span class="n">max_zone_pfns</span><span class="p">[</span><span class="n">ZONE_NORMAL</span><span class="p">],(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">_RET_IP_</span><span class="p">);</span>
<span class="n">free_area_init</span><span class="p">(</span><span class="n">max_zone_pfns</span><span class="p">);</span>
<span class="c1">//初始化node和zone信息，以及page结构体。</span>
<span class="p">}</span>
</code></pre></div>
<h5 id="free_area_init">free_area_init</h5>
<div class="codehilite"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="nf">free_area_init</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="o">*</span><span class="n">max_zone_pfn</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">start_pfn</span><span class="p">,</span><span class="w"> </span><span class="n">end_pfn</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">nid</span><span class="p">,</span><span class="w"> </span><span class="n">zone</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">descending</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* Record where the zone boundaries are */</span>
<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="n">arch_zone_lowest_possible_pfn</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">                </span><span class="k">sizeof</span><span class="p">(</span><span class="n">arch_zone_lowest_possible_pfn</span><span class="p">));</span>
<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="n">arch_zone_highest_possible_pfn</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">                </span><span class="k">sizeof</span><span class="p">(</span><span class="n">arch_zone_highest_possible_pfn</span><span class="p">));</span>

<span class="w">    </span><span class="n">start_pfn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">find_min_pfn_with_active_regions</span><span class="p">();</span>
<span class="w">    </span><span class="n">descending</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arch_has_descending_max_zone_pfns</span><span class="p">();</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">MAX_NR_ZONES</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">descending</span><span class="p">)</span>
<span class="w">            </span><span class="n">zone</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MAX_NR_ZONES</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">            </span><span class="n">zone</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">zone</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ZONE_MOVABLE</span><span class="p">)</span>
<span class="w">            </span><span class="k">continue</span><span class="p">;</span>
<span class="w">         </span><span class="c1">//ZONE_MOVABLE是一个虚拟ZONE，实际内存空间不是独立的，因此不需要初始化</span>
<span class="w">        </span><span class="n">end_pfn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">max_zone_pfn</span><span class="p">[</span><span class="n">zone</span><span class="p">],</span><span class="w"> </span><span class="n">start_pfn</span><span class="p">);</span>
<span class="w">        </span><span class="n">arch_zone_lowest_possible_pfn</span><span class="p">[</span><span class="n">zone</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">start_pfn</span><span class="p">;</span>
<span class="w">        </span><span class="n">arch_zone_highest_possible_pfn</span><span class="p">[</span><span class="n">zone</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">end_pfn</span><span class="p">;</span>
<span class="w">        </span><span class="c1">//填充每个zone的地址范围</span>
<span class="w">        </span><span class="n">start_pfn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">end_pfn</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/* Find the PFNs that ZONE_MOVABLE begins at in each node */</span>
<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="n">zone_movable_pfn</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">zone_movable_pfn</span><span class="p">));</span>
<span class="n">find_zone_movable_pfns_for_nodes</span><span class="p">();</span>
<span class="c1">//获取每个节点中ZONE_MOVABLE PFNs</span>

<span class="w">    </span><span class="cm">/* Print out the zone ranges */</span>
<span class="w">    </span><span class="n">pr_info</span><span class="p">(</span><span class="err">\</span><span class="s">"Zone ranges:</span><span class="se">\\</span><span class="s">n</span><span class="se">\"</span><span class="s">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">MAX_NR_ZONES</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ZONE_MOVABLE</span><span class="p">)</span>
<span class="w">            </span><span class="k">continue</span><span class="p">;</span>
<span class="w">        </span><span class="n">pr_info</span><span class="p">(</span><span class="err">\</span><span class="s">"  %-8s </span><span class="se">\"</span><span class="s">, zone_names[i]);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">arch_zone_lowest_possible_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span>
<span class="w">                </span><span class="n">arch_zone_highest_possible_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="w">            </span><span class="n">pr_cont</span><span class="p">(</span><span class="err">\</span><span class="s">"empty</span><span class="se">\\</span><span class="s">n</span><span class="se">\"</span><span class="s">);</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">            </span><span class="n">pr_cont</span><span class="p">(</span><span class="err">\</span><span class="s">"[mem %#018Lx-%#018Lx]</span><span class="se">\\</span><span class="s">n</span><span class="se">\"</span><span class="s">,</span>
<span class="w">                </span><span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">arch_zone_lowest_possible_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="w">                    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">PAGE_SHIFT</span><span class="p">,</span>
<span class="w">                </span><span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">arch_zone_highest_possible_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="w">                    </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">PAGE_SHIFT</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="c1">//打印每个Zone区域的地址范围。</span>

<span class="w">    </span><span class="cm">/* Print out the PFNs ZONE_MOVABLE begins at in each node */</span>
<span class="w">    </span><span class="n">pr_info</span><span class="p">(</span><span class="err">\</span><span class="s">"Movable zone start for each node</span><span class="se">\\</span><span class="s">n</span><span class="se">\"</span><span class="s">);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">MAX_NUMNODES</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">zone_movable_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="w">            </span><span class="n">pr_info</span><span class="p">(</span><span class="err">\</span><span class="s">"  Node %d: %#018Lx</span><span class="se">\\</span><span class="s">n</span><span class="se">\"</span><span class="s">, i,</span>
<span class="w">                   </span><span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">zone_movable_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">PAGE_SHIFT</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">//打印每个节点中ZONE_MOVABLE地址范围</span>
<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Print out the early node map, and initialize the</span>
<span class="cm">     * subsection-map relative to active online memory ranges to</span>
<span class="cm">     * enable future \"sub-section\" extensions of the memory map.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="n">pr_info</span><span class="p">(</span><span class="err">\</span><span class="s">"Early memory node ranges</span><span class="se">\\</span><span class="s">n</span><span class="se">\"</span><span class="s">);</span>
<span class="w">    </span><span class="n">for_each_mem_pfn_range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">MAX_NUMNODES</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">start_pfn</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">end_pfn</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">nid</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">pr_info</span><span class="p">(</span><span class="err">\</span><span class="s">"  node %3d: [mem %#018Lx-%#018Lx]</span><span class="se">\\</span><span class="s">n</span><span class="se">\"</span><span class="s">, nid,</span>
<span class="w">            </span><span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">start_pfn</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">PAGE_SHIFT</span><span class="p">,</span>
<span class="w">            </span><span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">end_pfn</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">PAGE_SHIFT</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="n">subsection_map_init</span><span class="p">(</span><span class="n">start_pfn</span><span class="p">,</span><span class="w"> </span><span class="n">end_pfn</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">start_pfn</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//初始化每个node，实际上ARM64上通常只有一个</span>
<span class="w">    </span><span class="cm">/* Initialise every node */</span>
<span class="w">    </span><span class="n">mminit_verify_pageflags_layout</span><span class="p">();</span>
<span class="w">    </span><span class="n">setup_nr_node_ids</span><span class="p">();</span>
<span class="w">    </span><span class="n">for_each_online_node</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">pg_data_t</span><span class="w"> </span><span class="o">*</span><span class="n">pgdat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NODE_DATA</span><span class="p">(</span><span class="n">nid</span><span class="p">);</span>
<span class="w">        </span><span class="n">free_area_init_node</span><span class="p">(</span><span class="n">nid</span><span class="p">);</span>
<span class="w">        </span><span class="c1">//初始化node相关结构体中pgdat内容，包括各个ZONE区域的spanned_pages,present_pages,memap_pages，nr_kernel_pages,nr_all_pages等等</span>
<span class="w">        </span><span class="cm">/* Any memory on that node */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_present_pages</span><span class="p">)</span>
<span class="w">            </span><span class="n">node_set_state</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span><span class="w"> </span><span class="n">N_MEMORY</span><span class="p">);</span>
<span class="w">            </span><span class="c1">//将node状态从N_ONLINE切换到N_MEMORY状态</span>
<span class="w">        </span><span class="n">check_for_memory</span><span class="p">(</span><span class="n">pgdat</span><span class="p">,</span><span class="w"> </span><span class="n">nid</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="n">memmap_init</span><span class="p">();</span>
<span class="c1">//遍历memblock的region，跟进PFN找到对应的struct page，对该结构体进行初始化，设置MIFRATE_MOVABLE标志等等。</span>
<span class="p">}</span>
</code></pre></div>
<h5 id="free_area_init_node">free_area_init_node</h5>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="nf">free_area_init_node</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">nid</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">pg_data_t</span><span class="w"> </span><span class="o">*</span><span class="n">pgdat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NODE_DATA</span><span class="p">(</span><span class="n">nid</span><span class="p">);</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">start_pfn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">end_pfn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* pg_data_t should be reset to zero when it\'s allocated */</span>
<span class="w">    </span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">nr_zones</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">kswapd_highest_zoneidx</span><span class="p">);</span>
<span class="w">    </span><span class="c1">//获取该节点中PFN的起始号和结束号</span>
<span class="w">    </span><span class="n">get_pfn_range_for_nid</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">start_pfn</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">end_pfn</span><span class="p">);</span>

<span class="w">    </span><span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nid</span><span class="p">;</span>
<span class="w">    </span><span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_start_pfn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">start_pfn</span><span class="p">;</span><span class="w"> </span><span class="c1">//设置该节点的起始PFN</span>
<span class="w">    </span><span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">per_cpu_nodestats</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>

<span class="w">    </span><span class="n">pr_info</span><span class="p">(</span><span class="err">\</span><span class="s">"Initmem setup node %d [mem %#018Lx-%#018Lx]</span><span class="se">\\</span><span class="s">n</span><span class="se">\"</span><span class="s">, nid,</span>
<span class="w">        </span><span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">start_pfn</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">PAGE_SHIFT</span><span class="p">,</span>
<span class="w">        </span><span class="n">end_pfn</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">end_pfn</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">PAGE_SHIFT</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="n">calculate_node_totalpages</span><span class="p">(</span><span class="n">pgdat</span><span class="p">,</span><span class="w"> </span><span class="n">start_pfn</span><span class="p">,</span><span class="w"> </span><span class="n">end_pfn</span><span class="p">);</span>
<span class="w">    </span><span class="c1">//计算pgdat中struct zone成员中的spanned_pages,present_pages等变量内容</span>
<span class="w">    </span><span class="n">alloc_node_mem_map</span><span class="p">(</span><span class="n">pgdat</span><span class="p">);</span>
<span class="w">    </span><span class="n">pgdat_set_deferred_range</span><span class="p">(</span><span class="n">pgdat</span><span class="p">);</span>

<span class="n">free_area_init_core</span><span class="p">(</span><span class="n">pgdat</span><span class="p">);</span>
<span class="c1">// 设置 zone data结构体，包括设置其所有的pages reserved，所有memory queues是空，清空memory bitmaps等等</span>
<span class="p">}</span>
</code></pre></div>
<h5 id="free_area_init_core">free_area_init_core</h5>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="nf">free_area_init_core</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">pglist_data</span><span class="w"> </span><span class="o">*</span><span class="n">pgdat</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">enum</span><span class="w"> </span><span class="n">zone_type</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">nid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_id</span><span class="p">;</span>

<span class="w">    </span><span class="n">pgdat_init_internals</span><span class="p">(</span><span class="n">pgdat</span><span class="p">);</span>
<span class="w">    </span><span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">per_cpu_nodestats</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">boot_nodestats</span><span class="p">;</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">MAX_NR_ZONES</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">zone</span><span class="w"> </span><span class="o">*</span><span class="n">zone</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_zones</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">freesize</span><span class="p">,</span><span class="w"> </span><span class="n">memmap_pages</span><span class="p">;</span>

<span class="w">        </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">spanned_pages</span><span class="p">;</span>
<span class="w">        </span><span class="n">freesize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">present_pages</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/*</span>
<span class="cm">         * Adjust freesize so that it accounts for how much memory</span>
<span class="cm">         * is used by this zone for memmap. This affects the watermark</span>
<span class="cm">         * and per-cpu initialisations</span>
<span class="cm">         */</span>
<span class="w">        </span><span class="n">memmap_pages</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calc_memmap_size</span><span class="p">(</span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">freesize</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">is_highmem_idx</span><span class="p">(</span><span class="n">j</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">freesize</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">memmap_pages</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">freesize</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">memmap_pages</span><span class="p">;</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">memmap_pages</span><span class="p">)</span>
<span class="w">                    </span><span class="n">pr_debug</span><span class="p">(</span><span class="err">\</span><span class="s">"  %s zone: %lu pages used for memmap</span><span class="se">\\</span><span class="s">n</span><span class="se">\"</span><span class="s">,</span>
<span class="w">                         </span><span class="n">zone_names</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="w"> </span><span class="n">memmap_pages</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span>
<span class="w">                </span><span class="n">pr_warn</span><span class="p">(</span><span class="err">\</span><span class="s">"  %s zone: %lu memmap pages exceeds freesize %lu</span><span class="se">\\</span><span class="s">n</span><span class="se">\"</span><span class="s">,</span>
<span class="w">                    </span><span class="n">zone_names</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="w"> </span><span class="n">memmap_pages</span><span class="p">,</span><span class="w"> </span><span class="n">freesize</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="cm">/* Account for reserved pages */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">freesize</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">dma_reserve</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">freesize</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">dma_reserve</span><span class="p">;</span>
<span class="w">            </span><span class="n">pr_debug</span><span class="p">(</span><span class="err">\</span><span class="s">"  %s zone: %lu pages reserved</span><span class="se">\\</span><span class="s">n</span><span class="se">\"</span><span class="s">, zone_names[0], dma_reserve);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">is_highmem_idx</span><span class="p">(</span><span class="n">j</span><span class="p">))</span>
<span class="w">            </span><span class="n">nr_kernel_pages</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">freesize</span><span class="p">;</span>
<span class="w">        </span><span class="cm">/* Charge for highmem memmap if there are enough kernel pages */</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">nr_kernel_pages</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">memmap_pages</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="w">            </span><span class="n">nr_kernel_pages</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">memmap_pages</span><span class="p">;</span>
<span class="w">        </span><span class="n">nr_all_pages</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">freesize</span><span class="p">;</span>

<span class="w">        </span><span class="cm">/*</span>
<span class="cm">         * Set an approximate value for lowmem here, it will be adjusted</span>
<span class="cm">         * when the bootmem allocator frees pages into the buddy system.</span>
<span class="cm">         * And all highmem pages will be managed by the buddy system.</span>
<span class="cm">         */</span>
<span class="w">        </span><span class="n">zone_init_internals</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">nid</span><span class="p">,</span><span class="w"> </span><span class="n">freesize</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">size</span><span class="p">)</span>
<span class="w">            </span><span class="k">continue</span><span class="p">;</span>

<span class="w">        </span><span class="n">set_pageblock_order</span><span class="p">();</span>
<span class="w">        </span><span class="n">setup_usemap</span><span class="p">(</span><span class="n">zone</span><span class="p">);</span>
<span class="w">        </span><span class="n">init_currently_empty_zone</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span><span class="w"> </span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">zone_start_pfn</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>
<span class="w">        </span><span class="c1">//初始化伙伴系统中使用的free_area[]</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h5 id="zone_init_free_lists">zone_init_free_lists</h5>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">__meminit</span><span class="w"> </span><span class="nf">zone_init_free_lists</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">zone</span><span class="w"> </span><span class="o">*</span><span class="n">zone</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">order</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">;</span>
<span class="w">    </span><span class="n">for_each_migratetype_order</span><span class="p">(</span><span class="n">order</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">free_area</span><span class="p">[</span><span class="n">order</span><span class="p">].</span><span class="n">free_list</span><span class="p">[</span><span class="n">t</span><span class="p">]);</span>
<span class="w">        </span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">free_area</span><span class="p">[</span><span class="n">order</span><span class="p">].</span><span class="n">nr_free</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//初始化free_area[]对应的链表。</span>
<span class="c1">//for_each_migratetype_order可用于迭代指定迁移类型的所有分配阶，先遍历free_area[]，再遍历free_list[]</span>
<span class="p">}</span>
</code></pre></div>
<h5 id="_5">启动打印信息</h5>
<div class="codehilite"><pre><span></span><code><span class="n">启动打印信息</span><span class="err">。</span>

<span class="p">[</span><span class="w">    </span><span class="mf">0.000000</span><span class="p">]</span><span class="w"> </span><span class="n">Zone</span><span class="w"> </span><span class="n">ranges</span><span class="o">:</span>
<span class="p">[</span><span class="w">    </span><span class="mf">0.000000</span><span class="p">]</span><span class="w">   </span><span class="n">DMA</span><span class="w">      </span><span class="p">[</span><span class="n">mem</span><span class="w"> </span><span class="mh">0x0000000040000000-0x00000000bfffffff</span><span class="p">]</span>
<span class="p">[</span><span class="w">    </span><span class="mf">0.000000</span><span class="p">]</span><span class="w">   </span><span class="n">DMA32</span><span class="w">    </span><span class="n">empty</span>
<span class="p">[</span><span class="w">    </span><span class="mf">0.000000</span><span class="p">]</span><span class="w">   </span><span class="n">Normal</span><span class="w">   </span><span class="n">empty</span>
<span class="p">[</span><span class="w">    </span><span class="mf">0.000000</span><span class="p">]</span><span class="w"> </span><span class="n">Movable</span><span class="w"> </span><span class="n">zone</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">each</span><span class="w"> </span><span class="n">node</span>
<span class="p">[</span><span class="w">    </span><span class="mf">0.000000</span><span class="p">]</span><span class="w"> </span><span class="n">Early</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="n">ranges</span>
<span class="p">[</span><span class="w">    </span><span class="mf">0.000000</span><span class="p">]</span><span class="w">   </span><span class="n">node</span><span class="w">   </span><span class="mi">0</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="n">mem</span><span class="w"> </span><span class="mh">0x0000000040000000-0x0000000041ffffff</span><span class="p">]</span>
<span class="p">[</span><span class="w">    </span><span class="mf">0.000000</span><span class="p">]</span><span class="w">   </span><span class="n">node</span><span class="w">   </span><span class="mi">0</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="n">mem</span><span class="w"> </span><span class="mh">0x0000000042000000-0x000000004210ffff</span><span class="p">]</span>
<span class="p">[</span><span class="w">    </span><span class="mf">0.000000</span><span class="p">]</span><span class="w">   </span><span class="n">node</span><span class="w">   </span><span class="mi">0</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="n">mem</span><span class="w"> </span><span class="mh">0x0000000042110000-0x00000000421fffff</span><span class="p">]</span>
<span class="p">[</span><span class="w">    </span><span class="mf">0.000000</span><span class="p">]</span><span class="w">   </span><span class="n">node</span><span class="w">   </span><span class="mi">0</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="n">mem</span><span class="w"> </span><span class="mh">0x0000000042200000-0x0000000042243fff</span><span class="p">]</span>
<span class="p">[</span><span class="w">    </span><span class="mf">0.000000</span><span class="p">]</span><span class="w">   </span><span class="n">node</span><span class="w">   </span><span class="mi">0</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="n">mem</span><span class="w"> </span><span class="mh">0x0000000042244000-0x00000000423fffff</span><span class="p">]</span>
<span class="p">[</span><span class="w">    </span><span class="mf">0.000000</span><span class="p">]</span><span class="w">   </span><span class="n">node</span><span class="w">   </span><span class="mi">0</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="n">mem</span><span class="w"> </span><span class="mh">0x0000000042400000-0x0000000042443fff</span><span class="p">]</span>
<span class="p">[</span><span class="w">    </span><span class="mf">0.000000</span><span class="p">]</span><span class="w">   </span><span class="n">node</span><span class="w">   </span><span class="mi">0</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="n">mem</span><span class="w"> </span><span class="mh">0x0000000042444000-0x00000000bfffffff</span><span class="p">]</span>
</code></pre></div>
<p>内核如何直到给定的分配内存属于何种迁移类型？ 内核提供两个标志，分别用于分配内存是可移动的(__GFP_MOVABLE)或可回收的(__GFP_RECATMABLE)，如果这些标志都没有设置，则分配的内存假定为不可移动。</p>
<p>如何初始化可移动性的分组？</p>
<p><a href="https://www.laumy.tech//wp-content/uploads/2023/11/wp_editor_md_53db4a12d9ea1a1b1474f54fab1b6e53.jpg"><img alt="" src="assets/doc/01-linux/内存管理/内存初始化之物理内存初始化（一）/images/wp_editor_md_53db4a12d9ea1a1b1474f54fab1b6e53.jpg"/></a></p>
<h2 id="build_all_zonelists">build_all_zonelists</h2>
<p><a href="https://www.laumy.tech//wp-content/uploads/2023/11/wp_editor_md_f3030335698a5e978b014bfb37c37d12.jpg"><img alt="" src="assets/doc/01-linux/内存管理/内存初始化之物理内存初始化（一）/images/wp_editor_md_f3030335698a5e978b014bfb37c37d12.jpg"/></a></p>
<p>主要是为node创建一个内存分配时优先级的顺序。将系统中各个节点的各个zone，按照备选节点的优先级顺序依次填写到对应结构体描述符的struct zonelist node_zonelist[]数组中。某node的zonelist可以按下面的优先级进行赋值：</p>
<p>（1）对于不同节点，本地node内存放在zonelist的最前面，其他node的内存根据其与本节点的distance值从小到大依次排列。</p>
<p>（2）对于node内部不同的zone也存在优先级关系，normal zone排在dma zone的前面。</p></div>
  <div class="post-nav">
    <a class="prev" href="伙伴系统.html">← 伙伴系统</a>
    <a class="next" href="内存初始化之页表基本操作.html">内存初始化之页表基本操作 →</a>
  </div>
</article>

      </section>

      <aside class="right-panel">
        
      </aside>
    </main>

    <footer class="site-footer">
      <div class="container">Copyright ©2022-2025 laumy 版权所有</div>
    </footer>

    <script src="assets/site.js"></script>
  </body>
  </html>

