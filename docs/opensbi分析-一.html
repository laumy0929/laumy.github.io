<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>opensbi分析（一） - Laumy的技术栈</title>
    <link rel="stylesheet" href="../../assets/style.css">
    <!-- MathJax支持LaTeX数学公式 -->
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          ignoreHtmlClass: 'tex2jax_ignore',
          processHtmlClass: 'tex2jax_process'
        }
      };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  </head>
  <body>
    <header class="site-header">
      <div class="container">
        <a class="logo" href="../../">Laumy的技术栈</a>
        <div class="search">
          <input id="search-input" type="text" placeholder="输入关键词回车搜索">
        </div>
        <div class="theme-toggle" title="切换主题" id="theme-toggle">☾</div>
        <nav class="top-nav">
          <div class="nav-item"><a href="../../">首页</a></div>
        </nav>
      </div>
    </header>

    <main class="container layout">
      <aside class="left-nav">
        
        <div class="card">
          <div class="card-title">文章目录</div>
          <nav id="toc"><ul><li><a href="#hart">引导Hart启动</a><ul></ul></li><li><a href="#_1">重定位和初始化</a><ul><li><a href="#_2">预备信息</a></li></ul></li><li><a href="#_3">状态初始化</a><ul></ul></li><li><a href="#_4">初始化平台</a><ul></ul></li><li><a href="#sbi_scratch">初始化sbi_scratch</a><ul></ul></li><li><a href="#fdt">FDT重定位</a><ul></ul></li><li><a href="#boot-hard">boot hard启动完成</a><ul></ul></li><li><a href="#boot-hart">非boot hart等待运行</a><ul></ul></li><li><a href="#hart_1">hart 热启动</a><ul></ul></li><li><a href="#_5">小结</a><ul></ul></li></ul></nav>
        </div>
        
      </aside>

      <section class="content">
        
<article class="card post">
  <h1>opensbi分析（一）</h1>
  <div class="meta">2024-05-16 · risc-v</div>
  <div class="post-content"><h2 id="hart">引导Hart启动</h2>
<div class="codehilite"><pre><span></span><code><span class="nl">_start</span><span class="p">:</span>
<span class="w">    </span><span class="cm">/* Find preferred boot HART id */</span>
<span class="w">    </span><span class="n">MOV_3R</span><span class="w">  </span><span class="n">s0</span><span class="p">,</span><span class="w"> </span><span class="n">a0</span><span class="p">,</span><span class="w"> </span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="n">a1</span><span class="p">,</span><span class="w"> </span><span class="n">s2</span><span class="p">,</span><span class="w"> </span><span class="n">a2</span>
<span class="w">    </span><span class="cp"># 将a0,a1,a2的参数分别赋值为s0,s1,s2,这3个参数是前一阶段传入的参数。</span>
<span class="w">    </span><span class="cp"># a0: hart id</span>
<span class="w">    </span><span class="cp"># a1: device tree</span>
<span class="w">    </span><span class="cp"># a2: struct fw_dynamic_info地址</span>

<span class="w">    </span><span class="n">call</span><span class="w">    </span><span class="n">fw_boot_hart</span>
<span class="w">    </span><span class="cp"># fw_boot_hart会根据配置为fw_dynamic、fw_jump、fw_payload三种方式进行跳转，</span>
<span class="w">    </span><span class="cp"># 后两种方式直接返回-1，即hart id使用随机的方式，而fw_dynamic根据传进来的参数</span>
<span class="w">    </span><span class="cp"># 进行解析出boot hart id，a2指向struct fw_dynamic_info</span>
<span class="w">    </span><span class="cp"># 我们这里分析使用的是fw_jump的方式。</span>

<span class="w">    </span><span class="n">add</span><span class="w"> </span><span class="n">a6</span><span class="p">,</span><span class="w"> </span><span class="n">a0</span><span class="p">,</span><span class="w"> </span><span class="n">zero</span>
<span class="w">    </span><span class="cp"># 将经过fw_boot_hart选择的hart id赋值为a6，这样a6保存的就是首先要启动的hart id</span>

<span class="w">    </span><span class="n">MOV_3R</span><span class="w">  </span><span class="n">a0</span><span class="p">,</span><span class="w"> </span><span class="n">s0</span><span class="p">,</span><span class="w"> </span><span class="n">a1</span><span class="p">,</span><span class="w"> </span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="n">a2</span><span class="p">,</span><span class="w"> </span><span class="n">s2</span>
<span class="w">    </span><span class="cp"># 恢复a0,a1,a2的值，之前是暂存到s0,s1,s2中，因为前面调用了fw_boot_hart会修改</span>

<span class="w">    </span><span class="n">li</span><span class="w">  </span><span class="n">a7</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span>
<span class="w">    </span><span class="n">beq</span><span class="w"> </span><span class="n">a6</span><span class="p">,</span><span class="w"> </span><span class="n">a7</span><span class="p">,</span><span class="w"> </span><span class="n">_try_lottery</span>
<span class="w">    </span><span class="cp"># 如果a6为-1,即上一阶段没有选定boot hard id，则使用彩票机制随机选择一个</span>
<span class="w">    </span><span class="cp"># hard id进行先启动。</span>

<span class="w">    </span><span class="cm">/* Jump to relocation wait loop if we are not boot hart */</span>
<span class="w">    </span><span class="n">bne</span><span class="w"> </span><span class="n">a0</span><span class="p">,</span><span class="w"> </span><span class="n">a6</span><span class="p">,</span><span class="w"> </span><span class="n">_wait_relocate_copy_done</span>
<span class="w">    </span><span class="cp"># 如果选择的boot hard id与当前运行的hart id不等，则进行等待boot hart id先运行。</span>

<span class="nl">_try_lottery</span><span class="p">:</span><span class="err">（</span><span class="n">彩票机制选择一个hart</span><span class="w"> </span><span class="n">id作为启动hart</span><span class="err">）</span>
<span class="w">    </span><span class="cm">/* Jump to relocation wait loop if we don't get relocation lottery */</span>
<span class="w">    </span><span class="n">lla</span><span class="w"> </span><span class="n">a6</span><span class="p">,</span><span class="w"> </span><span class="n">_relocate_lottery</span>
<span class="w">    </span><span class="cp"># 加载_relocate_lottery（是一段bss空间）到a6寄存</span>
<span class="w">    </span><span class="n">li</span><span class="w">  </span><span class="n">a7</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="n">amoadd</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="n">a6</span><span class="p">,</span><span class="w"> </span><span class="n">a7</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">a6</span><span class="p">)</span>
<span class="w">    </span><span class="cp"># a6指向的地址上的值（_relocate_lottery 的地址）做原子加 1，</span>
<span class="w">    </span><span class="cp"># _relocate_lottery 的老值写入a6（最原始的值为0）。</span>
<span class="w">    </span><span class="n">bnez</span><span class="w">    </span><span class="n">a6</span><span class="p">,</span><span class="w"> </span><span class="n">_wait_relocate_copy_done</span>
<span class="w">    </span><span class="cp"># 如果a6不等于0，表示不是最先执行的hart，则跳转到_wait_relocate_copy_done</span>
<span class="w">    </span><span class="cp"># 等待，如果等于0，表示最快运行的hart，则为boot hart往下走</span>
<span class="w">    </span><span class="cp"># 与其说是彩票机制，看起来是赛跑机制，最先跑到这段代码的作为boot hart</span>
</code></pre></div>
<p>上面的代码，主要是获取一个hart 作为boot hart，选定了boot hart后，其他的hart就需要等待boot hart先运行完成相关初始化工作再运行。如果opensbi使用的是fw_jump、fw_payload，选择boot hart的方式就是彩票机制。</p>
<h2 id="_1">重定位和初始化</h2>
<h3 id="_2">预备信息</h3>
<h4 id="_fw_start">_fw_start</h4>
<p>_fw_start的值，在链接脚本 build/platform/generic/firmware/fw_jump.elf.ld中指定 <a href="https://www.laumy.tech/wp-content/uploads/2024/05/wp_editor_md_9c3807da2c0941724b7dbfc629354ac2.jpg"><img alt="" src="assets/doc/02-risc-v/opensbi分析（一）/images/wp_editor_md_9c3807da2c0941724b7dbfc629354ac2.jpg"/></a></p>
<p>从通过工具链读取到_fw_start为0x80000000,如下：</p>
<p><a href="https://www.laumy.tech/wp-content/uploads/2024/05/wp_editor_md_2b32ae0fe9b5e437f62b9d2e48fff47d.jpg"><img alt="" src="assets/doc/02-risc-v/opensbi分析（一）/images/wp_editor_md_2b32ae0fe9b5e437f62b9d2e48fff47d.jpg"/></a></p>
<h4 id="reladyn">.rela.dyn</h4>
<p>.rela.dyn是重定位段，重定位是连接符号引用与符号定义的过程。例如，程序调用函数时，关联的调用指令必须在执行时将控制权转移到正确的目标地址。可重定位文件必须包含说明如何修改其节内容的信息。通过此信息，可执行文件和共享目标文件可包含进程的程序映像的正确信息。重定位项即是这些数据。</p>
<div class="codehilite"><pre><span></span><code><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">elf32_rela</span><span class="p">{</span>
<span class="w">  </span><span class="n">Elf32_Addr</span><span class="w">    </span><span class="n">r_offset</span><span class="p">;</span>
<span class="w">  </span><span class="n">Elf32_Word</span><span class="w">    </span><span class="n">r_info</span><span class="p">;</span>
<span class="w">  </span><span class="n">Elf32_Sword</span><span class="w">   </span><span class="n">r_addend</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">Elf32_Rela</span><span class="p">;</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">elf64_rela</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">Elf64_Addr</span><span class="w"> </span><span class="n">r_offset</span><span class="p">;</span><span class="w">  </span><span class="cm">/* Location at which to apply the action */</span>
<span class="w">  </span><span class="n">Elf64_Xword</span><span class="w"> </span><span class="n">r_info</span><span class="p">;</span><span class="w">   </span><span class="cm">/* index and type of relocation */</span>
<span class="w">  </span><span class="n">Elf64_Sxword</span><span class="w"> </span><span class="n">r_addend</span><span class="p">;</span><span class="w">    </span><span class="cm">/* Constant addend used to compute value */</span>
<span class="p">}</span><span class="w"> </span><span class="n">Elf64_Rela</span><span class="p">;</span>
</code></pre></div>
<p>重定位表的每个条目的内容如上数据结构所示，有3个变量。</p>
<ul>
<li>r_offset: 需要重定位地址的偏移，外部符号在got表的偏移</li>
<li>r_r_info: 重定位的方法</li>
<li>r_addend：重定位计算的值</li>
</ul>
<p>使用 riscv64-unknown-linux-gnu-readelf -S build/platform/generic/firmware/fw_jump.elf命令可以看到重定位表的地址。</p>
<p><a href="https://www.laumy.tech/wp-content/uploads/2024/05/wp_editor_md_053503180c2ea4d7d1a4daae09be0ec3.jpg"><img alt="" src="assets/doc/02-risc-v/opensbi分析（一）/images/wp_editor_md_053503180c2ea4d7d1a4daae09be0ec3.jpg"/></a></p>
<p>如上图.rela.dyn的地址为0x8001c3a8，长度为0x2418。</p>
<p>执行riscv64-unknown-linux-gnu-readelf -rW build/platform/generic/firmware/fw_jump.elf可以查看重定位信息表。 <a href="https://www.laumy.tech/wp-content/uploads/2024/05/wp_editor_md_a334cd8ead484a4434f97d55a5abea15.jpg"><img alt="" src="assets/doc/02-risc-v/opensbi分析（一）/images/wp_editor_md_a334cd8ead484a4434f97d55a5abea15.jpg"/></a></p>
<p>上图所示，fw_jump.elf的重定位表中有385个条目，即有385个地址需要重定位，上图中r_info是0x3,即类型是R_RISCV_RELATIVE，则重定位方式是按照B+A，B表示执行过程中将共享目标文件装入内存的基本地址，通常生成的共享目标文件的基本虚拟地址为0，在本节中B为_fw_start - FW_TEXT_START；A表示常量加数，用于计算存储在可重定位字段中的值，即r_addend的值，所以0x80020018的地址重定位到0x80000000。</p>
<p>怎么理解_fw_start 和 FW_TEXT_START地址？</p>
<ul>
<li>_fw_start表示加载地址</li>
<li>FW_TEXT_START表示链接地址</li>
</ul>
<p>在opensbi 1.2版本，_fw_start和FW_TEXT_START是一样的。</p>
<p><a href="https://www.laumy.tech/wp-content/uploads/2024/05/wp_editor_md_da1a1fd18d1fc19cf1244668f42433bf.jpg"><img alt="" src="assets/doc/02-risc-v/opensbi分析（一）/images/wp_editor_md_da1a1fd18d1fc19cf1244668f42433bf.jpg"/></a></p>
<p>OpenSBI在什么时候引入的PIE支持？</p>
<p>在1.0版本引入的，<a href="https://github.com/riscv-software-src/opensbi/commit/0f20e8a?diff=split&amp;w=0">https://github.com/riscv-software-src/opensbi/commit/0f20e8a?diff=split&amp;w=0</a></p>
<ul>
<li>链接脚本包含.rela.dyn节，该节中的所有重定位表项均是R_RISCV_RELATIVE类型。</li>
<li>Self-relocataion发生在非常早期的汇编代码阶段firmware/fw_base.S</li>
<li>遍历.rela.dyn节里的所有重定位表项，进行地址修正</li>
<li>在重定位完成之前，所有对全局变量的地址引用，需要显式使用lla汇编伪指令（load local address）而不是la</li>
<li>la在PIE模式下会编译成对GOT表的引用。</li>
</ul>
<p>rela.dyn和.rel.dyn有什么区别？</p>
<p>.rel.dyn 和 .rela.dyn 都是 ELF 文件中用于存储重定位条目的节（section），它们主要用于动态链接过程中修正全局偏移表（GOT, Global Offset Table）和程序中的某些地址。不过，它们之间存在一些关键差异：</p>
<p>（1）数据结构不同：.rel.dyn 使用的是 REL 类型的重定位条目，每个条目包含两个字段：一个表示需要被重定位的位置的偏移量，另一个表示重定位类型。 .rela.dyn 使用的是 RELA 类型的重定位条目，在 REL 类型的基础上增加了一个 additive constant 字段，使得重定位操作可以直接应用一个立即数到目标位置，而不需要像 REL 那样进行间接计算。这意味着 RELA 类型提供了更直接的重定位能力。 （2）内存占用和效率：RELA 类型由于包含额外的 additive constant 字段，所以每个条目相比 REL 类型会占用更多的空间。然而，RELA 类型在处理时可能因为直接性而稍微提高效率，因为它减少了处理器需要执行的计算步骤。 （3）使用场景：在不同的系统或编译器配置下，可能会优先选择使用其中一种类型。通常，现代系统和编译器更倾向于使用 .rela.dyn，因为它虽然占用更多空间，但提供的直接重定位能力简化了链接过程。 总的来说，.rel.dyn 和 .rela.dyn 都服务于动态链接时的地址修正，主要区别在于重定位条目的格式及其对空间和处理效率的影响。在具体应用中，根据编译器选项和目标系统的偏好，会选择使用其中之一来完成动态链接所需的重定位工作。</p>
<div class="codehilite"><pre><span></span><code><span class="w">    </span><span class="cm">/* Save load address */</span>
<span class="w">    </span><span class="n">lla</span><span class="w"> </span><span class="n">t0</span><span class="p">,</span><span class="w"> </span><span class="n">_load_start</span>
<span class="w">    </span><span class="cp"># 加载地址存储到t0寄存器：0x0000000080020018</span>
<span class="w">    </span><span class="n">lla</span><span class="w"> </span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="n">_fw_start</span>
<span class="w">    </span><span class="cp"># _fw_start存储到t1寄存器：t1片=0x0000000080000000</span>
<span class="w">    </span><span class="cp"># _fw_start为链接脚本中设定的起始地址</span>
<span class="w">    </span><span class="n">REG_S</span><span class="w">   </span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">(</span><span class="n">t0</span><span class="p">)</span>
<span class="w">    </span><span class="cp"># REG_S是sd，即t1的值存储到t0的地址</span>
<span class="w">    </span><span class="cp"># 可以理解为_load_start是一个全局指针（指向事先分配的空间），将fw_jump.elf</span>
<span class="w">    </span><span class="cp"># 的起始地址即，在链接脚本中设置的赋值_load_start中存储。</span>

<span class="cp">#ifdef FW_PIC</span>
<span class="w">    </span><span class="cm">/* relocate the global table content */</span>
<span class="w">    </span><span class="n">lla</span><span class="w"> </span><span class="n">t0</span><span class="p">,</span><span class="w"> </span><span class="n">_link_start</span>
<span class="w">    </span><span class="cp"># _link_start存储到t0寄存器：t0 = 0x0000000080020020</span>
<span class="w">    </span><span class="n">REG_L</span><span class="w">   </span><span class="n">t0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">(</span><span class="n">t0</span><span class="p">)</span>
<span class="w">    </span><span class="cp"># 将t0地址的值加载到t0,t0=0x0000000080000000，</span>
<span class="w">    </span><span class="cp"># _link_start指向一个dword全局变量的指针，指向的是FW_TEXT_START</span>
<span class="w">    </span><span class="cp"># 在firmware/fw_base.S中如下定义</span>
<span class="w">    </span><span class="cp">#  _link_start:gg</span>
<span class="w">    </span><span class="cp">#  RISCV_PTR   FW_TEXT_START</span>
<span class="w">    </span><span class="cp"># 所以上面代码的意思就是将FW_TEXT_START赋值为t0,FW_TEXT_START在</span>
<span class="w">    </span><span class="cp"># platform/generic/objects.mk中定义，表示FW TEXT段的开始地址</span>
<span class="w">    </span><span class="cp"># 正好也是FW_TEXT_START=0x80000000</span>
<span class="w">    </span><span class="cp"># FW_TEXT_START设置的是固件要运行的起始地址，而_fw_start是链接地址</span>

<span class="w">    </span><span class="cm">/* t1 shall has the address of _fw_start */</span>
<span class="w">    </span><span class="n">sub</span><span class="w"> </span><span class="n">t2</span><span class="p">,</span><span class="w"> </span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="n">t0</span>
<span class="w">    </span><span class="cp"># t2 = _fw_start - FW_TEXT_START，计算要运行地址和链接地址的差值</span>
<span class="w">    </span><span class="n">lla</span><span class="w"> </span><span class="n">t3</span><span class="p">,</span><span class="w"> </span><span class="n">_runtime_offset</span>
<span class="w">    </span><span class="cp"># t3 = 0x0000000080020060,申请的一个全局变量（bss空间）</span>
<span class="w">    </span><span class="n">REG_S</span><span class="w">   </span><span class="n">t2</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">t3</span><span class="p">)</span>
<span class="w">    </span><span class="cp"># 将运行的地址与链接地址的偏移存储到_runtime_offset指向的地址中</span>

<span class="w">    </span><span class="n">lla</span><span class="w"> </span><span class="n">t0</span><span class="p">,</span><span class="w"> </span><span class="n">__rel_dyn_start</span>
<span class="w">    </span><span class="cp"># 重定位表开始地址：0x000000008001c3a8</span>
<span class="w">    </span><span class="n">lla</span><span class="w"> </span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="n">__rel_dyn_end</span>
<span class="w">    </span><span class="cp"># 重定位表的结束地址：0x000000008001e7c0</span>
<span class="w">    </span><span class="cp"># 结束地址减去起始地址正好size为0x2418,跟前面章节对应。</span>

<span class="w">    </span><span class="n">beq</span><span class="w"> </span><span class="n">t0</span><span class="p">,</span><span class="w"> </span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="n">_relocate_done</span>
<span class="w">    </span><span class="n">j</span><span class="w">   </span><span class="mf">5f</span>
<span class="w">    </span><span class="cp"># 如果重定位表的开始地址等于结束地址，说明不需要重定位，直接跳转到</span>
<span class="w">    </span><span class="cp"># _relocate_done结束重定位，否则跳转到5标签进行重定位。</span>
<span class="mi">2</span><span class="o">:</span>
<span class="w">    </span><span class="n">REG_L</span><span class="w">   </span><span class="n">t5</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="p">(</span><span class="n">REGBYTES</span><span class="o">*</span><span class="mi">2</span><span class="p">)(</span><span class="n">t0</span><span class="p">)</span><span class="w">   </span><span class="cm">/* t5 &lt;-- relocation info:type */</span>
<span class="w">    </span><span class="cp"># REG_L为ld，t0-16地址指向条目的第二个成员变量即info type</span>
<span class="w">    </span><span class="n">li</span><span class="w">  </span><span class="n">t3</span><span class="p">,</span><span class="w"> </span><span class="n">R_RISCV_RELATIVE</span><span class="w">    </span><span class="cm">/* reloc type R_RISCV_RELATIVE */</span>
<span class="w">    </span><span class="n">bne</span><span class="w"> </span><span class="n">t5</span><span class="p">,</span><span class="w"> </span><span class="n">t3</span><span class="p">,</span><span class="w"> </span><span class="mf">3f</span>
<span class="w">    </span><span class="cp"># 如果info type不是R_RISCV_RELATIVE类型，则跳转到标签</span>
<span class="w">    </span><span class="cp"># 接下来就是处理info type为R_RISCV_RELATIVE的重定位</span>
<span class="w">    </span><span class="n">REG_L</span><span class="w">   </span><span class="n">t3</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="p">(</span><span class="n">REGBYTES</span><span class="o">*</span><span class="mi">3</span><span class="p">)(</span><span class="n">t0</span><span class="p">)</span>
<span class="w">    </span><span class="cp"># 获取重定位表一个条目中offset的值存储到t3</span>
<span class="w">    </span><span class="n">REG_L</span><span class="w">   </span><span class="n">t5</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="p">(</span><span class="n">REGBYTES</span><span class="p">)(</span><span class="n">t0</span><span class="p">)</span><span class="w"> </span><span class="cm">/* t5 &lt;-- addend */</span>
<span class="w">    </span><span class="cp"># 获取重定位表一个条目中addend值</span>
<span class="w">    </span><span class="n">add</span><span class="w"> </span><span class="n">t5</span><span class="p">,</span><span class="w"> </span><span class="n">t5</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span>
<span class="w">    </span><span class="cp"># 即重定位地址为B+A，A为addend值，B=_fw_start - FW_TEXT_START</span>
<span class="w">    </span><span class="n">add</span><span class="w"> </span><span class="n">t3</span><span class="p">,</span><span class="w"> </span><span class="n">t3</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span>
<span class="w">    </span><span class="n">REG_S</span><span class="w">   </span><span class="n">t5</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">(</span><span class="n">t3</span><span class="p">)</span><span class="w">       </span><span class="cm">/* store runtime address to the GOT entry */</span>
<span class="w">    </span><span class="cp"># 将重定位的地址更新到GOT表中去。</span>
<span class="w">    </span><span class="n">j</span><span class="w">   </span><span class="mf">5f</span>
<span class="w">    </span><span class="cp"># 跳转到标签5继续循环，将所有的重定位条目更新到GOT表中去。</span>

<span class="w">    </span><span class="cp"># 标签3和4是针对info type不是R_RISCV_RELATIVE的处理，这里就不再分析了。</span>
<span class="mi">3</span><span class="o">:</span>
<span class="w">    </span><span class="n">lla</span><span class="w"> </span><span class="n">t4</span><span class="p">,</span><span class="w"> </span><span class="n">__dyn_sym_start</span>
<span class="mi">4</span><span class="o">:</span>
<span class="w">    </span><span class="n">REG_L</span><span class="w">   </span><span class="n">t5</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="p">(</span><span class="n">REGBYTES</span><span class="o">*</span><span class="mi">2</span><span class="p">)(</span><span class="n">t0</span><span class="p">)</span><span class="w">   </span><span class="cm">/* t5 &lt;-- relocation info:type */</span>
<span class="w">    </span><span class="n">srli</span><span class="w">    </span><span class="n">t6</span><span class="p">,</span><span class="w"> </span><span class="n">t5</span><span class="p">,</span><span class="w"> </span><span class="n">SYM_INDEX</span><span class="w">   </span><span class="cm">/* t6 &lt;--- sym table index */</span>
<span class="w">    </span><span class="n">andi</span><span class="w">    </span><span class="n">t5</span><span class="p">,</span><span class="w"> </span><span class="n">t5</span><span class="p">,</span><span class="w"> </span><span class="mh">0xFF</span><span class="w">        </span><span class="cm">/* t5 &lt;--- relocation type */</span>
<span class="w">    </span><span class="n">li</span><span class="w">  </span><span class="n">t3</span><span class="p">,</span><span class="w"> </span><span class="n">RELOC_TYPE</span>
<span class="w">    </span><span class="n">bne</span><span class="w"> </span><span class="n">t5</span><span class="p">,</span><span class="w"> </span><span class="n">t3</span><span class="p">,</span><span class="w"> </span><span class="mf">5f</span>
<span class="w">    </span><span class="cm">/* address R_RISCV_64 or R_RISCV_32 cases*/</span>
<span class="w">    </span><span class="n">REG_L</span><span class="w">   </span><span class="n">t3</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="p">(</span><span class="n">REGBYTES</span><span class="o">*</span><span class="mi">3</span><span class="p">)(</span><span class="n">t0</span><span class="p">)</span>
<span class="w">    </span><span class="n">li</span><span class="w">  </span><span class="n">t5</span><span class="p">,</span><span class="w"> </span><span class="n">SYM_SIZE</span>
<span class="w">    </span><span class="n">mul</span><span class="w"> </span><span class="n">t6</span><span class="p">,</span><span class="w"> </span><span class="n">t6</span><span class="p">,</span><span class="w"> </span><span class="n">t5</span>
<span class="w">    </span><span class="n">add</span><span class="w"> </span><span class="n">s5</span><span class="p">,</span><span class="w"> </span><span class="n">t4</span><span class="p">,</span><span class="w"> </span><span class="n">t6</span>
<span class="w">    </span><span class="n">REG_L</span><span class="w">   </span><span class="n">t6</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="p">(</span><span class="n">REGBYTES</span><span class="p">)(</span><span class="n">t0</span><span class="p">)</span><span class="w"> </span><span class="cm">/* t0 &lt;-- addend */</span>
<span class="w">    </span><span class="n">REG_L</span><span class="w">   </span><span class="n">t5</span><span class="p">,</span><span class="w"> </span><span class="n">REGBYTES</span><span class="p">(</span><span class="n">s5</span><span class="p">)</span>
<span class="w">    </span><span class="n">add</span><span class="w"> </span><span class="n">t5</span><span class="p">,</span><span class="w"> </span><span class="n">t5</span><span class="p">,</span><span class="w"> </span><span class="n">t6</span>
<span class="w">    </span><span class="n">add</span><span class="w"> </span><span class="n">t5</span><span class="p">,</span><span class="w"> </span><span class="n">t5</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span><span class="w">      </span><span class="cm">/* t5 &lt;-- location to fix up in RAM */</span>
<span class="w">    </span><span class="n">add</span><span class="w"> </span><span class="n">t3</span><span class="p">,</span><span class="w"> </span><span class="n">t3</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span><span class="w">      </span><span class="cm">/* t3 &lt;-- location to fix up in RAM */</span>
<span class="w">    </span><span class="n">REG_S</span><span class="w">   </span><span class="n">t5</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">(</span><span class="n">t3</span><span class="p">)</span><span class="w">       </span><span class="cm">/* store runtime address to the variable */</span>

<span class="mi">5</span><span class="o">:</span>
<span class="w">    </span><span class="n">addi</span><span class="w">    </span><span class="n">t0</span><span class="p">,</span><span class="w"> </span><span class="n">t0</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">REGBYTES</span><span class="o">*</span><span class="mi">3</span><span class="p">)</span>
<span class="w">    </span><span class="cp"># REGBYTES在64位系统为8字节大小，__rel_dyn_start偏移3个变量，即24字节大小</span>
<span class="w">    </span><span class="cp"># 正好就是一个条目的大小（Elf64_Rela数据结构）。</span>
<span class="w">    </span><span class="n">ble</span><span class="w"> </span><span class="n">t0</span><span class="p">,</span><span class="w"> </span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="n">b</span>
<span class="w">    </span><span class="cp"># 如果t0加了一个条目的大小还小于__rel_dyn_end则跳转到2标签。</span>

<span class="w">    </span><span class="n">j</span><span class="w">   </span><span class="n">_relocate_done</span>
<span class="nl">_wait_relocate_copy_done</span><span class="p">:</span>
<span class="w">    </span><span class="n">j</span><span class="w">   </span><span class="n">_wait_for_boot_hart</span>

<span class="nl">_relocate_done</span><span class="p">:</span>
<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Mark relocate copy done</span>
<span class="cm">     * Use _boot_status copy relative to the load address</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="n">lla</span><span class="w"> </span><span class="n">t0</span><span class="p">,</span><span class="w"> </span><span class="n">_boot_status</span>
<span class="w">    </span><span class="cp"># t0 = 0x0000000080020010</span>
<span class="cp">#ifndef FW_PIC</span>
<span class="w">    </span><span class="n">lla</span><span class="w"> </span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="n">_link_start</span>
<span class="w">    </span><span class="n">REG_L</span><span class="w">   </span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span>
<span class="w">    </span><span class="n">lla</span><span class="w"> </span><span class="n">t2</span><span class="p">,</span><span class="w"> </span><span class="n">_load_start</span>
<span class="w">    </span><span class="n">REG_L</span><span class="w">   </span><span class="n">t2</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span>
<span class="w">    </span><span class="n">sub</span><span class="w"> </span><span class="n">t0</span><span class="p">,</span><span class="w"> </span><span class="n">t0</span><span class="p">,</span><span class="w"> </span><span class="n">t1</span>
<span class="w">    </span><span class="n">add</span><span class="w"> </span><span class="n">t0</span><span class="p">,</span><span class="w"> </span><span class="n">t0</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span>
<span class="cp">#endif</span>
<span class="w">    </span><span class="n">li</span><span class="w">  </span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="n">BOOT_STATUS_RELOCATE_DONE</span>
<span class="w">    </span><span class="cp"># t1 = 1</span>
<span class="w">    </span><span class="n">REG_S</span><span class="w">   </span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">(</span><span class="n">t0</span><span class="p">)</span>
<span class="w">    </span><span class="cp"># 将1 写到_boot_status指向的地址</span>
<span class="w">    </span><span class="n">fence</span><span class="w">   </span><span class="n">rw</span><span class="p">,</span><span class="w"> </span><span class="n">rw</span>
<span class="w">    </span><span class="cp"># 建立一个全局内存屏障，确保该指令执行前后，所有写操作都完成完成。</span>
<span class="w">    </span><span class="cp"># _relocate_done的作用就是写一个标志位到_boot_status表示重定位</span>
<span class="w">    </span><span class="cp"># 已经完成。</span>
</code></pre></div>
<h2 id="_3">状态初始化</h2>
<div class="codehilite"><pre><span></span><code><span class="w">    </span><span class="cm">/* At this point we are running from link address */</span>

<span class="w">    </span><span class="cm">/* Reset all registers for boot HART */</span>
<span class="w">    </span><span class="n">li</span><span class="w">  </span><span class="n">ra</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span>
<span class="w">    </span><span class="n">call</span><span class="w">    </span><span class="n">_reset_regs</span>
<span class="w">    </span><span class="cp"># 清除所有的寄存器</span>

<span class="w">    </span><span class="cm">/* Zero-out BSS */</span>
<span class="w">    </span><span class="n">lla</span><span class="w"> </span><span class="n">s4</span><span class="p">,</span><span class="w"> </span><span class="n">_bss_start</span>
<span class="w">    </span><span class="n">lla</span><span class="w"> </span><span class="n">s5</span><span class="p">,</span><span class="w"> </span><span class="n">_bss_end</span>
<span class="nl">_bss_zero</span><span class="p">:</span>
<span class="w">    </span><span class="n">REG_S</span><span class="w">   </span><span class="n">zero</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">s4</span><span class="p">)</span>
<span class="w">    </span><span class="n">add</span><span class="w"> </span><span class="n">s4</span><span class="p">,</span><span class="w"> </span><span class="n">s4</span><span class="p">,</span><span class="w"> </span><span class="n">__SIZEOF_POINTER__</span>
<span class="w">    </span><span class="n">blt</span><span class="w"> </span><span class="n">s4</span><span class="p">,</span><span class="w"> </span><span class="n">s5</span><span class="p">,</span><span class="w"> </span><span class="n">_bss_zero</span>
<span class="w">    </span><span class="cp"># 清除BSS段，BSS段写0</span>

<span class="w">    </span><span class="cm">/* Setup temporary trap handler */</span>
<span class="w">    </span><span class="n">lla</span><span class="w"> </span><span class="n">s4</span><span class="p">,</span><span class="w"> </span><span class="n">_start_hang</span>
<span class="w">    </span><span class="n">csrw</span><span class="w">    </span><span class="n">CSR_MTVEC</span><span class="p">,</span><span class="w"> </span><span class="n">s4</span>
<span class="w">    </span><span class="cp"># 设置临时的trap handle，里面直接进入WFI</span>

<span class="w">    </span><span class="cm">/* Setup temporary stack */</span>
<span class="w">    </span><span class="n">lla</span><span class="w"> </span><span class="n">s4</span><span class="p">,</span><span class="w"> </span><span class="n">_fw_end</span>
<span class="w">    </span><span class="n">li</span><span class="w">  </span><span class="n">s5</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">SBI_SCRATCH_SIZE</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="w">    </span><span class="n">add</span><span class="w"> </span><span class="n">sp</span><span class="p">,</span><span class="w"> </span><span class="n">s4</span><span class="p">,</span><span class="w"> </span><span class="n">s5</span>
<span class="w">    </span><span class="cp"># 设置临时栈</span>

<span class="w">    </span><span class="cm">/* Allow main firmware to save info */</span>
<span class="w">    </span><span class="n">MOV_5R</span><span class="w">  </span><span class="n">s0</span><span class="p">,</span><span class="w"> </span><span class="n">a0</span><span class="p">,</span><span class="w"> </span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="n">a1</span><span class="p">,</span><span class="w"> </span><span class="n">s2</span><span class="p">,</span><span class="w"> </span><span class="n">a2</span><span class="p">,</span><span class="w"> </span><span class="n">s3</span><span class="p">,</span><span class="w"> </span><span class="n">a3</span><span class="p">,</span><span class="w"> </span><span class="n">s4</span><span class="p">,</span><span class="w"> </span><span class="n">a4</span>
<span class="w">    </span><span class="n">call</span><span class="w">    </span><span class="n">fw_save_info</span>
<span class="w">    </span><span class="n">MOV_5R</span><span class="w">  </span><span class="n">a0</span><span class="p">,</span><span class="w"> </span><span class="n">s0</span><span class="p">,</span><span class="w"> </span><span class="n">a1</span><span class="p">,</span><span class="w"> </span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="n">a2</span><span class="p">,</span><span class="w"> </span><span class="n">s2</span><span class="p">,</span><span class="w"> </span><span class="n">a3</span><span class="p">,</span><span class="w"> </span><span class="n">s3</span><span class="p">,</span><span class="w"> </span><span class="n">a4</span><span class="p">,</span><span class="w"> </span><span class="n">s4</span>
</code></pre></div>
<h2 id="_4">初始化平台</h2>
<div class="codehilite"><pre><span></span><code><span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Initialize platform</span>
<span class="cm">     * Note: The a0 to a4 registers passed to the</span>
<span class="cm">     * firmware are parameters to this function.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="n">MOV_5R</span><span class="w">  </span><span class="n">s0</span><span class="p">,</span><span class="w"> </span><span class="n">a0</span><span class="p">,</span><span class="w"> </span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="n">a1</span><span class="p">,</span><span class="w"> </span><span class="n">s2</span><span class="p">,</span><span class="w"> </span><span class="n">a2</span><span class="p">,</span><span class="w"> </span><span class="n">s3</span><span class="p">,</span><span class="w"> </span><span class="n">a3</span><span class="p">,</span><span class="w"> </span><span class="n">s4</span><span class="p">,</span><span class="w"> </span><span class="n">a4</span>
<span class="w">    </span><span class="n">call</span><span class="w">    </span><span class="n">fw_platform_init</span>
<span class="w">    </span><span class="n">add</span><span class="w"> </span><span class="n">t0</span><span class="p">,</span><span class="w"> </span><span class="n">a0</span><span class="p">,</span><span class="w"> </span><span class="n">zero</span>
<span class="w">    </span><span class="n">MOV_5R</span><span class="w">  </span><span class="n">a0</span><span class="p">,</span><span class="w"> </span><span class="n">s0</span><span class="p">,</span><span class="w"> </span><span class="n">a1</span><span class="p">,</span><span class="w"> </span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="n">a2</span><span class="p">,</span><span class="w"> </span><span class="n">s2</span><span class="p">,</span><span class="w"> </span><span class="n">a3</span><span class="p">,</span><span class="w"> </span><span class="n">s3</span><span class="p">,</span><span class="w"> </span><span class="n">a4</span><span class="p">,</span><span class="w"> </span><span class="n">s4</span>
<span class="w">    </span><span class="n">add</span><span class="w"> </span><span class="n">a1</span><span class="p">,</span><span class="w"> </span><span class="n">t0</span><span class="p">,</span><span class="w"> </span><span class="n">zero</span>
</code></pre></div>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">sbi_platform</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/**</span>
<span class="cm">     * OpenSBI version this sbi_platform is based on.</span>
<span class="cm">     * It's a 32-bit value where upper 16-bits are major number</span>
<span class="cm">     * and lower 16-bits are minor number</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="n">u32</span><span class="w"> </span><span class="n">opensbi_version</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/**</span>
<span class="cm">     * OpenSBI platform version released by vendor.</span>
<span class="cm">     * It's a 32-bit value where upper 16-bits are major number</span>
<span class="cm">     * and lower 16-bits are minor number</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="n">u32</span><span class="w"> </span><span class="n">platform_version</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/** Name of the platform */</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">name</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
<span class="w">    </span><span class="cm">/** Supported features */</span>
<span class="w">    </span><span class="n">u64</span><span class="w"> </span><span class="n">features</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/** Total number of HARTs */</span>
<span class="w">    </span><span class="n">u32</span><span class="w"> </span><span class="n">hart_count</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/** Per-HART stack size for exception/interrupt handling */</span>
<span class="w">    </span><span class="n">u32</span><span class="w"> </span><span class="n">hart_stack_size</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/** Pointer to sbi platform operations */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">platform_ops_addr</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/** Pointer to system firmware specific context */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">firmware_context</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/**</span>
<span class="cm">     * HART index to HART id table</span>
<span class="cm">     *</span>
<span class="cm">     * For used HART index &lt;abc&gt;:</span>
<span class="cm">     *     hart_index2id[&lt;abc&gt;] = some HART id</span>
<span class="cm">     * For unused HART index &lt;abc&gt;:</span>
<span class="cm">     *     hart_index2id[&lt;abc&gt;] = -1U</span>
<span class="cm">     *</span>
<span class="cm">     * If hart_index2id == NULL then we assume identity mapping</span>
<span class="cm">     *     hart_index2id[&lt;abc&gt;] = &lt;abc&gt;</span>
<span class="cm">     *</span>
<span class="cm">     * We have only two restrictions:</span>
<span class="cm">     * 1. HART index &lt; sbi_platform hart_count</span>
<span class="cm">     * 2. HART id &lt; SBI_HARTMASK_MAX_BITS</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">u32</span><span class="w"> </span><span class="o">*</span><span class="n">hart_index2id</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">sbi_platform</span><span class="w"> </span><span class="n">platform</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">.</span><span class="n">opensbi_version</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">OPENSBI_VERSION</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">platform_version</span><span class="w">   </span><span class="o">=</span>
<span class="w">        </span><span class="n">SBI_PLATFORM_VERSION</span><span class="p">(</span><span class="n">CONFIG_PLATFORM_GENERIC_MAJOR_VER</span><span class="p">,</span>
<span class="w">                     </span><span class="n">CONFIG_PLATFORM_GENERIC_MINOR_VER</span><span class="p">),</span>
<span class="w">    </span><span class="p">.</span><span class="n">name</span><span class="w">           </span><span class="o">=</span><span class="w"> </span><span class="n">CONFIG_PLATFORM_GENERIC_NAME</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">features</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="n">SBI_PLATFORM_DEFAULT_FEATURES</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">hart_count</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">SBI_HARTMASK_MAX_BITS</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">hart_index2id</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">generic_hart_index2id</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">hart_stack_size</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">SBI_PLATFORM_DEFAULT_HART_STACK_SIZE</span><span class="p">,</span>
<span class="w">    </span><span class="p">.</span><span class="n">platform_ops_addr</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">)</span><span class="o">&amp;</span><span class="n">platform_ops</span>
<span class="p">};</span>
</code></pre></div>
<h2 id="sbi_scratch">初始化sbi_scratch</h2>
<div class="codehilite"><pre><span></span><code><span class="cm">/** Representation of per-HART scratch space */</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">sbi_scratch</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/** Start (or base) address of firmware linked to OpenSBI library */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">fw_start</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/** Size (in bytes) of firmware linked to OpenSBI library */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">fw_size</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/** Offset (in bytes) of the R/W section */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">fw_rw_offset</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/** Arg1 (or 'a1' register) of next booting stage for this HART */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">next_arg1</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/** Address of next booting stage for this HART */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">next_addr</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/** Privilege mode of next booting stage for this HART */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">next_mode</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/** Warm boot entry point address for this HART */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">warmboot_addr</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/** Address of sbi_platform */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">platform_addr</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/** Address of HART ID to sbi_scratch conversion function */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">hartid_to_scratch</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/** Address of trap exit function */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">trap_exit</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/** Temporary storage */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">tmp0</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/** Options for OpenSBI library */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">options</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>接下来的代码就是创建一段空间，给sbi_scratch，然后将里面的值填充。</p>
<div class="codehilite"><pre><span></span><code><span class="w">    </span><span class="cm">/* Preload HART details</span>
<span class="cm">     * s7 -&gt; HART Count</span>
<span class="cm">     * s8 -&gt; HART Stack Size</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="n">lla</span><span class="w"> </span><span class="n">a4</span><span class="p">,</span><span class="w"> </span><span class="n">platform</span>
<span class="w">    </span><span class="cp"># 加载platform的地址到a4寄存器</span>
<span class="cp">#if __riscv_xlen &gt; 32</span>
<span class="w">    </span><span class="n">lwu</span><span class="w"> </span><span class="n">s7</span><span class="p">,</span><span class="w"> </span><span class="n">SBI_PLATFORM_HART_COUNT_OFFSET</span><span class="p">(</span><span class="n">a4</span><span class="p">)</span>
<span class="w">    </span><span class="n">lwu</span><span class="w"> </span><span class="n">s8</span><span class="p">,</span><span class="w"> </span><span class="n">SBI_PLATFORM_HART_STACK_SIZE_OFFSET</span><span class="p">(</span><span class="n">a4</span><span class="p">)</span>
<span class="cp">#else</span>
<span class="w">    </span><span class="n">lw</span><span class="w">  </span><span class="n">s7</span><span class="p">,</span><span class="w"> </span><span class="n">SBI_PLATFORM_HART_COUNT_OFFSET</span><span class="p">(</span><span class="n">a4</span><span class="p">)</span>
<span class="w">    </span><span class="cp"># 基于a4地址偏移80字节，即指向platform-&gt;hart_count:1？为啥不是128？</span>
<span class="w">    </span><span class="n">lw</span><span class="w">  </span><span class="n">s8</span><span class="p">,</span><span class="w"> </span><span class="n">SBI_PLATFORM_HART_STACK_SIZE_OFFSET</span><span class="p">(</span><span class="n">a4</span><span class="p">)</span>
<span class="w">    </span><span class="cp"># 基于a4地址偏移84字节，即指向platform-&gt;hart_stack_size:8192</span>
<span class="cp">#endif</span>
<span class="w">    </span><span class="cm">/* Setup scratch space for all the HARTs*/</span>
<span class="w">    </span><span class="n">lla</span><span class="w"> </span><span class="n">tp</span><span class="p">,</span><span class="w"> </span><span class="n">_fw_end</span>
<span class="w">    </span><span class="cp"># 加载_fw_end: 0x80038000</span>
<span class="w">    </span><span class="n">mul</span><span class="w"> </span><span class="n">a5</span><span class="p">,</span><span class="w"> </span><span class="n">s7</span><span class="p">,</span><span class="w"> </span><span class="n">s8</span>
<span class="w">    </span><span class="cp"># a5 = s7 *s8 = 1 * 0x2000 = 0x2000</span>
<span class="w">    </span><span class="n">add</span><span class="w"> </span><span class="n">tp</span><span class="p">,</span><span class="w"> </span><span class="n">tp</span><span class="p">,</span><span class="w"> </span><span class="n">a5</span>
<span class="w">    </span><span class="cp"># tp = tp +a5 = 0x80038000 + 0x2000 = 0x8003a000</span>
<span class="w">    </span><span class="cm">/* Keep a copy of tp */</span>
<span class="w">    </span><span class="n">add</span><span class="w"> </span><span class="n">t3</span><span class="p">,</span><span class="w"> </span><span class="n">tp</span><span class="p">,</span><span class="w"> </span><span class="n">zero</span>
<span class="w">    </span><span class="cp"># t3 = tp = 0x8003a000</span>
<span class="w">    </span><span class="cm">/* Counter */</span>
<span class="w">    </span><span class="n">li</span><span class="w">  </span><span class="n">t2</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="cm">/* hartid 0 is mandated by ISA */</span>
<span class="w">    </span><span class="n">li</span><span class="w">  </span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span>
<span class="w">    </span><span class="cp"># tp 是 RISC-V 中的一个特殊寄存器，用于指向临时工作区域（scratch space）。</span>
<span class="w">    </span><span class="cp"># 将 _fw_end 地址加载进 tp, 在用 s7,s8 计算出 scratch space, 再加上 tp,</span>
<span class="w">    </span><span class="cp"># 这样就相当于分配了一段hart的暂存空间。</span>
<span class="nl">_scratch_init</span><span class="p">:</span>
<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * The following registers hold values that are computed before</span>
<span class="cm">     * entering this block, and should remain unchanged.</span>
<span class="cm">     *</span>
<span class="cm">     * t3 -&gt; the firmware end address</span>
<span class="cm">     * s7 -&gt; HART count</span>
<span class="cm">     * s8 -&gt; HART stack size</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="n">add</span><span class="w"> </span><span class="n">tp</span><span class="p">,</span><span class="w"> </span><span class="n">t3</span><span class="p">,</span><span class="w"> </span><span class="n">zero</span>
<span class="w">    </span><span class="cp"># tp = t3 = 0x8003a000</span>
<span class="w">    </span><span class="n">mul</span><span class="w"> </span><span class="n">a5</span><span class="p">,</span><span class="w"> </span><span class="n">s8</span><span class="p">,</span><span class="w"> </span><span class="n">t1</span>
<span class="w">    </span><span class="cp"># a5 = s8 *s1 = 0</span>
<span class="w">    </span><span class="n">sub</span><span class="w"> </span><span class="n">tp</span><span class="p">,</span><span class="w"> </span><span class="n">tp</span><span class="p">,</span><span class="w"> </span><span class="n">a5</span>
<span class="w">    </span><span class="cp"># tp = tp - a5 = 0x8003a000</span>
<span class="w">    </span><span class="n">li</span><span class="w">  </span><span class="n">a5</span><span class="p">,</span><span class="w"> </span><span class="n">SBI_SCRATCH_SIZE</span>
<span class="w">    </span><span class="cp"># 加载SBI_SRATCH_SIZE空间到a5，这里是0x1000</span>
<span class="w">    </span><span class="n">sub</span><span class="w"> </span><span class="n">tp</span><span class="p">,</span><span class="w"> </span><span class="n">tp</span><span class="p">,</span><span class="w"> </span><span class="n">a5</span>
<span class="w">    </span><span class="cp"># tp = tp - a5 = 0x80039000</span>

<span class="w">    </span><span class="cm">/* Initialize scratch space */</span>
<span class="w">    </span><span class="cm">/* Store fw_start and fw_size in scratch space */</span>
<span class="w">    </span><span class="n">lla</span><span class="w"> </span><span class="n">a4</span><span class="p">,</span><span class="w"> </span><span class="n">_fw_start</span>
<span class="w">    </span><span class="n">sub</span><span class="w"> </span><span class="n">a5</span><span class="p">,</span><span class="w"> </span><span class="n">t3</span><span class="p">,</span><span class="w"> </span><span class="n">a4</span>
<span class="w">    </span><span class="n">REG_S</span><span class="w">   </span><span class="n">a4</span><span class="p">,</span><span class="w"> </span><span class="n">SBI_SCRATCH_FW_START_OFFSET</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span>
<span class="w">    </span><span class="n">REG_S</span><span class="w">   </span><span class="n">a5</span><span class="p">,</span><span class="w"> </span><span class="n">SBI_SCRATCH_FW_SIZE_OFFSET</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span>
<span class="w">    </span><span class="cp"># 将fw_start和fw_size写到scratch空间</span>

<span class="w">    </span><span class="cm">/* Store R/W section's offset in scratch space */</span>
<span class="w">    </span><span class="n">lla</span><span class="w"> </span><span class="n">a4</span><span class="p">,</span><span class="w"> </span><span class="n">__fw_rw_offset</span>
<span class="w">    </span><span class="n">REG_L</span><span class="w">   </span><span class="n">a5</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">(</span><span class="n">a4</span><span class="p">)</span>
<span class="w">    </span><span class="n">REG_S</span><span class="w">   </span><span class="n">a5</span><span class="p">,</span><span class="w"> </span><span class="n">SBI_SCRATCH_FW_RW_OFFSET</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span>
<span class="w">    </span><span class="cp"># 将__fw_rw_offset= _fw_rw_start - _fw_start，写到scratch空间。</span>
<span class="w">    </span><span class="cp"># 即data段的偏移位置。</span>

<span class="w">    </span><span class="cm">/* Store next arg1 in scratch space */</span>
<span class="w">    </span><span class="n">MOV_3R</span><span class="w">  </span><span class="n">s0</span><span class="p">,</span><span class="w"> </span><span class="n">a0</span><span class="p">,</span><span class="w"> </span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="n">a1</span><span class="p">,</span><span class="w"> </span><span class="n">s2</span><span class="p">,</span><span class="w"> </span><span class="n">a2</span>
<span class="w">    </span><span class="n">call</span><span class="w">    </span><span class="n">fw_next_arg1</span>
<span class="w">    </span><span class="n">REG_S</span><span class="w">   </span><span class="n">a0</span><span class="p">,</span><span class="w"> </span><span class="n">SBI_SCRATCH_NEXT_ARG1_OFFSET</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span>
<span class="w">    </span><span class="n">MOV_3R</span><span class="w">  </span><span class="n">a0</span><span class="p">,</span><span class="w"> </span><span class="n">s0</span><span class="p">,</span><span class="w"> </span><span class="n">a1</span><span class="p">,</span><span class="w"> </span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="n">a2</span><span class="p">,</span><span class="w"> </span><span class="n">s2</span>
<span class="w">    </span><span class="cp"># 存储下一阶段启动的传递的第一个参数，这里是FW_JUMP_FDT_ADDR</span>
<span class="w">    </span><span class="cp"># 在platform/generic/objects.mk中配置，= ($(FW_TEXT_START) + 0x2200000))</span>
<span class="w">    </span><span class="cp"># FW_JUMP_FDT_ADDR = 0x82200000</span>
<span class="w">    </span><span class="cm">/* Store next address in scratch space */</span>
<span class="w">    </span><span class="n">MOV_3R</span><span class="w">  </span><span class="n">s0</span><span class="p">,</span><span class="w"> </span><span class="n">a0</span><span class="p">,</span><span class="w"> </span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="n">a1</span><span class="p">,</span><span class="w"> </span><span class="n">s2</span><span class="p">,</span><span class="w"> </span><span class="n">a2</span>
<span class="w">    </span><span class="n">call</span><span class="w">    </span><span class="n">fw_next_addr</span>
<span class="w">    </span><span class="n">REG_S</span><span class="w">   </span><span class="n">a0</span><span class="p">,</span><span class="w"> </span><span class="n">SBI_SCRATCH_NEXT_ADDR_OFFSET</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span>
<span class="w">    </span><span class="n">MOV_3R</span><span class="w">  </span><span class="n">a0</span><span class="p">,</span><span class="w"> </span><span class="n">s0</span><span class="p">,</span><span class="w"> </span><span class="n">a1</span><span class="p">,</span><span class="w"> </span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="n">a2</span><span class="p">,</span><span class="w"> </span><span class="n">s2</span>
<span class="w">    </span><span class="cp"># 存储下一阶段启动地址，即opensbi运行阶段要跳转的地址</span>
<span class="w">    </span><span class="cp"># 跳转的地址为FW_JUMP_ADDR，object.mk中设置</span>
<span class="w">    </span><span class="cp"># = ($(FW_TEXT_START) + 0x200000))</span>
<span class="w">    </span><span class="cp"># 所以FW_JUMP_ADDR = 0x80200000</span>
<span class="w">    </span><span class="cm">/* Store next mode in scratch space */</span>
<span class="w">    </span><span class="n">MOV_3R</span><span class="w">  </span><span class="n">s0</span><span class="p">,</span><span class="w"> </span><span class="n">a0</span><span class="p">,</span><span class="w"> </span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="n">a1</span><span class="p">,</span><span class="w"> </span><span class="n">s2</span><span class="p">,</span><span class="w"> </span><span class="n">a2</span>
<span class="w">    </span><span class="n">call</span><span class="w">    </span><span class="n">fw_next_mode</span>
<span class="w">    </span><span class="n">REG_S</span><span class="w">   </span><span class="n">a0</span><span class="p">,</span><span class="w"> </span><span class="n">SBI_SCRATCH_NEXT_MODE_OFFSET</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span>
<span class="w">    </span><span class="n">MOV_3R</span><span class="w">  </span><span class="n">a0</span><span class="p">,</span><span class="w"> </span><span class="n">s0</span><span class="p">,</span><span class="w"> </span><span class="n">a1</span><span class="p">,</span><span class="w"> </span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="n">a2</span><span class="p">,</span><span class="w"> </span><span class="n">s2</span>
<span class="w">    </span><span class="cp"># 将下一阶段启动的模式存储next_mode，这里是S模式：1</span>

<span class="w">    </span><span class="cm">/* Store warm_boot address in scratch space */</span>
<span class="w">    </span><span class="n">lla</span><span class="w"> </span><span class="n">a4</span><span class="p">,</span><span class="w"> </span><span class="n">_start_warm</span>
<span class="w">    </span><span class="n">REG_S</span><span class="w">   </span><span class="n">a4</span><span class="p">,</span><span class="w"> </span><span class="n">SBI_SCRATCH_WARMBOOT_ADDR_OFFSET</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span>
<span class="w">    </span><span class="cp"># 存储warm_boot启动地址：0x80000354</span>
<span class="w">    </span><span class="cp"># 即：firmware/fw_base.S::426行</span>

<span class="w">    </span><span class="cm">/* Store platform address in scratch space */</span>
<span class="w">    </span><span class="n">lla</span><span class="w"> </span><span class="n">a4</span><span class="p">,</span><span class="w"> </span><span class="n">platform</span>
<span class="w">    </span><span class="n">REG_S</span><span class="w">   </span><span class="n">a4</span><span class="p">,</span><span class="w"> </span><span class="n">SBI_SCRATCH_PLATFORM_ADDR_OFFSET</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span>
<span class="w">    </span><span class="cp"># 存储platform的地址</span>

<span class="w">    </span><span class="cm">/* Store hartid-to-scratch function address in scratch space */</span>
<span class="w">    </span><span class="n">lla</span><span class="w"> </span><span class="n">a4</span><span class="p">,</span><span class="w"> </span><span class="n">_hartid_to_scratch</span>
<span class="w">    </span><span class="n">REG_S</span><span class="w">   </span><span class="n">a4</span><span class="p">,</span><span class="w"> </span><span class="n">SBI_SCRATCH_HARTID_TO_SCRATCH_OFFSET</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span>
<span class="w">    </span><span class="cp"># 存储_hartid_to_scratch地址，这段是其他hard调用该函数用于分配scratch空间</span>

<span class="w">    </span><span class="cm">/* Store trap-exit function address in scratch space */</span>
<span class="w">    </span><span class="n">lla</span><span class="w"> </span><span class="n">a4</span><span class="p">,</span><span class="w"> </span><span class="n">_trap_exit</span>
<span class="w">    </span><span class="n">REG_S</span><span class="w">   </span><span class="n">a4</span><span class="p">,</span><span class="w"> </span><span class="n">SBI_SCRATCH_TRAP_EXIT_OFFSET</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span>
<span class="w">    </span><span class="cp"># 存储的是trap退出函数</span>

<span class="w">    </span><span class="cm">/* Clear tmp0 in scratch space */</span>
<span class="w">    </span><span class="n">REG_S</span><span class="w">   </span><span class="n">zero</span><span class="p">,</span><span class="w"> </span><span class="n">SBI_SCRATCH_TMP0_OFFSET</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span>
<span class="w">    </span><span class="cm">/* Store firmware options in scratch space */</span>
<span class="w">    </span><span class="n">MOV_3R</span><span class="w">  </span><span class="n">s0</span><span class="p">,</span><span class="w"> </span><span class="n">a0</span><span class="p">,</span><span class="w"> </span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="n">a1</span><span class="p">,</span><span class="w"> </span><span class="n">s2</span><span class="p">,</span><span class="w"> </span><span class="n">a2</span>
<span class="cp">#ifdef FW_OPTIONS</span>
<span class="w">    </span><span class="n">li</span><span class="w">  </span><span class="n">a0</span><span class="p">,</span><span class="w"> </span><span class="n">FW_OPTIONS</span>
<span class="cp">#else</span>
<span class="w">    </span><span class="n">call</span><span class="w">    </span><span class="n">fw_options</span>
<span class="cp">#endif</span>
<span class="w">    </span><span class="n">REG_S</span><span class="w">   </span><span class="n">a0</span><span class="p">,</span><span class="w"> </span><span class="n">SBI_SCRATCH_OPTIONS_OFFSET</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span>
<span class="w">    </span><span class="n">MOV_3R</span><span class="w">  </span><span class="n">a0</span><span class="p">,</span><span class="w"> </span><span class="n">s0</span><span class="p">,</span><span class="w"> </span><span class="n">a1</span><span class="p">,</span><span class="w"> </span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="n">a2</span><span class="p">,</span><span class="w"> </span><span class="n">s2</span>
<span class="w">    </span><span class="cm">/* Move to next scratch space */</span>
<span class="w">    </span><span class="n">add</span><span class="w"> </span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span>
<span class="w">    </span><span class="n">blt</span><span class="w"> </span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="n">s7</span><span class="p">,</span><span class="w"> </span><span class="n">_scratch_init</span>
<span class="w">    </span><span class="cp"># 完成一个hart的scrach初始化，接着为下一个hart分配一个scratch并初始化。</span>
</code></pre></div>
<h2 id="fdt">FDT重定位</h2>
<div class="codehilite"><pre><span></span><code><span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Relocate Flatened Device Tree (FDT)</span>
<span class="cm">     * source FDT address = previous arg1</span>
<span class="cm">     * destination FDT address = next arg1</span>
<span class="cm">     *</span>
<span class="cm">     * Note: We will preserve a0 and a1 passed by</span>
<span class="cm">     * previous booting stage.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="n">beqz</span><span class="w">    </span><span class="n">a1</span><span class="p">,</span><span class="w"> </span><span class="n">_fdt_reloc_done</span>
<span class="w">    </span><span class="cm">/* Mask values in a4 */</span>
<span class="w">    </span><span class="n">li</span><span class="w">  </span><span class="n">a4</span><span class="p">,</span><span class="w"> </span><span class="mh">0xff</span>
<span class="w">    </span><span class="cm">/* t1 = destination FDT start address */</span>
<span class="w">    </span><span class="n">MOV_3R</span><span class="w">  </span><span class="n">s0</span><span class="p">,</span><span class="w"> </span><span class="n">a0</span><span class="p">,</span><span class="w"> </span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="n">a1</span><span class="p">,</span><span class="w"> </span><span class="n">s2</span><span class="p">,</span><span class="w"> </span><span class="n">a2</span>
<span class="w">    </span><span class="n">call</span><span class="w">    </span><span class="n">fw_next_arg1</span>
<span class="w">    </span><span class="n">add</span><span class="w"> </span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="n">a0</span><span class="p">,</span><span class="w"> </span><span class="n">zero</span>
<span class="w">    </span><span class="n">MOV_3R</span><span class="w">  </span><span class="n">a0</span><span class="p">,</span><span class="w"> </span><span class="n">s0</span><span class="p">,</span><span class="w"> </span><span class="n">a1</span><span class="p">,</span><span class="w"> </span><span class="n">s1</span><span class="p">,</span><span class="w"> </span><span class="n">a2</span><span class="p">,</span><span class="w"> </span><span class="n">s2</span>
<span class="w">    </span><span class="n">beqz</span><span class="w">    </span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="n">_fdt_reloc_done</span>
<span class="w">    </span><span class="n">beq</span><span class="w"> </span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="n">a1</span><span class="p">,</span><span class="w"> </span><span class="n">_fdt_reloc_done</span>
<span class="w">    </span><span class="cm">/* t0 = source FDT start address */</span>
<span class="w">    </span><span class="n">add</span><span class="w"> </span><span class="n">t0</span><span class="p">,</span><span class="w"> </span><span class="n">a1</span><span class="p">,</span><span class="w"> </span><span class="n">zero</span>
<span class="w">    </span><span class="cm">/* t2 = source FDT size in big-endian */</span>
<span class="cp">#if __riscv_xlen == 64</span>
<span class="w">    </span><span class="n">lwu</span><span class="w"> </span><span class="n">t2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">(</span><span class="n">t0</span><span class="p">)</span>
<span class="cp">#else</span>
<span class="w">    </span><span class="n">lw</span><span class="w">  </span><span class="n">t2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">(</span><span class="n">t0</span><span class="p">)</span>
<span class="cp">#endif</span>
<span class="w">    </span><span class="cm">/* t3 = bit[15:8] of FDT size */</span>
<span class="w">    </span><span class="n">add</span><span class="w"> </span><span class="n">t3</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span><span class="p">,</span><span class="w"> </span><span class="n">zero</span>
<span class="w">    </span><span class="n">srli</span><span class="w">    </span><span class="n">t3</span><span class="p">,</span><span class="w"> </span><span class="n">t3</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span>
<span class="w">    </span><span class="n">and</span><span class="w"> </span><span class="n">t3</span><span class="p">,</span><span class="w"> </span><span class="n">t3</span><span class="p">,</span><span class="w"> </span><span class="n">a4</span>
<span class="w">    </span><span class="n">slli</span><span class="w">    </span><span class="n">t3</span><span class="p">,</span><span class="w"> </span><span class="n">t3</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span>
<span class="w">    </span><span class="cm">/* t4 = bit[23:16] of FDT size */</span>
<span class="w">    </span><span class="n">add</span><span class="w"> </span><span class="n">t4</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span><span class="p">,</span><span class="w"> </span><span class="n">zero</span>
<span class="w">    </span><span class="n">srli</span><span class="w">    </span><span class="n">t4</span><span class="p">,</span><span class="w"> </span><span class="n">t4</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span>
<span class="w">    </span><span class="n">and</span><span class="w"> </span><span class="n">t4</span><span class="p">,</span><span class="w"> </span><span class="n">t4</span><span class="p">,</span><span class="w"> </span><span class="n">a4</span>
<span class="w">    </span><span class="n">slli</span><span class="w">    </span><span class="n">t4</span><span class="p">,</span><span class="w"> </span><span class="n">t4</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span>
<span class="w">    </span><span class="cm">/* t5 = bit[31:24] of FDT size */</span>
<span class="w">    </span><span class="n">add</span><span class="w"> </span><span class="n">t5</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span><span class="p">,</span><span class="w"> </span><span class="n">zero</span>
<span class="w">    </span><span class="n">and</span><span class="w"> </span><span class="n">t5</span><span class="p">,</span><span class="w"> </span><span class="n">t5</span><span class="p">,</span><span class="w"> </span><span class="n">a4</span>
<span class="w">    </span><span class="n">slli</span><span class="w">    </span><span class="n">t5</span><span class="p">,</span><span class="w"> </span><span class="n">t5</span><span class="p">,</span><span class="w"> </span><span class="mi">24</span>
<span class="w">    </span><span class="cm">/* t2 = bit[7:0] of FDT size */</span>
<span class="w">    </span><span class="n">srli</span><span class="w">    </span><span class="n">t2</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span><span class="p">,</span><span class="w"> </span><span class="mi">24</span>
<span class="w">    </span><span class="n">and</span><span class="w"> </span><span class="n">t2</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span><span class="p">,</span><span class="w"> </span><span class="n">a4</span>
<span class="w">    </span><span class="cm">/* t2 = FDT size in little-endian */</span>
<span class="w">    </span><span class="n">or</span><span class="w">  </span><span class="n">t2</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span><span class="p">,</span><span class="w"> </span><span class="n">t3</span>
<span class="w">    </span><span class="n">or</span><span class="w">  </span><span class="n">t2</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span><span class="p">,</span><span class="w"> </span><span class="n">t4</span>
<span class="w">    </span><span class="n">or</span><span class="w">  </span><span class="n">t2</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span><span class="p">,</span><span class="w"> </span><span class="n">t5</span>
<span class="w">    </span><span class="cm">/* t2 = destination FDT end address */</span>
<span class="w">    </span><span class="n">add</span><span class="w"> </span><span class="n">t2</span><span class="p">,</span><span class="w"> </span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span>
<span class="w">    </span><span class="cm">/* FDT copy loop */</span>
<span class="w">    </span><span class="n">ble</span><span class="w"> </span><span class="n">t2</span><span class="p">,</span><span class="w"> </span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="n">_fdt_reloc_done</span>
<span class="nl">_fdt_reloc_again</span><span class="p">:</span>
<span class="w">    </span><span class="n">REG_L</span><span class="w">   </span><span class="n">t3</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">(</span><span class="n">t0</span><span class="p">)</span>
<span class="w">    </span><span class="n">REG_S</span><span class="w">   </span><span class="n">t3</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span>
<span class="w">    </span><span class="n">add</span><span class="w"> </span><span class="n">t0</span><span class="p">,</span><span class="w"> </span><span class="n">t0</span><span class="p">,</span><span class="w"> </span><span class="n">__SIZEOF_POINTER__</span>
<span class="w">    </span><span class="n">add</span><span class="w"> </span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="n">__SIZEOF_POINTER__</span>
<span class="w">    </span><span class="n">blt</span><span class="w"> </span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="n">t2</span><span class="p">,</span><span class="w"> </span><span class="n">_fdt_reloc_again</span>
</code></pre></div>
<h2 id="boot-hard">boot hard启动完成</h2>
<div class="codehilite"><pre><span></span><code><span class="nl">_fdt_reloc_done</span><span class="p">:</span>

<span class="w">    </span><span class="cm">/* mark boot hart done */</span>
<span class="w">    </span><span class="n">li</span><span class="w">  </span><span class="n">t0</span><span class="p">,</span><span class="w"> </span><span class="n">BOOT_STATUS_BOOT_HART_DONE</span>
<span class="w">    </span><span class="n">lla</span><span class="w"> </span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="n">_boot_status</span>
<span class="w">    </span><span class="n">REG_S</span><span class="w">   </span><span class="n">t0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span>
<span class="w">    </span><span class="n">fence</span><span class="w">   </span><span class="n">rw</span><span class="p">,</span><span class="w"> </span><span class="n">rw</span>
<span class="w">    </span><span class="n">j</span><span class="w">   </span><span class="n">_start_warm</span>
<span class="w">    </span><span class="cp"># boot hart启动完成，写入一个标志位，以便通知其他hart，跳转到热启动</span>
</code></pre></div>
<h2 id="boot-hart">非boot hart等待运行</h2>
<div class="codehilite"><pre><span></span><code><span class="w">    </span><span class="cm">/* waiting for boot hart to be done (_boot_status == 2) */</span>
<span class="nl">_wait_for_boot_hart</span><span class="p">:</span>
<span class="w">    </span><span class="n">li</span><span class="w">  </span><span class="n">t0</span><span class="p">,</span><span class="w"> </span><span class="n">BOOT_STATUS_BOOT_HART_DONE</span>
<span class="w">    </span><span class="n">lla</span><span class="w"> </span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="n">_boot_status</span>
<span class="w">    </span><span class="n">REG_L</span><span class="w">   </span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span>
<span class="w">    </span><span class="cm">/* Reduce the bus traffic so that boot hart may proceed faster */</span>
<span class="w">    </span><span class="n">nop</span>
<span class="w">    </span><span class="n">nop</span>
<span class="w">    </span><span class="n">nop</span>
<span class="w">    </span><span class="n">bne</span><span class="w"> </span><span class="n">t0</span><span class="p">,</span><span class="w"> </span><span class="n">t1</span><span class="p">,</span><span class="w"> </span><span class="n">_wait_for_boot_hart</span>
<span class="w">    </span><span class="cp"># 读取_boot_status的标志，判断boot hart是否运行初始化完，如果初始化</span>
<span class="w">    </span><span class="cp"># 即可进入_start_warm，否则需要一直等待。</span>
</code></pre></div>
<h2 id="hart_1">hart 热启动</h2>
<div class="codehilite"><pre><span></span><code><span class="nl">_start_warm</span><span class="p">:</span>
<span class="w">    </span><span class="cm">/* Reset all registers for non-boot HARTs */</span>
<span class="w">    </span><span class="n">li</span><span class="w">  </span><span class="n">ra</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span>
<span class="w">    </span><span class="n">call</span><span class="w">    </span><span class="n">_reset_regs</span>
<span class="w">    </span><span class="cp"># 对于non-boot HARTS复位寄存器</span>

<span class="w">    </span><span class="cm">/* Disable all interrupts */</span>
<span class="w">    </span><span class="n">csrw</span><span class="w">    </span><span class="n">CSR_MIE</span><span class="p">,</span><span class="w"> </span><span class="n">zero</span>
<span class="w">    </span><span class="cp"># 关闭所有的中断</span>

<span class="w">    </span><span class="cm">/* Find HART count and HART stack size */</span>
<span class="w">    </span><span class="n">lla</span><span class="w"> </span><span class="n">a4</span><span class="p">,</span><span class="w"> </span><span class="n">platform</span>
<span class="cp">#if __riscv_xlen == 64</span>
<span class="w">    </span><span class="n">lwu</span><span class="w"> </span><span class="n">s7</span><span class="p">,</span><span class="w"> </span><span class="n">SBI_PLATFORM_HART_COUNT_OFFSET</span><span class="p">(</span><span class="n">a4</span><span class="p">)</span>
<span class="w">    </span><span class="n">lwu</span><span class="w"> </span><span class="n">s8</span><span class="p">,</span><span class="w"> </span><span class="n">SBI_PLATFORM_HART_STACK_SIZE_OFFSET</span><span class="p">(</span><span class="n">a4</span><span class="p">)</span>
<span class="cp">#else</span>
<span class="w">    </span><span class="n">lw</span><span class="w">  </span><span class="n">s7</span><span class="p">,</span><span class="w"> </span><span class="n">SBI_PLATFORM_HART_COUNT_OFFSET</span><span class="p">(</span><span class="n">a4</span><span class="p">)</span>
<span class="w">    </span><span class="n">lw</span><span class="w">  </span><span class="n">s8</span><span class="p">,</span><span class="w"> </span><span class="n">SBI_PLATFORM_HART_STACK_SIZE_OFFSET</span><span class="p">(</span><span class="n">a4</span><span class="p">)</span>
<span class="cp">#endif</span>
<span class="w">    </span><span class="n">REG_L</span><span class="w">   </span><span class="n">s9</span><span class="p">,</span><span class="w"> </span><span class="n">SBI_PLATFORM_HART_INDEX2ID_OFFSET</span><span class="p">(</span><span class="n">a4</span><span class="p">)</span>
<span class="w">    </span><span class="cp"># 加载platform，获取到Hart count和hart stack size</span>

<span class="w">    </span><span class="cm">/* Find HART id */</span>
<span class="w">    </span><span class="n">csrr</span><span class="w">    </span><span class="n">s6</span><span class="p">,</span><span class="w"> </span><span class="n">CSR_MHARTID</span>
<span class="w">    </span><span class="cp"># 获取当前的hart id</span>

<span class="w">    </span><span class="cm">/* Find HART index */</span>
<span class="w">    </span><span class="n">beqz</span><span class="w">    </span><span class="n">s9</span><span class="p">,</span><span class="w"> </span><span class="mf">3f</span>
<span class="w">    </span><span class="n">li</span><span class="w">  </span><span class="n">a4</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span>
<span class="mi">1</span><span class="o">:</span>
<span class="cp">#if __riscv_xlen == 64</span>
<span class="w">    </span><span class="n">lwu</span><span class="w"> </span><span class="n">a5</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">s9</span><span class="p">)</span>
<span class="cp">#else</span>
<span class="w">    </span><span class="n">lw</span><span class="w">  </span><span class="n">a5</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">s9</span><span class="p">)</span>
<span class="cp">#endif</span>
<span class="w">    </span><span class="n">beq</span><span class="w"> </span><span class="n">a5</span><span class="p">,</span><span class="w"> </span><span class="n">s6</span><span class="p">,</span><span class="w"> </span><span class="mf">2f</span>
<span class="w">    </span><span class="n">add</span><span class="w"> </span><span class="n">s9</span><span class="p">,</span><span class="w"> </span><span class="n">s9</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span>
<span class="w">    </span><span class="n">add</span><span class="w"> </span><span class="n">a4</span><span class="p">,</span><span class="w"> </span><span class="n">a4</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="n">blt</span><span class="w"> </span><span class="n">a4</span><span class="p">,</span><span class="w"> </span><span class="n">s7</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="n">b</span>
<span class="w">    </span><span class="n">li</span><span class="w">  </span><span class="n">a4</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span>
<span class="mi">2</span><span class="o">:</span><span class="w">  </span><span class="n">add</span><span class="w"> </span><span class="n">s6</span><span class="p">,</span><span class="w"> </span><span class="n">a4</span><span class="p">,</span><span class="w"> </span><span class="n">zero</span>
<span class="mi">3</span><span class="o">:</span><span class="w">  </span><span class="n">bge</span><span class="w"> </span><span class="n">s6</span><span class="p">,</span><span class="w"> </span><span class="n">s7</span><span class="p">,</span><span class="w"> </span><span class="n">_start_hang</span>
<span class="w">    </span><span class="cm">/* Find the scratch space based on HART index */</span>
<span class="w">    </span><span class="n">lla</span><span class="w"> </span><span class="n">tp</span><span class="p">,</span><span class="w"> </span><span class="n">_fw_end</span>
<span class="w">    </span><span class="n">mul</span><span class="w"> </span><span class="n">a5</span><span class="p">,</span><span class="w"> </span><span class="n">s7</span><span class="p">,</span><span class="w"> </span><span class="n">s8</span>
<span class="w">    </span><span class="n">add</span><span class="w"> </span><span class="n">tp</span><span class="p">,</span><span class="w"> </span><span class="n">tp</span><span class="p">,</span><span class="w"> </span><span class="n">a5</span>
<span class="w">    </span><span class="n">mul</span><span class="w"> </span><span class="n">a5</span><span class="p">,</span><span class="w"> </span><span class="n">s8</span><span class="p">,</span><span class="w"> </span><span class="n">s6</span>
<span class="w">    </span><span class="n">sub</span><span class="w"> </span><span class="n">tp</span><span class="p">,</span><span class="w"> </span><span class="n">tp</span><span class="p">,</span><span class="w"> </span><span class="n">a5</span>
<span class="w">    </span><span class="n">li</span><span class="w">  </span><span class="n">a5</span><span class="p">,</span><span class="w"> </span><span class="n">SBI_SCRATCH_SIZE</span>
<span class="w">    </span><span class="n">sub</span><span class="w"> </span><span class="n">tp</span><span class="p">,</span><span class="w"> </span><span class="n">tp</span><span class="p">,</span><span class="w"> </span><span class="n">a5</span>
<span class="w">    </span><span class="cp"># 根据hart index找到对应的scratch space</span>

<span class="w">    </span><span class="cm">/* update the mscratch */</span>
<span class="w">    </span><span class="n">csrw</span><span class="w">    </span><span class="n">CSR_MSCRATCH</span><span class="p">,</span><span class="w"> </span><span class="n">tp</span>
<span class="w">    </span><span class="cp"># 将scratch地址更新到mscratch寄存器中</span>

<span class="w">    </span><span class="cm">/* Setup stack */</span>
<span class="w">    </span><span class="n">add</span><span class="w"> </span><span class="n">sp</span><span class="p">,</span><span class="w"> </span><span class="n">tp</span><span class="p">,</span><span class="w"> </span><span class="n">zero</span>
<span class="w">    </span><span class="cp"># 设置hart的栈空间</span>

<span class="w">    </span><span class="cm">/* Setup trap handler */</span>
<span class="w">    </span><span class="n">lla</span><span class="w"> </span><span class="n">a4</span><span class="p">,</span><span class="w"> </span><span class="n">_trap_handler</span>
<span class="cp">#if __riscv_xlen == 32</span>
<span class="w">    </span><span class="n">csrr</span><span class="w">    </span><span class="n">a5</span><span class="p">,</span><span class="w"> </span><span class="n">CSR_MISA</span>
<span class="w">    </span><span class="n">srli</span><span class="w">    </span><span class="n">a5</span><span class="p">,</span><span class="w"> </span><span class="n">a5</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="sc">'H'</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="sc">'A'</span><span class="p">)</span>
<span class="w">    </span><span class="n">andi</span><span class="w">    </span><span class="n">a5</span><span class="p">,</span><span class="w"> </span><span class="n">a5</span><span class="p">,</span><span class="w"> </span><span class="mh">0x1</span>
<span class="w">    </span><span class="n">beq</span><span class="w"> </span><span class="n">a5</span><span class="p">,</span><span class="w"> </span><span class="n">zero</span><span class="p">,</span><span class="w"> </span><span class="n">_skip_trap_handler_rv32_hyp</span>
<span class="w">    </span><span class="n">lla</span><span class="w"> </span><span class="n">a4</span><span class="p">,</span><span class="w"> </span><span class="n">_trap_handler_rv32_hyp</span>
<span class="nl">_skip_trap_handler_rv32_hyp</span><span class="p">:</span>
<span class="cp">#endif</span>
<span class="w">    </span><span class="n">csrw</span><span class="w">    </span><span class="n">CSR_MTVEC</span><span class="p">,</span><span class="w"> </span><span class="n">a4</span>
<span class="w">    </span><span class="cp"># 设置trap处理入口函数_trap_handler</span>
<span class="cp">#if __riscv_xlen == 32</span>
<span class="w">    </span><span class="cm">/* Override trap exit for H-extension */</span>
<span class="w">    </span><span class="n">csrr</span><span class="w">    </span><span class="n">a5</span><span class="p">,</span><span class="w"> </span><span class="n">CSR_MISA</span>
<span class="w">    </span><span class="n">srli</span><span class="w">    </span><span class="n">a5</span><span class="p">,</span><span class="w"> </span><span class="n">a5</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="sc">'H'</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="sc">'A'</span><span class="p">)</span>
<span class="w">    </span><span class="n">andi</span><span class="w">    </span><span class="n">a5</span><span class="p">,</span><span class="w"> </span><span class="n">a5</span><span class="p">,</span><span class="w"> </span><span class="mh">0x1</span>
<span class="w">    </span><span class="n">beq</span><span class="w"> </span><span class="n">a5</span><span class="p">,</span><span class="w"> </span><span class="n">zero</span><span class="p">,</span><span class="w"> </span><span class="n">_skip_trap_exit_rv32_hyp</span>
<span class="w">    </span><span class="n">lla</span><span class="w"> </span><span class="n">a4</span><span class="p">,</span><span class="w"> </span><span class="n">_trap_exit_rv32_hyp</span>
<span class="w">    </span><span class="n">csrr</span><span class="w">    </span><span class="n">a5</span><span class="p">,</span><span class="w"> </span><span class="n">CSR_MSCRATCH</span>
<span class="w">    </span><span class="n">REG_S</span><span class="w">   </span><span class="n">a4</span><span class="p">,</span><span class="w"> </span><span class="n">SBI_SCRATCH_TRAP_EXIT_OFFSET</span><span class="p">(</span><span class="n">a5</span><span class="p">)</span>
<span class="nl">_skip_trap_exit_rv32_hyp</span><span class="p">:</span>
<span class="cp">#endif</span>

<span class="w">    </span><span class="cm">/* Initialize SBI runtime */</span>
<span class="w">    </span><span class="n">csrr</span><span class="w">    </span><span class="n">a0</span><span class="p">,</span><span class="w"> </span><span class="n">CSR_MSCRATCH</span>
<span class="w">    </span><span class="n">call</span><span class="w">    </span><span class="n">sbi_init</span>
<span class="w">    </span><span class="cp"># scratch的地址作为参数，跳转到sbi_init执行。</span>
</code></pre></div>
<h2 id="_5">小结</h2>
<p><a href="https://www.laumy.tech/wp-content/uploads/2024/05/wp_editor_md_9e0252c9c3914a87a4e0af3c33349b68.jpg"><img alt="" src="assets/doc/02-risc-v/opensbi分析（一）/images/wp_editor_md_9e0252c9c3914a87a4e0af3c33349b68.jpg"/></a></p>
<p>本文参考： [泰晓科技OpenSBI分析1](https://tinylab.org/sbi-firmware-analyze-41/ \"泰晓科技OpenSBI分析1\") [泰晓科技OpenSBI分析2](https://tinylab.org/sbi-firmware-analyze-2/ \"泰晓科技OpenSBI分析2\") [泰晓科技OpenSBI分析3](https://tinylab.org/sbi-firmware-analyze-3/ \"泰晓科技OpenSBI分析3\") [泰晓科技OpenSBI分析4](https://tinylab.org/sbi-firmware-analyze-4/ \"泰晓科技OpenSBI分析4\") [passenger12234的博客 OpenSBI分析](https://blog.csdn.net/passenger12234/category_11411139.html \"passenger12234的博客 OpenSBI分析\") [OpenSBI ELF rela.dyn和.dynsym动态链接过程](https://blog.csdn.net/dai_xiangjun/article/details/123629743 \"OpenSBI ELF rela.dyn和.dynsym动态链接过程\")</p></div>
  <div class="post-nav">
    <a class="prev" href="../../opensbi分析-二.html">← opensbi分析（二）</a>
    <a class="next" href="../../qemu-opensbi-uboot-linux-busybox启动环境搭建.html">qemu+opensbi+uboot+linux+busybox启动环境搭建 →</a>
  </div>
</article>

      </section>

      <aside class="right-panel">
        
      </aside>
    </main>

    <footer class="site-footer">
      <div class="container">Copyright ©2022-2025 laumy 版权所有</div>
    </footer>

    <script src="../../assets/site.js"></script>
  </body>
  </html>

