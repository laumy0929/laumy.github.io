<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>连续内存分配器CMA - Laumy的技术栈</title>
    <link rel="stylesheet" href="../assets/style.css">
    <!-- MathJax支持LaTeX数学公式 -->
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          ignoreHtmlClass: 'tex2jax_ignore',
          processHtmlClass: 'tex2jax_process'
        }
      };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  </head>
  <body>
    <header class="site-header">
      <div class="container">
        <a class="logo" href="../">Laumy的技术栈</a>
        <div class="search">
          <input id="search-input" type="text" placeholder="输入关键词回车搜索">
        </div>
        <div class="theme-toggle" title="切换主题" id="theme-toggle">☾</div>
        <nav class="top-nav">
          <div class="nav-item"><a href="../">首页</a></div>
        </nav>
      </div>
    </header>

    <main class="container layout">
      <aside class="left-nav">
        
        <div class="card">
          <div class="card-title">文章目录</div>
          <nav id="toc"><ul><li><a href="#cma">CMA区域创建</a><ul><li><a href="#_1">设备数的方式创建</a></li></ul></li><li><a href="#_2">命令行或宏方式创建</a><ul></ul></li><li><a href="#cma_1">CMA初始化</a><ul></ul></li><li><a href="#cma_2">CMA应用</a><ul></ul></li><li><a href="#ion">ION</a><ul></ul></li></ul></nav>
        </div>
        
      </aside>

      <section class="content">
        
<article class="card post">
  <h1>连续内存分配器CMA</h1>
  <div class="meta">2023-08-19 · linux</div>
  <div class="post-content"><p>CMA,contiguous memory allocator是内存管理子系统的一个模块，其主要为了解决分配连续的物理内存。尽管有了伙伴系统、slab分配器以及相关的内存回收机制，但是对于一些驱动如camera、display等模块一下需要分配比较大的一块连续物理内存，随着系统运行久之后，碎片化严重，分配较大的连续内存会变得困难，而同时又不能直接预留一块大的连续内存只用于连续物理内存分配，因为当模块不使用这些内存时，内存就浪费掉了。因此为解决这个问题，提出了CMA机制，先预留一部分内存出来专门用于CMA内存，当驱动没有分配使用的时候，这些memory可以给伙伴系统供其他模块正常使用，当需要分配连续的大内存时，就回收回来形成物理地址连续的大块内存。</p>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/12/wp_editor_md_534a275819ad65dd5978c0d341381b29.jpg"><img alt="" src="../assets/doc/01-linux/内存管理/连续内存分配器cma/images/wp_editor_md_534a275819ad65dd5978c0d341381b29.jpg"/></a></p>
<p>上图可以看出CMA所处的位置，CMA向下是基于伙伴系统，向上是提供给DMA的封装接口，最终用户通过操作DMA buffer来分配和释放内存。CMA的区域有两种方式可以进行配置，分别是内核命令行参数配置和DTS设备树的方式配置。</p>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">cma</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w">   </span><span class="n">base_pfn</span><span class="p">;</span><span class="w">  </span><span class="n">物理地址起始页帧号</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w">   </span><span class="n">count</span><span class="p">;</span><span class="w">     </span><span class="n">区域的总页数</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w">   </span><span class="o">*</span><span class="n">bitmap</span><span class="p">;</span><span class="w">   </span><span class="n">页的分配情况0表示free</span><span class="err">，</span><span class="mi">1</span><span class="n">表示已分配</span><span class="err">。</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">order_per_bit</span><span class="p">;</span><span class="w">  </span><span class="n">每次分配</span><span class="o">/</span><span class="n">释放对应的2</span><span class="o">^</span><span class="n">order</span><span class="w"> </span><span class="n">页</span><span class="err">，</span><span class="n">与bitmap的bit对应</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">mutex</span><span class="w">    </span><span class="n">lock</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_CMA_DEBUGFS</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">hlist_head</span><span class="w"> </span><span class="n">mem_head</span><span class="p">;</span>
<span class="w">    </span><span class="n">spinlock_t</span><span class="w"> </span><span class="n">mem_head_lock</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">cma</span><span class="w"> </span><span class="n">cma_areas</span><span class="p">[</span><span class="n">MAX_CMA_AREAS</span><span class="p">];</span>
<span class="k">extern</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">cma_area_count</span><span class="p">;</span>
</code></pre></div>
<p>内核使用struct cma结构体来描述cma区域，系统中可能有多个cma区域，使用一个全局的数组来描述所有的cma区域struct cma cma_areas[MAX_CMA_AREAS];</p>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/12/wp_editor_md_9cfaf952d9167d7c2305b9492f635706.jpg"><img alt="" src="../assets/doc/01-linux/内存管理/连续内存分配器cma/images/wp_editor_md_9cfaf952d9167d7c2305b9492f635706.jpg"/></a></p>
<p>如上图，cma_areas 0号区域，物理页号从0开始，每块内存由4页物理帧组成，目前只分配了第0块。</p>
<h2 id="cma">CMA区域创建</h2>
<p>创建CMA区域有两种方式：第一种方式是通过设备树DTS的配置方式，另一种是根据命令行或宏配置方式。</p>
<h3 id="_1">设备数的方式创建</h3>
<div class="codehilite"><pre><span></span><code><span class="cm">/* global autoconfigured region for contiguous allocations */</span>
<span class="n">linux</span><span class="p">,</span><span class="n">cma</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">compatible</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"shared-dma-pool"</span><span class="p">;</span>
<span class="w">    </span><span class="n">reusable</span><span class="p">;</span>
<span class="w">    </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x4000000</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">    </span><span class="n">alignment</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x2000</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">    </span><span class="n">linux</span><span class="p">,</span><span class="n">cma</span><span class="o">-</span><span class="k">default</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>CMA的内存区域通过以上设备树信息来进行描述，对节点的解析在rmem_cma_setup函数中进行。</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="nf">rmem_cma_setup</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">reserved_mem</span><span class="w"> </span><span class="o">*</span><span class="n">rmem</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">phys_addr_t</span><span class="w"> </span><span class="n">align</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PAGE_SIZE</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">MAX_ORDER</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">pageblock_order</span><span class="p">);</span>
<span class="w">    </span><span class="n">phys_addr_t</span><span class="w"> </span><span class="n">mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">align</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rmem</span><span class="o">-&gt;</span><span class="n">fdt_node</span><span class="p">;</span>
<span class="kt">bool</span><span class="w"> </span><span class="n">default_cma</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">of_get_flat_dt_prop</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="s">"linux,cma-default"</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="err">（</span><span class="mi">1</span><span class="err">）</span><span class="n">解析linux</span><span class="p">,</span><span class="n">cma</span><span class="o">-</span><span class="n">default节点</span><span class="err">。</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">cma</span><span class="w"> </span><span class="o">*</span><span class="n">cma</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">err</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">size_cmdline</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">default_cma</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">pr_info</span><span class="p">(</span><span class="s">"Reserved memory: bypass %s node, using cmdline CMA params instead</span><span class="se">\\</span><span class="s">n"</span><span class="p">,</span>
<span class="w">            </span><span class="n">rmem</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="err">（</span><span class="mi">2</span><span class="err">）</span><span class="n">CMA对应的reserved</span><span class="w"> </span><span class="n">memory节点必须有reusable属性</span><span class="err">，</span><span class="n">不能有no</span><span class="o">-</span><span class="n">map属性</span><span class="err">。</span>
<span class="w">   </span><span class="n">reusable属性才能被伙伴系统回收使用</span><span class="err">。</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">of_get_flat_dt_prop</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="s">"reusable"</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="o">||</span>
<span class="w">        </span><span class="n">of_get_flat_dt_prop</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="s">"no-map"</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">))</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">rmem</span><span class="o">-&gt;</span><span class="n">base</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">mask</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">rmem</span><span class="o">-&gt;</span><span class="n">size</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">mask</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">pr_err</span><span class="p">(</span><span class="s">"Reserved memory: incorrect alignment of CMA region</span><span class="se">\\</span><span class="s">n"</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="err">（</span><span class="mi">3</span><span class="err">）</span><span class="n">解析出来的参数进行初始化CMA区域</span>
<span class="w">    </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cma_init_reserved_mem</span><span class="p">(</span><span class="n">rmem</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="n">rmem</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">rmem</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cma</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">pr_err</span><span class="p">(</span><span class="s">"Reserved memory: unable to setup CMA region</span><span class="se">\\</span><span class="s">n"</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">err</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cm">/* Architecture specific contiguous memory fixup. */</span>
<span class="w">    </span><span class="n">dma_contiguous_early_fixup</span><span class="p">(</span><span class="n">rmem</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="n">rmem</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">default_cma</span><span class="p">)</span>
<span class="w">        </span><span class="n">dma_contiguous_default_area</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cma</span><span class="p">;</span>

<span class="w">    </span><span class="n">rmem</span><span class="o">-&gt;</span><span class="n">ops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rmem_cma_ops</span><span class="p">;</span>
<span class="w">    </span><span class="n">rmem</span><span class="o">-&gt;</span><span class="n">priv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cma</span><span class="p">;</span>

<span class="w">    </span><span class="n">pr_info</span><span class="p">(</span><span class="s">"Reserved memory: created CMA memory pool at %pa, size %ld MiB</span><span class="se">\\</span><span class="s">n"</span><span class="p">,</span>
<span class="w">        </span><span class="o">&amp;</span><span class="n">rmem</span><span class="o">-&gt;</span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">)</span><span class="n">rmem</span><span class="o">-&gt;</span><span class="n">size</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">SZ_1M</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">RESERVEDMEM_OF_DECLARE</span><span class="p">(</span><span class="n">cma</span><span class="p">,</span><span class="w"> </span><span class="s">"shared-dma-pool"</span><span class="p">,</span><span class="w"> </span><span class="n">rmem_cma_setup</span><span class="p">);</span>
</code></pre></div>
<p>rmem_cma_setup函数主要解析设备树，获取cma区域的地址及大小，然后调用cma_init_reserved_mem函数从全局数组struct cma cma_areas[MAX_CMA_AREAS]获取一个cma进行初始化设置。</p>
<div class="codehilite"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="nf">cma_init_reserved_mem</span><span class="p">(</span><span class="n">phys_addr_t</span><span class="w"> </span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="n">phys_addr_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span>
<span class="w">                 </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">order_per_bit</span><span class="p">,</span>
<span class="w">                 </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p">,</span>
<span class="w">                 </span><span class="k">struct</span><span class="w"> </span><span class="nc">cma</span><span class="w"> </span><span class="o">**</span><span class="n">res_cma</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">cma</span><span class="w"> </span><span class="o">*</span><span class="n">cma</span><span class="p">;</span>
<span class="w">    </span><span class="n">phys_addr_t</span><span class="w"> </span><span class="n">alignment</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* Sanity checks */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cma_area_count</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">cma_areas</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">pr_err</span><span class="p">(</span><span class="s">"Not enough slots for CMA reserved regions!</span><span class="se">\\</span><span class="s">n"</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">size</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="n">memblock_is_region_reserved</span><span class="p">(</span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">))</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* ensure minimal alignment required by mm core */</span>
<span class="w">    </span><span class="n">alignment</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PAGE_SIZE</span><span class="w"> </span><span class="o">&lt;&lt;</span>
<span class="w">            </span><span class="n">max_t</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">,</span><span class="w"> </span><span class="n">MAX_ORDER</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">pageblock_order</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/* alignment should be aligned with order_per_bit */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">IS_ALIGNED</span><span class="p">(</span><span class="n">alignment</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">PAGE_SHIFT</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">order_per_bit</span><span class="p">))</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ALIGN</span><span class="p">(</span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="n">alignment</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">ALIGN</span><span class="p">(</span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">alignment</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">size</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Each reserved area must be initialised later, when more kernel</span>
<span class="cm">     * subsystems (like slab allocator) are available.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="n">cma</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cma_areas</span><span class="p">[</span><span class="n">cma_area_count</span><span class="p">];</span>
<span class="w">   </span><span class="err">（</span><span class="mi">1</span><span class="err">）</span><span class="n">从全局数组中获取一个cma</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
<span class="w">        </span><span class="n">snprintf</span><span class="p">(</span><span class="n">cma</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">CMA_MAX_NAME</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">);</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">        </span><span class="n">snprintf</span><span class="p">(</span><span class="n">cma</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">CMA_MAX_NAME</span><span class="p">,</span><span class="w">  </span><span class="s">"cma%d</span><span class="se">\\</span><span class="s">n"</span><span class="p">,</span><span class="w"> </span><span class="n">cma_area_count</span><span class="p">);</span>
<span class="w">   </span><span class="err">（</span><span class="mi">2</span><span class="err">）</span><span class="n">设置cma相关的参数</span>
<span class="w">    </span><span class="n">cma</span><span class="o">-&gt;</span><span class="n">base_pfn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PFN_DOWN</span><span class="p">(</span><span class="n">base</span><span class="p">);</span>
<span class="w">    </span><span class="n">cma</span><span class="o">-&gt;</span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">PAGE_SHIFT</span><span class="p">;</span>
<span class="w">    </span><span class="n">cma</span><span class="o">-&gt;</span><span class="n">order_per_bit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">order_per_bit</span><span class="p">;</span>
<span class="w">    </span><span class="o">*</span><span class="n">res_cma</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cma</span><span class="p">;</span>
<span class="w">    </span><span class="n">cma_area_count</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="n">totalcma_pages</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">PAGE_SIZE</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="_2">命令行或宏方式创建</h2>
<p>内核还提供通过内核启动参数或宏的方式来进行配置，本章节重点描述内核启动参数的方式，这里的启动参数一般是uboot传递过来的参数。</p>
<div class="codehilite"><pre><span></span><code><span class="n">env</span><span class="p">.</span><span class="n">cfg</span>

<span class="n">earlycon</span><span class="o">=</span><span class="n">uart8250</span><span class="p">,</span><span class="n">mmio32</span><span class="p">,</span><span class="mh">0x02500000</span>
<span class="n">initcall_debug</span><span class="o">=</span><span class="mi">0</span>
<span class="n">console</span><span class="o">=</span><span class="n">ttyAS0</span><span class="p">,</span><span class="mi">115200</span>
<span class="n">nand_root</span><span class="o">=/</span><span class="n">dev</span><span class="o">/</span><span class="n">nand0p4</span>
<span class="n">mmc_root</span><span class="o">=/</span><span class="n">dev</span><span class="o">/</span><span class="n">mmcblk0p4</span>
<span class="n">nor_root</span><span class="o">=/</span><span class="n">dev</span><span class="o">/</span><span class="n">mtdblock4</span>
<span class="n">init</span><span class="o">=/</span><span class="n">init</span>
<span class="n">loglevel</span><span class="o">=</span><span class="mi">8</span>
<span class="n">selinux</span><span class="o">=</span><span class="mi">0</span>
<span class="n">cma</span><span class="o">=</span><span class="mi">64</span><span class="n">M</span>
<span class="n">mac</span><span class="o">=</span>
<span class="n">wifi_mac</span><span class="o">=</span>
<span class="n">bt_mac</span><span class="o">=</span>
<span class="n">specialstr</span><span class="o">=</span>
<span class="n">keybox_list</span><span class="o">=</span><span class="n">hdcpkey</span><span class="p">,</span><span class="n">widevine</span>
</code></pre></div>
<p>笔者系统中内核的启动参数配置在env.cfg中，如下cma的大小配置为64M。内核代码中通过函数dma_contiguous_reserve进行获取cmdline或宏配置的cma大小。</p>
<div class="codehilite"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="nf">dma_contiguous_reserve</span><span class="p">(</span><span class="n">phys_addr_t</span><span class="w"> </span><span class="n">limit</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">phys_addr_t</span><span class="w"> </span><span class="n">selected_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">phys_addr_t</span><span class="w"> </span><span class="n">selected_base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">phys_addr_t</span><span class="w"> </span><span class="n">selected_limit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">limit</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">fixed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">    </span><span class="n">pr_debug</span><span class="p">(</span><span class="s">"%s(limit %08lx)</span><span class="se">\\</span><span class="s">n"</span><span class="p">,</span><span class="w"> </span><span class="n">__func__</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">)</span><span class="n">limit</span><span class="p">);</span>
<span class="w">   </span><span class="err">（</span><span class="mi">1</span><span class="err">）</span><span class="n">获取cmdline中传入的cma</span><span class="w"> </span><span class="n">size大小和地址</span><span class="err">。</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">size_cmdline</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">selected_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">size_cmdline</span><span class="p">;</span>
<span class="w">        </span><span class="n">selected_base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">base_cmdline</span><span class="p">;</span>
<span class="w">        </span><span class="n">selected_limit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">min_not_zero</span><span class="p">(</span><span class="n">limit_cmdline</span><span class="p">,</span><span class="w"> </span><span class="n">limit</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">base_cmdline</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">size_cmdline</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">limit_cmdline</span><span class="p">)</span>
<span class="w">            </span><span class="n">fixed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">这里是宏定义的方式</span>
<span class="cp">#ifdef CONFIG_CMA_SIZE_SEL_MBYTES</span>
<span class="w">        </span><span class="n">selected_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">size_bytes</span><span class="p">;</span>
<span class="cp">#elif defined(CONFIG_CMA_SIZE_SEL_PERCENTAGE)</span>
<span class="w">        </span><span class="n">selected_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cma_early_percent_memory</span><span class="p">();</span>
<span class="cp">#elif defined(CONFIG_CMA_SIZE_SEL_MIN)</span>
<span class="w">        </span><span class="n">selected_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">size_bytes</span><span class="p">,</span><span class="w"> </span><span class="n">cma_early_percent_memory</span><span class="p">());</span>
<span class="cp">#elif defined(CONFIG_CMA_SIZE_SEL_MAX)</span>
<span class="w">        </span><span class="n">selected_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">size_bytes</span><span class="p">,</span><span class="w"> </span><span class="n">cma_early_percent_memory</span><span class="p">());</span>
<span class="cp">#endif</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">selected_size</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">dma_contiguous_default_area</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">pr_debug</span><span class="p">(</span><span class="s">"%s: reserving %ld MiB for global area</span><span class="se">\\</span><span class="s">n"</span><span class="p">,</span><span class="w"> </span><span class="n">__func__</span><span class="p">,</span>
<span class="w">             </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">)</span><span class="n">selected_size</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">SZ_1M</span><span class="p">);</span>
<span class="w">    </span><span class="err">（</span><span class="mi">2</span><span class="err">）</span><span class="n">获取到cma区域后</span><span class="err">，</span><span class="n">进行初始化</span>
<span class="w">        </span><span class="n">dma_contiguous_reserve_area</span><span class="p">(</span><span class="n">selected_size</span><span class="p">,</span><span class="w"> </span><span class="n">selected_base</span><span class="p">,</span>
<span class="w">                        </span><span class="n">selected_limit</span><span class="p">,</span>
<span class="w">                        </span><span class="o">&amp;</span><span class="n">dma_contiguous_default_area</span><span class="p">,</span>
<span class="w">                        </span><span class="n">fixed</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>dma_contiguous_reserve_area函数最终还是会调用到cma_init_reserved_mem，进而获取一个cma实例，然后进行初始化cma结构体。</p>
<h2 id="cma_1">CMA初始化</h2>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="nf">cma_init_reserved_areas</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="n">遍历CMA数组</span><span class="err">，</span><span class="n">进行初始化</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">cma_area_count</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="n">cma_activate_area</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cma_areas</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">core_initcall</span><span class="p">(</span><span class="n">cma_init_reserved_areas</span><span class="p">);</span>
</code></pre></div>
<p>主要是遍历cma_areas数组，进行初始化。</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="nf">cma_activate_area</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">cma</span><span class="w"> </span><span class="o">*</span><span class="n">cma</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">base_pfn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cma</span><span class="o">-&gt;</span><span class="n">base_pfn</span><span class="p">,</span><span class="w"> </span><span class="n">pfn</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">zone</span><span class="w"> </span><span class="o">*</span><span class="n">zone</span><span class="p">;</span>
<span class="w">   </span><span class="err">（</span><span class="mi">1</span><span class="err">）</span><span class="n">计算需要的bitmap大小</span><span class="err">，</span><span class="n">然后进行分配</span><span class="err">。</span><span class="n">主要受count和bit的影响</span><span class="err">。</span>
<span class="w">    </span><span class="n">cma</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bitmap_zalloc</span><span class="p">(</span><span class="n">cma_bitmap_maxno</span><span class="p">(</span><span class="n">cma</span><span class="p">),</span><span class="w"> </span><span class="n">GFP_KERNEL</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">cma</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">)</span>
<span class="w">        </span><span class="k">goto</span><span class="w"> </span><span class="n">out_error</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * alloc_contig_range() requires the pfn range specified to be in the</span>
<span class="cm">     * same zone. Simplify by forcing the entire CMA resv range to be in the</span>
<span class="cm">     * same zone.</span>
<span class="cm">     */</span>
<span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">pfn_valid</span><span class="p">(</span><span class="n">base_pfn</span><span class="p">));</span>
<span class="err">（</span><span class="mi">2</span><span class="err">）</span><span class="n">判断物理页是否都在一个zone区</span><span class="err">，</span><span class="n">需要在同一个zone区</span><span class="err">。</span>
<span class="w">    </span><span class="n">zone</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">page_zone</span><span class="p">(</span><span class="n">pfn_to_page</span><span class="p">(</span><span class="n">base_pfn</span><span class="p">));</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">pfn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">base_pfn</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">pfn</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">base_pfn</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">cma</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span><span class="w"> </span><span class="n">pfn</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="o">!</span><span class="n">pfn_valid</span><span class="p">(</span><span class="n">pfn</span><span class="p">));</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">page_zone</span><span class="p">(</span><span class="n">pfn_to_page</span><span class="p">(</span><span class="n">pfn</span><span class="p">))</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">zone</span><span class="p">)</span>
<span class="w">            </span><span class="k">goto</span><span class="w"> </span><span class="n">not_in_zone</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">   </span><span class="err">（</span><span class="mi">3</span><span class="err">）</span><span class="n">将物理页释放到伙伴系统中去</span><span class="err">。</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">pfn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">base_pfn</span><span class="p">;</span><span class="w"> </span><span class="n">pfn</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">base_pfn</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">cma</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
<span class="w">         </span><span class="n">pfn</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">pageblock_nr_pages</span><span class="p">)</span>
<span class="w">        </span><span class="n">init_cma_reserved_pageblock</span><span class="p">(</span><span class="n">pfn_to_page</span><span class="p">(</span><span class="n">pfn</span><span class="p">));</span>

<span class="w">    </span><span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cma</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_CMA_DEBUGFS</span>
<span class="w">    </span><span class="n">INIT_HLIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cma</span><span class="o">-&gt;</span><span class="n">mem_head</span><span class="p">);</span>
<span class="w">    </span><span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cma</span><span class="o">-&gt;</span><span class="n">mem_head_lock</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="w">    </span><span class="k">return</span><span class="p">;</span>

<span class="nl">not_in_zone</span><span class="p">:</span>
<span class="w">    </span><span class="n">bitmap_free</span><span class="p">(</span><span class="n">cma</span><span class="o">-&gt;</span><span class="n">bitmap</span><span class="p">);</span>
<span class="nl">out_error</span><span class="p">:</span>
<span class="w">    </span><span class="cm">/* Expose all pages to the buddy, they are useless for CMA. */</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">pfn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">base_pfn</span><span class="p">;</span><span class="w"> </span><span class="n">pfn</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">base_pfn</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">cma</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span><span class="w"> </span><span class="n">pfn</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="n">free_reserved_page</span><span class="p">(</span><span class="n">pfn_to_page</span><span class="p">(</span><span class="n">pfn</span><span class="p">));</span>
<span class="w">    </span><span class="n">totalcma_pages</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">cma</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
<span class="w">    </span><span class="n">cma</span><span class="o">-&gt;</span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">pr_err</span><span class="p">(</span><span class="s">"CMA area %s could not be activated</span><span class="se">\\</span><span class="s">n"</span><span class="p">,</span><span class="w"> </span><span class="n">cma</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="cma_2">CMA应用</h2>
<div class="codehilite"><pre><span></span><code><span class="n">DMA的申请</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">page</span><span class="w"> </span><span class="o">*</span><span class="n">dma_alloc_from_contiguous</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">device</span><span class="w"> </span><span class="o">*</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">count</span><span class="p">,</span>
<span class="w">                       </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">align</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">no_warn</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">align</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">CONFIG_CMA_ALIGNMENT</span><span class="p">)</span>
<span class="w">        </span><span class="n">align</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CONFIG_CMA_ALIGNMENT</span><span class="p">;</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">cma_alloc</span><span class="p">(</span><span class="n">dev_get_cma_area</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span><span class="w"> </span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="n">align</span><span class="p">,</span><span class="w"> </span><span class="n">no_warn</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">DMA的释放</span>

<span class="kt">bool</span><span class="w"> </span><span class="n">dma_release_from_contiguous</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">device</span><span class="w"> </span><span class="o">*</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">page</span><span class="w"> </span><span class="o">*</span><span class="n">pages</span><span class="p">,</span>
<span class="w">                 </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">cma_release</span><span class="p">(</span><span class="n">dev_get_cma_area</span><span class="p">(</span><span class="n">dev</span><span class="p">),</span><span class="w"> </span><span class="n">pages</span><span class="p">,</span><span class="w"> </span><span class="n">count</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>对内核的申请和释放提供给用户使用的分配是dma_alloc_from_contiguous和dma_release_from_contiguous，其调用的是cma_alloc和cma_release来实现的。 cma_alloc指定CMA areas上分配count个连续的page frame，具体就是遍历bitmap看是否有可用内存，如果有就向伙伴系统申请内存，如果伙伴系统将对应的内存挪给其他应用了，那么需要进行页面迁移、页面回收等操作回收回来。</p>
<h2 id="ion">ION</h2>
<p>待补充</p></div>
  <div class="post-nav">
    <a class="prev" href="../dma与cache一致性.html">← DMA与cache一致性</a>
    <a class="next" href="../slub分配器.html">slub分配器 →</a>
  </div>
</article>

      </section>

      <aside class="right-panel">
        
      </aside>
    </main>

    <footer class="site-footer">
      <div class="container">Copyright ©2022-2025 laumy 版权所有</div>
    </footer>

    <script src="../assets/site.js"></script>
  </body>
  </html>

