<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>负载均衡之调度组和调度域 - Laumy的技术栈</title>
    <link rel="stylesheet" href="/laumy.github.io/assets/style.css">
    <!-- MathJax支持LaTeX数学公式 -->
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          ignoreHtmlClass: 'tex2jax_ignore',
          processHtmlClass: 'tex2jax_process'
        }
      };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  </head>
  <body>
    <header class="site-header">
      <div class="container">
        <a class="logo" href="/laumy.github.io/">Laumy的技术栈</a>
        <div class="search">
          <input id="search-input" type="text" placeholder="输入关键词回车搜索">
        </div>
        <div class="theme-toggle" title="切换主题" id="theme-toggle">☾</div>
        <nav class="top-nav">
          <div class="nav-item"><a href="/laumy.github.io/">首页</a></div>
        </nav>
      </div>
    </header>

    <main class="container layout">
      <aside class="left-nav">
        
        <div class="card">
          <div class="card-title">文章目录</div>
          <nav id="toc"><ul><li><a href="#_1">概述</a><ul></ul></li><li><a href="#_2">数据结构</a><ul></ul></li><li><a href="#cpu">CPU拓扑结构</a><ul></ul></li><li><a href="#sdsg">创建sd和sg</a><ul><li><a href="#diemccpusdsdcsgsgc">为DIE和MC分配每CPU的sd/sdc/sg/sgc空间</a></li><li><a href="#sd">初始化调度域sd</a></li><li><a href="#sg">初始化调度组sg</a></li><li><a href="#sgc">构建调度组能力sgc</a></li><li><a href="#cpumcsdrootdomaincpu-rq">将每cpu的MC层级sd、rootdomain与cpu rq绑定</a></li></ul></li></ul></nav>
        </div>
        
      </aside>

      <section class="content">
        
<article class="card post">
  <h1>负载均衡之调度组和调度域</h1>
  <div class="meta">2023-04-16 · linux</div>
  <div class="post-content"><h2 id="_1">概述</h2>
<p>从上一章节大概应该能够理解负载和利用率的区别了，当一个进程正在运行或者即使没有在cpu上运行，而在就绪队列中等待运行，那么他依旧消耗cpu的负载。这是合理的，因为cpu的就绪队列有10个任务等待着运行与5个任务等待运行，明显是10个任务的负载重。而利用率只是关注正在运行的任务而不包含在就绪队列的任务，在某个时间段内可能某个任务的cpu利用率很高，但是占用完之后一直睡眠，那么其队系统的负载贡献还是较小。</p>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_7899f9010271eec5a7d023fca4dd488b.jpg"><img alt="" src="/laumy.github.io/assets/doc/01-linux/进程调度/10-负载均衡之调度组和调度域/images/wp_editor_md_7899f9010271eec5a7d023fca4dd488b.jpg"/></a></p>
<p>从CPU的层次划分，从大到小分为：</p>
<ul>
<li>NUMA: 多个SOC组成，通过UPI可以共享多块物理内存，常用于服务器。</li>
<li>SOC: system-on-a-chip，集成了多个系统组件或功能的芯片，对应DIE。</li>
<li>MC:multi-core，多核处理器，一个SOC集成多个核心，每个核心用于自己的缓存或寄存器资源，可以并行处理多个程序。</li>
<li>SMT:Simultaneous Multi-Threading，超线程，单个核心处理器同时执行多个线程，在单个核心处理器引入多个逻辑执行单元和资源共享极致，实现更好的指令集并发性。</li>
</ul>
<p>现在的嵌入式处理器通常包含SOC+MC技术，也就是在一个SOC上集成了多核处理器，目前遇到的SMT和NUMA的还比较少，因此本章节先讨论一个SOC上集成MC的情况。 因为多核的出现，我们需要引入负载均衡，我们需要解决将SOC运行的任务均衡的分配到各个核上处理，但是并不能简单的平均分配任务到各个CPU上，从上图的架构来看，一个SOC上存在大小核的情况2个小核+2个大核，那自然大核的算力要高于小核的算力，同时我们还需要考虑CPU的频率，同样的架构核心高频的算力自然要高于低频的算力。除了配合各CPU的算力来均衡负载外，还需要考虑任务迁移的开销，上图CPU0上的任务迁移到CPU1上的开销会少于迁移到CPU2上，因为CPU0和CPU1共享L2 cache，如果迁移到L2上的话，cache就会失效，性能或许会减弱。基于上述这些因素，linux构建了相关的数据结构来处理这些问题，称为调度域和调度组。</p>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_2e21f150223e2f456e7dab528e5568de.jpg"><img alt="" src="/laumy.github.io/assets/doc/01-linux/进程调度/10-负载均衡之调度组和调度域/images/wp_editor_md_2e21f150223e2f456e7dab528e5568de.jpg"/></a></p>
<p>系统为了便于负载均衡，构建调度域（sched domain，简记sd）和调度组(sched group，简记sg)。按照架构层级可以依次划分为不同的SOC、相同SOC不同的核心、相同的核心不同的超线程。我们把相同层级称为调度域，越往下层的调度域共用的缓存越多，因此在任务做迁移时，优先选择从底层的调度域中进行。先不考虑SMT，上图的调度域可以分为两级从下往上MC domain（multi core domain），DIE domain。</p>
<ul>
<li>DIE domain：处于顶层，覆盖系统所有的CPU（CPU0~CPU3）。</li>
<li>MC domain：处于底层，也称为base domain，分为小核MC domain（cpu0~cpu1）和大核MC domain（CPU2~CPU3），小核MC domain是一个cluster，大核MC domain是一个cluster。</li>
</ul>
<p>负载均衡调度的最小单元是调度组，每个调度域进行分组。对于MC域，基本可以按照一个cpu是一组，所以小核MC domain可以分为两组（一个CPU对应一组），大核MC domain也是分为两组。对于DIE域，每个分组要覆盖到其child domain，DIE 域有两个子domain，分别是小核MC domain，大核MC domain，因此DIE domain分为两个组对于小核group和大核group。</p>
<h2 id="_2">数据结构</h2>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_a488005fef52cf5dc4690aa63612a881.jpg"><img alt="" src="/laumy.github.io/assets/doc/01-linux/进程调度/10-负载均衡之调度组和调度域/images/wp_editor_md_a488005fef52cf5dc4690aa63612a881.jpg"/></a></p>
<p>Linux内核使用struct sched_domain_topology_level，简称SDTL来描述CPU的层次关系。</p>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_92716d6b3a12d29b803e07b741b7498c.jpg"><img alt="" src="/laumy.github.io/assets/doc/01-linux/进程调度/10-负载均衡之调度组和调度域/images/wp_editor_md_92716d6b3a12d29b803e07b741b7498c.jpg"/></a></p>
<p>struct sched_domain_topology_level</p>
<ul>
<li>mask：函数指针，指定cpumask位图</li>
<li>sd_flags：函数指针，指定标志位</li>
<li>flags:进一步描述和设置调度域</li>
<li>numa_level:NUMA层级，确定该层级为NUMA的那一层</li>
<li>data:调度域数据结构，存储关于调度域的统计信息</li>
<li>name:调度域名称</li>
</ul>
<p>以下是内核默认定义了一个层次结构，DIE是默认打开，MC和SMT是可选的。</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_domain_topology_level</span><span class="w"> </span><span class="n">default_topology</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="cp">#ifdef CONFIG_SCHED_SMT</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="n">cpu_smt_mask</span><span class="p">,</span><span class="w"> </span><span class="n">cpu_smt_flags</span><span class="p">,</span><span class="w"> </span><span class="n">SD_INIT_NAME</span><span class="p">(</span><span class="n">SMT</span><span class="p">)</span><span class="w"> </span><span class="p">},</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_SCHED_MC</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="n">cpu_coregroup_mask</span><span class="p">,</span><span class="w"> </span><span class="n">cpu_core_flags</span><span class="p">,</span><span class="w"> </span><span class="n">SD_INIT_NAME</span><span class="p">(</span><span class="n">MC</span><span class="p">)</span><span class="w"> </span><span class="p">},</span>
<span class="cp">#endif</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="n">cpu_cpu_mask</span><span class="p">,</span><span class="w"> </span><span class="n">SD_INIT_NAME</span><span class="p">(</span><span class="n">DIE</span><span class="p">)</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="p">},</span>
<span class="p">};</span>
<span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_domain_topology_level</span><span class="w"> </span><span class="o">*</span><span class="n">sched_domain_topology</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">default_topology</span><span class="p">;</span>
</code></pre></div>
<p>struct sd_data,该结构体中成员都使用percpu来修饰，用于指示该指针是一个per-CPU变量，告诉编译器将变量的内存分配为每个CPU分别保留的独立内存块，如struct sched *__percpu *sd是指向struct sched_domain类型的per-CPU变量，也就是其指向的是一个数组（有cpu个数元素），数组的每个元素是指向一个struct sched_domain类型的指针，每个指针与一个特定的CPU相关联，分配数组是使用alloc_percpu来实现，该函数会分配一个具有相同大小的块，并为每个cpu都分配一个指针。 sd = alloc_percpu(struct sched_domain *)，则sd分配了per-CPU变量的内存空间，这意味着每个CPU都有自己独立的struct sched_domain指针变量，当给其每个CPU的指针变量赋值后，后续可以通过sd[cpu]来cpu上的struct sched_domain变量。</p>
<ul>
<li>sd[]: 描述CPU的调度域，实际是一个指针数组，每个数组元素指针指向cpu所属的调度域，下同。</li>
<li>sds[]:存储调度域共享数据，用于描述多个CPU共享的调度域。</li>
<li>sg[]:每个cpu都有一个指向调度组的指针，用于描述CPU所属的调度组</li>
<li>sgc[]:调度组的容量信息，用于描述调度组的资源容量。</li>
</ul>
<p>在系统中，为了避免多核之间的互斥访问影响性能，调度域sched_domain数据结构采用Per-CPU的变量来构建，每个CPU都维护一个调度域数据结构。 struct sched_domain_shared，为了降低锁竞争，sd是per-cpu的，但是有一些信息需要在per-cpu上的sd之间共享，不能在每个sd上构建，这些共享的信息就存储在sds上。</p>
<ul>
<li>nr_busy_cpus:该sd中忙的cpu个数。</li>
<li>has_idle_cores:该sd中是否有idle cpu。</li>
</ul>
<p>struct sched_group_capacity</p>
<ul>
<li>capacity:</li>
<li>min/max_capacity:</li>
<li>next_update:</li>
<li>imbalance:</li>
<li>cpumask[]</li>
</ul>
<p>struct sched_domain</p>
<ul>
<li>parent和child:调度域会形成层次结构，parent和child建立了不同层级的父子关系。对于base domain而言，其child=NULL，对于顶层domain而言，parent=NULL。</li>
<li>groups:一个调度域中有若干调度组，这些调到组形成一个环形的链表，groups成员就是链表头。</li>
<li>flags:调度域的标志，SD_BALANCE_NEWIDLE是否支持newidle balance，SD_SHARE_PKG_RESOURCES是否共享cache等资源。</li>
<li>span[]:调度域中cpu 核形成的cpu mask，即调度域覆盖的cpu核范围，当前调度域可使用那几个cpu核。</li>
</ul>
<p>struct sched_group</p>
<ul>
<li>next: 调度域中的所有group都会形成一个链表，next指向下一个group。</li>
<li>ref:该调度组被应用的次数。</li>
<li>group_weight:调度组中有多少个cpu。</li>
<li>sgc:调度组的算力信息。</li>
<li>cpumask:调度组包括那些cpu。</li>
</ul>
<div class="codehilite"><pre><span></span><code><span class="n">include</span><span class="o">/</span><span class="n">linux</span><span class="o">/</span><span class="n">cpumask</span><span class="p">.</span><span class="n">h</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">cpumask</span><span class="w"> </span><span class="p">{</span>
<span class="n">DECLARE_BITMAP</span><span class="p">(</span><span class="n">bits</span><span class="p">,</span><span class="w"> </span><span class="n">NR_CPUS</span><span class="p">);</span>
<span class="c1">//unsigned long bits[1]；</span>
<span class="p">}</span>

<span class="c1">//NR_CPUS为核心数，以8核，64位系统计算为例。</span>

<span class="cp">#define DECLARE_BITMAP(name,bits) \\</span>
<span class="cp">unsigned long name[BITS_TO_LONGS(bits)]</span>

<span class="cp">#define BITS_TO_LONGS(nr)   __KERNEL_DIV_ROUND_UP(nr, BITS_PER_TYPE(long))</span>

<span class="cp">#define __KERNEL_DIV_ROUND_UP(n, d) (((n) + (d) - 1) / (d))</span>

<span class="cp">#define BITS_PER_TYPE(type) (sizeof(type) * BITS_PER_BYTE)</span>

<span class="cp">#define BITS_PER_BYTE       8</span>

<span class="p">(((</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">d</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">d</span><span class="p">))</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(((</span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="mi">64</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="mi">64</span><span class="p">))</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span>
</code></pre></div>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">s_data</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_domain</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">__percpu</span><span class="w"> </span><span class="o">*</span><span class="n">sd</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">root_domain</span><span class="w">  </span><span class="o">*</span><span class="n">rd</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<h2 id="cpu">CPU拓扑结构</h2>
<div class="codehilite"><pre><span></span><code><span class="n">Linux内核中</span><span class="err">，</span><span class="n">通过读取dts文件</span><span class="err">，</span><span class="n">建立Topology</span><span class="err">。</span>
</code></pre></div>
<div class="codehilite"><pre><span></span><code><span class="w"> </span><span class="n">cpus</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="cp">#address-cells = &lt;0x02&gt;;</span>
<span class="w">        </span><span class="cp">#size-cells = &lt;0x00&gt;;</span>

<span class="w">        </span><span class="n">cpu</span><span class="err">@</span><span class="mi">0</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">device_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"cpu"</span><span class="p">;</span>
<span class="w">            </span><span class="n">compatible</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"arm,cortex-a55"</span><span class="p">;</span>
<span class="w">            </span><span class="n">reg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x00</span><span class="w"> </span><span class="mh">0x00</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">            </span><span class="n">enable</span><span class="o">-</span><span class="n">method</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"psci"</span><span class="p">;</span>
<span class="w">            </span><span class="n">cpu</span><span class="o">-</span><span class="n">idle</span><span class="o">-</span><span class="n">states</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x02</span><span class="w"> </span><span class="mh">0x03</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">            </span><span class="n">capacity</span><span class="o">-</span><span class="n">dmips</span><span class="o">-</span><span class="n">mhz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x39a</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">            </span><span class="n">clocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x04</span><span class="w"> </span><span class="mh">0x01</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">            </span><span class="n">operating</span><span class="o">-</span><span class="n">points</span><span class="o">-</span><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x05</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">            </span><span class="cp">#cooling-cells = &lt;0x02&gt;;</span>
<span class="w">            </span><span class="n">dynamic</span><span class="o">-</span><span class="n">power</span><span class="o">-</span><span class="n">coefficient</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x11e</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">            </span><span class="n">cpu</span><span class="o">-</span><span class="n">supply</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x06</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">            </span><span class="n">phandle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x09</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">        </span><span class="p">};</span>

<span class="w">        </span><span class="n">cpu</span><span class="err">@</span><span class="mi">100</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">device_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"cpu"</span><span class="p">;</span>
<span class="w">            </span><span class="n">compatible</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"arm,cortex-a55"</span><span class="p">;</span>
<span class="w">            </span><span class="n">reg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x00</span><span class="w"> </span><span class="mh">0x100</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">            </span><span class="n">enable</span><span class="o">-</span><span class="n">method</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"psci"</span><span class="p">;</span>
<span class="w">            </span><span class="n">cpu</span><span class="o">-</span><span class="n">idle</span><span class="o">-</span><span class="n">states</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x02</span><span class="w"> </span><span class="mh">0x03</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">            </span><span class="n">capacity</span><span class="o">-</span><span class="n">dmips</span><span class="o">-</span><span class="n">mhz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x39a</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">            </span><span class="n">clocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x04</span><span class="w"> </span><span class="mh">0x01</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">            </span><span class="n">operating</span><span class="o">-</span><span class="n">points</span><span class="o">-</span><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x05</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">            </span><span class="cp">#cooling-cells = &lt;0x02&gt;;</span>
<span class="w">            </span><span class="n">phandle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x0a</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">        </span><span class="p">};</span>

<span class="w">        </span><span class="n">cpu</span><span class="err">@</span><span class="mi">200</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">device_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"cpu"</span><span class="p">;</span>
<span class="w">            </span><span class="n">compatible</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"arm,cortex-a55"</span><span class="p">;</span>
<span class="w">            </span><span class="n">reg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x00</span><span class="w"> </span><span class="mh">0x200</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">            </span><span class="n">enable</span><span class="o">-</span><span class="n">method</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"psci"</span><span class="p">;</span>
<span class="w">            </span><span class="n">cpu</span><span class="o">-</span><span class="n">idle</span><span class="o">-</span><span class="n">states</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x02</span><span class="w"> </span><span class="mh">0x03</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">            </span><span class="n">capacity</span><span class="o">-</span><span class="n">dmips</span><span class="o">-</span><span class="n">mhz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x39a</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">            </span><span class="n">clocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x04</span><span class="w"> </span><span class="mh">0x01</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">            </span><span class="n">operating</span><span class="o">-</span><span class="n">points</span><span class="o">-</span><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x05</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">            </span><span class="cp">#cooling-cells = &lt;0x02&gt;;</span>
<span class="w">            </span><span class="n">phandle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x0b</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">        </span><span class="p">};</span>
<span class="w">        </span><span class="n">cpu</span><span class="err">@</span><span class="mi">300</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">device_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"cpu"</span><span class="p">;</span>
<span class="w">            </span><span class="n">compatible</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"arm,cortex-a55"</span><span class="p">;</span>
<span class="w">            </span><span class="n">reg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x00</span><span class="w"> </span><span class="mh">0x300</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">            </span><span class="n">enable</span><span class="o">-</span><span class="n">method</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"psci"</span><span class="p">;</span>
<span class="w">            </span><span class="n">cpu</span><span class="o">-</span><span class="n">idle</span><span class="o">-</span><span class="n">states</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x02</span><span class="w"> </span><span class="mh">0x03</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">            </span><span class="n">capacity</span><span class="o">-</span><span class="n">dmips</span><span class="o">-</span><span class="n">mhz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x39a</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">            </span><span class="n">clocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x04</span><span class="w"> </span><span class="mh">0x01</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">            </span><span class="n">operating</span><span class="o">-</span><span class="n">points</span><span class="o">-</span><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x05</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">            </span><span class="cp">#cooling-cells = &lt;0x02&gt;;</span>
<span class="w">            </span><span class="n">phandle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x0c</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">        </span><span class="p">};</span>

<span class="w">        </span><span class="n">cpu</span><span class="err">@</span><span class="mi">400</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">device_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"cpu"</span><span class="p">;</span>
<span class="w">            </span><span class="n">compatible</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"arm,cortex-a55"</span><span class="p">;</span>
<span class="w">            </span><span class="n">reg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x00</span><span class="w"> </span><span class="mh">0x400</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">            </span><span class="n">enable</span><span class="o">-</span><span class="n">method</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"psci"</span><span class="p">;</span>
<span class="w">            </span><span class="n">cpu</span><span class="o">-</span><span class="n">idle</span><span class="o">-</span><span class="n">states</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x02</span><span class="w"> </span><span class="mh">0x03</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">            </span><span class="n">capacity</span><span class="o">-</span><span class="n">dmips</span><span class="o">-</span><span class="n">mhz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x400</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">            </span><span class="n">clocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x04</span><span class="w"> </span><span class="mh">0x03</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">            </span><span class="n">operating</span><span class="o">-</span><span class="n">points</span><span class="o">-</span><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x07</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">            </span><span class="cp">#cooling-cells = &lt;0x02&gt;;</span>
<span class="w">            </span><span class="n">dynamic</span><span class="o">-</span><span class="n">power</span><span class="o">-</span><span class="n">coefficient</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x162</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">            </span><span class="n">cpu</span><span class="o">-</span><span class="n">supply</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x08</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">            </span><span class="n">phandle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x0d</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">        </span><span class="p">};</span>

<span class="w">        </span><span class="n">cpu</span><span class="err">@</span><span class="mi">500</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">device_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"cpu"</span><span class="p">;</span>
<span class="w">            </span><span class="n">compatible</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"arm,cortex-a55"</span><span class="p">;</span>
<span class="w">            </span><span class="n">reg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x00</span><span class="w"> </span><span class="mh">0x500</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">            </span><span class="n">enable</span><span class="o">-</span><span class="n">method</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"psci"</span><span class="p">;</span>
<span class="w">            </span><span class="n">cpu</span><span class="o">-</span><span class="n">idle</span><span class="o">-</span><span class="n">states</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x02</span><span class="w"> </span><span class="mh">0x03</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">            </span><span class="n">capacity</span><span class="o">-</span><span class="n">dmips</span><span class="o">-</span><span class="n">mhz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x400</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">            </span><span class="n">clocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x04</span><span class="w"> </span><span class="mh">0x03</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">            </span><span class="n">operating</span><span class="o">-</span><span class="n">points</span><span class="o">-</span><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x07</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">            </span><span class="cp">#cooling-cells = &lt;0x02&gt;;</span>
<span class="w">            </span><span class="n">phandle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x0e</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">        </span><span class="p">};</span>
<span class="w">        </span><span class="n">cpu</span><span class="err">@</span><span class="mi">600</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">device_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"cpu"</span><span class="p">;</span>
<span class="w">            </span><span class="n">compatible</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"arm,cortex-a55"</span><span class="p">;</span>
<span class="w">            </span><span class="n">reg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x00</span><span class="w"> </span><span class="mh">0x600</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">            </span><span class="n">enable</span><span class="o">-</span><span class="n">method</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"psci"</span><span class="p">;</span>
<span class="w">            </span><span class="n">cpu</span><span class="o">-</span><span class="n">idle</span><span class="o">-</span><span class="n">states</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x02</span><span class="w"> </span><span class="mh">0x03</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">            </span><span class="n">capacity</span><span class="o">-</span><span class="n">dmips</span><span class="o">-</span><span class="n">mhz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x400</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">            </span><span class="n">clocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x04</span><span class="w"> </span><span class="mh">0x03</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">            </span><span class="n">operating</span><span class="o">-</span><span class="n">points</span><span class="o">-</span><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x07</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">            </span><span class="cp">#cooling-cells = &lt;0x02&gt;;</span>
<span class="w">            </span><span class="n">phandle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x0f</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">        </span><span class="p">};</span>

<span class="w">        </span><span class="n">cpu</span><span class="err">@</span><span class="mi">700</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">device_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"cpu"</span><span class="p">;</span>
<span class="w">            </span><span class="n">compatible</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"arm,cortex-a55"</span><span class="p">;</span>
<span class="w">            </span><span class="n">reg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x00</span><span class="w"> </span><span class="mh">0x700</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">            </span><span class="n">enable</span><span class="o">-</span><span class="n">method</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"psci"</span><span class="p">;</span>
<span class="w">            </span><span class="n">cpu</span><span class="o">-</span><span class="n">idle</span><span class="o">-</span><span class="n">states</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x02</span><span class="w"> </span><span class="mh">0x03</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">            </span><span class="n">capacity</span><span class="o">-</span><span class="n">dmips</span><span class="o">-</span><span class="n">mhz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x400</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">            </span><span class="n">clocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x04</span><span class="w"> </span><span class="mh">0x03</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">            </span><span class="n">operating</span><span class="o">-</span><span class="n">points</span><span class="o">-</span><span class="n">v2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x07</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">            </span><span class="cp">#cooling-cells = &lt;0x02&gt;;</span>
<span class="w">            </span><span class="n">phandle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x10</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">        </span><span class="p">};</span>

<span class="w">        </span><span class="n">cpu</span><span class="o">-</span><span class="n">map</span><span class="w"> </span><span class="p">{</span>

<span class="w">            </span><span class="n">cluster0</span><span class="w"> </span><span class="p">{</span>

<span class="w">                </span><span class="n">core0</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="n">cpu</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x09</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">                </span><span class="p">};</span>

<span class="w">                </span><span class="n">core1</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="n">cpu</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x0a</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">                </span><span class="p">};</span>

<span class="w">                </span><span class="n">core2</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="n">cpu</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x0b</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">                </span><span class="p">};</span>

<span class="w">                </span><span class="n">core3</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="n">cpu</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x0c</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">                </span><span class="p">};</span>
<span class="w">            </span><span class="p">};</span>

<span class="w">            </span><span class="n">cluster1</span><span class="w"> </span><span class="p">{</span>

<span class="w">                </span><span class="n">core0</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="n">cpu</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x0d</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">                </span><span class="p">};</span>

<span class="w">                </span><span class="n">core1</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="n">cpu</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x0e</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">                </span><span class="p">};</span>

<span class="w">                </span><span class="n">core2</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="n">cpu</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x0f</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">                </span><span class="p">};</span>

<span class="w">                </span><span class="n">core3</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="n">cpu</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&lt;</span><span class="mh">0x10</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">                </span><span class="p">};</span>
<span class="w">            </span><span class="p">};</span>
<span class="w">        </span><span class="p">};</span>
<span class="p">}</span>
</code></pre></div>
<p>上面的dts描述，soc中有8个核心，分为两个cluster，cpu0~cpu3，cpu4~cpu7，因此调度域可以这样划分。</p>
<ul>
<li>DIE: cpu 0~7</li>
<li>MC: cpu 0~3一组，cpu4~7一组。</li>
</ul>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_85351c787565585bdea6b8eb17e513f1.jpg"><img alt="" src="/laumy.github.io/assets/doc/01-linux/进程调度/10-负载均衡之调度组和调度域/images/wp_editor_md_85351c787565585bdea6b8eb17e513f1.jpg"/></a></p>
<p>可以通过 /sys/devices/system/cpu/cpuX/topology节点来获取topology相关信息。</p>
<div class="codehilite"><pre><span></span><code><span class="n">root</span><span class="err">@</span><span class="n">TinaLinux</span><span class="o">:/</span><span class="n">sys</span><span class="o">/</span><span class="n">devices</span><span class="o">/</span><span class="n">system</span><span class="o">/</span><span class="n">cpu</span><span class="o">/</span><span class="n">cpu0</span><span class="o">/</span><span class="n">topology</span><span class="err">#</span><span class="w"> </span><span class="n">cat</span><span class="w"> </span><span class="o">*</span>
<span class="mo">01</span><span class="w"> </span><span class="c1">//core_cpus </span>
<span class="mi">0</span><span class="w"> </span><span class="c1">//core_cpus_list</span>
<span class="mi">0</span><span class="w"> </span><span class="c1">//core_id</span>
<span class="mf">0f</span><span class="w"> </span><span class="c1">//core_siblings</span>
<span class="mi">0-3</span><span class="w"> </span><span class="c1">//core_siblings_list</span>
<span class="mo">01</span><span class="w"> </span><span class="c1">//die_cpus</span>
<span class="mi">0</span><span class="w"> </span><span class="c1">//die_cpus_list</span>
<span class="mi">-1</span><span class="w"> </span><span class="c1">//die_id</span>
<span class="mf">0f</span><span class="w"> </span><span class="c1">//package_cpus</span>
<span class="mi">0-3</span><span class="w"> </span><span class="c1">//package_cpus_list</span>
<span class="mi">0</span><span class="w"> </span><span class="c1">//physical_package_id</span>
<span class="mo">01</span><span class="w"> </span><span class="c1">//thread_siblings</span>
<span class="mi">0</span><span class="w"> </span><span class="c1">//thread_siblings_list</span>
</code></pre></div>
<div class="codehilite"><pre><span></span><code><span class="n">root</span><span class="err">@</span><span class="n">TinaLinux</span><span class="o">:/</span><span class="n">sys</span><span class="o">/</span><span class="n">devices</span><span class="o">/</span><span class="n">system</span><span class="o">/</span><span class="n">cpu</span><span class="o">/</span><span class="n">cpu6</span><span class="o">/</span><span class="n">topology</span><span class="err">#</span><span class="w"> </span><span class="n">cat</span><span class="w"> </span><span class="o">*</span>
<span class="mi">40</span><span class="w"> </span><span class="c1">//core_cpus </span>
<span class="mi">6</span><span class="w"> </span><span class="c1">//core_cpus_list</span>
<span class="mi">2</span><span class="w"> </span><span class="c1">//core_id</span>
<span class="n">f0</span><span class="w"> </span><span class="c1">//core_siblings</span>
<span class="mi">4-7</span><span class="w"> </span><span class="c1">//core_siblings_list</span>
<span class="mi">40</span><span class="w"> </span><span class="c1">//die_cpus</span>
<span class="mi">6</span><span class="w"> </span><span class="c1">//die_cpus_list</span>
<span class="mi">-1</span><span class="w"> </span><span class="c1">//die_id</span>
<span class="n">f0</span><span class="w"> </span><span class="c1">//package_cpus</span>
<span class="mi">4-7</span><span class="w"> </span><span class="c1">//package_cpus_list</span>
<span class="mi">1</span><span class="w"> </span><span class="c1">//physical_package_id</span>
<span class="mi">40</span><span class="w"> </span><span class="c1">//thread_siblings</span>
<span class="mi">7</span><span class="w"> </span><span class="c1">//thread_siblings_list</span>
</code></pre></div>
<p>在后续章节中，我们都以当前的拓扑结构举例来说明。</p>
<h2 id="sdsg">创建sd和sg</h2>
<p>CPU MASK</p>
<div class="codehilite"><pre><span></span><code><span class="cp">#define cpu_possible_mask ((const struct cpumask *)&amp;__cpu_possible_mask) </span>
<span class="c1">//系统中有多少个CPU核可以运行</span>

<span class="cp">#define cpu_online_mask   ((const struct cpumask *)&amp;__cpu_online_mask)</span>
<span class="c1">//系统中有多少个CPU核正在运行</span>

<span class="cp">#define cpu_present_mask  ((const struct cpumask *)&amp;__cpu_present_mask)</span>
<span class="c1">//系统中有多少个正处于运行状态的CPU核。</span>

<span class="cp">#define cpu_active_mask   ((const struct cpumask *)&amp;__cpu_active_mask)</span>
<span class="c1">//系统中有多少个活跃的CPU核</span>

<span class="cp">#define cpu_dying_mask    ((const struct cpumask *)&amp;__cpu_dying_mask)</span>
<span class="c1">//系统中有多少个将死的cpu核</span>

<span class="n">如果没有CONFIG_HOTPULG_CPU</span><span class="err">，</span><span class="n">那么present</span><span class="o">=</span><span class="n">possible</span><span class="err">，</span><span class="n">active</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">online</span><span class="err">。</span>
</code></pre></div>
<div class="codehilite"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">sched_init_domains</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">cpumask</span><span class="w"> </span><span class="o">*</span><span class="n">cpu_map</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">err</span><span class="p">;</span>

<span class="w">    </span><span class="n">zalloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sched_domains_tmpmask</span><span class="p">,</span><span class="w"> </span><span class="n">GFP_KERNEL</span><span class="p">);</span>
<span class="w">    </span><span class="n">zalloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sched_domains_tmpmask2</span><span class="p">,</span><span class="w"> </span><span class="n">GFP_KERNEL</span><span class="p">);</span>
<span class="w">    </span><span class="n">zalloc_cpumask_var</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fallback_doms</span><span class="p">,</span><span class="w"> </span><span class="n">GFP_KERNEL</span><span class="p">);</span>

<span class="w">    </span><span class="n">arch_update_cpu_topology</span><span class="p">();</span>
<span class="w">    </span><span class="n">asym_cpu_capacity_scan</span><span class="p">();</span>
<span class="w">    </span><span class="n">ndoms_cur</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">doms_cur</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alloc_sched_domains</span><span class="p">(</span><span class="n">ndoms_cur</span><span class="p">);</span>
<span class="c1">//创建cpumask_var_t类型，存储用于当前调度域的可用的cpu。</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">doms_cur</span><span class="p">)</span>
<span class="w">        </span><span class="n">doms_cur</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">fallback_doms</span><span class="p">;</span>

<span class="n">cpumask_and</span><span class="p">(</span><span class="n">doms_cur</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">cpu_map</span><span class="p">,</span><span class="w"> </span><span class="n">housekeeping_cpumask</span><span class="p">(</span><span class="n">HK_FLAG_DOMAIN</span><span class="p">));</span>
<span class="c1">//cpu_map为cpu_active_mask，在active中排除掉不能用于调度域的cpu，isolcpus对某些//cpu进行的隔离，不参与调度域中，doms_cur最终保存的排除之后可用调度域的cpu。</span>

<span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">build_sched_domains</span><span class="p">(</span><span class="n">doms_cur</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>
<span class="c1">//调度域建立。</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="diemccpusdsdcsgsgc">为DIE和MC分配每CPU的sd/sdc/sg/sgc空间</h3>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">int</span>
<span class="nf">build_sched_domains</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">cpumask</span><span class="w"> </span><span class="o">*</span><span class="n">cpu_map</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_domain_attr</span><span class="w"> </span><span class="o">*</span><span class="n">attr</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">enum</span><span class="w"> </span><span class="n">s_alloc</span><span class="w"> </span><span class="n">alloc_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sa_none</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_domain</span><span class="w"> </span><span class="o">*</span><span class="n">sd</span><span class="p">;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">s_data</span><span class="w"> </span><span class="n">d</span><span class="p">;</span>
<span class="p">......</span>
<span class="w">   </span><span class="c1">//分配DIE,MC SDTL拓扑相关数据结构，初始化一个struct s_data；</span>
<span class="w">    </span><span class="n">alloc_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__visit_domain_allocation_hell</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="p">,</span><span class="w"> </span><span class="n">cpu_map</span><span class="p">);</span>
<span class="p">......</span>
<span class="p">}</span>
</code></pre></div>
<p>build_shed_domains函数中首先调用__visit_domain_allocation_hell为每个cpu分配各个调度域层级（DIE/MC）分配sd/sdc/sg/sgc。</p>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">sched_domain_topology_level</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">sched_domain_mask_f</span><span class="w"> </span><span class="n">mask</span><span class="p">;</span>
<span class="w">    </span><span class="n">sched_domain_flags_f</span><span class="w"> </span><span class="n">sd_flags</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w">         </span><span class="n">flags</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w">         </span><span class="n">numa_level</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">sd_data</span><span class="w">      </span><span class="n">data</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_SCHED_DEBUG</span>
<span class="w">    </span><span class="kt">char</span><span class="w">                </span><span class="o">*</span><span class="n">name</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="c1">//定义了一个static struct sched_domain_topology_level default_topology[]全局变量。</span>
<span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_domain_topology_level</span><span class="w"> </span><span class="n">default_topology</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="cp">#ifdef CONFIG_SCHED_SMT</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="n">cpu_smt_mask</span><span class="p">,</span><span class="w"> </span><span class="n">cpu_smt_flags</span><span class="p">,</span><span class="w"> </span><span class="n">SD_INIT_NAME</span><span class="p">(</span><span class="n">SMT</span><span class="p">)</span><span class="w"> </span><span class="p">},</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_SCHED_MC</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="n">cpu_coregroup_mask</span><span class="p">,</span><span class="w"> </span><span class="n">cpu_core_flags</span><span class="p">,</span><span class="w"> </span><span class="n">SD_INIT_NAME</span><span class="p">(</span><span class="n">MC</span><span class="p">)</span><span class="w"> </span><span class="p">},</span>
<span class="cp">#endif</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="n">cpu_cpu_mask</span><span class="p">,</span><span class="w"> </span><span class="n">SD_INIT_NAME</span><span class="p">(</span><span class="n">DIE</span><span class="p">)</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="p">},</span>
<span class="p">};</span>
</code></pre></div>
<p>内核定义了一个全局变量static struct sched_domain_topology_level default_topology[]，该变量根据宏配置调度域的层次，DIE调度域是默认开启的，往下是MC调度域，再到SMT调度域，由于ARM架构SMT调度目前见得还比较少，所以再不考虑，build_shed_domains得核心就是各层级得SDTL。</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="n">s_alloc</span>
<span class="nf">__visit_domain_allocation_hell</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">s_data</span><span class="w"> </span><span class="o">*</span><span class="n">d</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">cpumask</span><span class="w"> </span><span class="o">*</span><span class="n">cpu_map</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="n">d</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">d</span><span class="p">));</span>
<span class="c1">//为全局struct sched_domain_topology_level default_topology[]的DIE和MC分配对应的</span>
<span class="c1">//per-CPU sd/sds/sg/sgc</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">__sdt_alloc</span><span class="p">(</span><span class="n">cpu_map</span><span class="p">))</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">sa_sd_storage</span><span class="p">;</span>
<span class="c1">//为每个CPU分配了一个调度域，作用是用户存储最底层（MC）的sd，也就是每个CPU 的</span>
<span class="c1">//d-&gt;sd指向MC的sd，这只是临时分配，用于在建立sg的时候辅助使用，后续会销毁。</span>
<span class="w">    </span><span class="n">d</span><span class="o">-&gt;</span><span class="n">sd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alloc_percpu</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_domain</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">sd</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">sa_sd_storage</span><span class="p">;</span>
<span class="w">    </span><span class="c1">//分配一个rootdomain并进行初始化，主要用于rt的？</span>
<span class="w">    </span><span class="n">d</span><span class="o">-&gt;</span><span class="n">rd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alloc_rootdomain</span><span class="p">();</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">d</span><span class="o">-&gt;</span><span class="n">rd</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">sa_sd</span><span class="p">;</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">sa_rootdomain</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>__visist_domain_allocation_hell调用__sdt_alloc，分配SDTL中的struct sd_data data并进行初始化。</p>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">sd_data</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_domain</span><span class="w"> </span><span class="o">*</span><span class="n">__percpu</span><span class="w"> </span><span class="o">*</span><span class="n">sd</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_domain_shared</span><span class="w"> </span><span class="o">*</span><span class="n">__percpu</span><span class="w"> </span><span class="o">*</span><span class="n">sds</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_group</span><span class="w"> </span><span class="o">*</span><span class="n">__percpu</span><span class="w"> </span><span class="o">*</span><span class="n">sg</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_group_capacity</span><span class="w"> </span><span class="o">*</span><span class="n">__percpu</span><span class="w"> </span><span class="o">*</span><span class="n">sgc</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>sd_data的成员都是__percpu类型，需要先调用alloc_percpu分配相同大小的cpu个数区域，这些区域存储的是指针，指向每个cpu对应的sd/sds/sg/sgc，以struct sched_domain *__percpu *sd为例，sdd-&gt;sd = alloc_percpu(struct sched_domain *)分配一块指针数组，数组元素的个数为cpu核个数，sd指向这个指针数组，数组中的指针用于后续每个CPU指向分配的sd空间。</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">__sdt_alloc</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">cpumask</span><span class="w"> </span><span class="o">*</span><span class="n">cpu_map</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_domain_topology_level</span><span class="w"> </span><span class="o">*</span><span class="n">tl</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="p">;</span>
<span class="w">    </span><span class="c1">//遍历SDTL，这里有MC和DIE。</span>
<span class="w">    </span><span class="n">for_each_sd_topology</span><span class="p">(</span><span class="n">tl</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">sd_data</span><span class="w"> </span><span class="o">*</span><span class="n">sdd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tl</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
<span class="w">        </span><span class="c1">//分配当前层级调度域sd Per-CPU变量（指针数组，数组元素为cpu个数指针，下同）</span>
<span class="w">        </span><span class="n">sdd</span><span class="o">-&gt;</span><span class="n">sd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alloc_percpu</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_domain</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">sdd</span><span class="o">-&gt;</span><span class="n">sd</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="w">       </span><span class="c1">//分配当前层级sdc Per-CPU变量</span>
<span class="w">        </span><span class="n">sdd</span><span class="o">-&gt;</span><span class="n">sds</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alloc_percpu</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_domain_shared</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">sdd</span><span class="o">-&gt;</span><span class="n">sds</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="w">       </span><span class="c1">//分配当前层级sg Per-CPU变量</span>
<span class="w">        </span><span class="n">sdd</span><span class="o">-&gt;</span><span class="n">sg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alloc_percpu</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_group</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">sdd</span><span class="o">-&gt;</span><span class="n">sg</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="w">       </span><span class="c1">//分配当前层级sgc Per-CPU变量</span>
<span class="w">        </span><span class="n">sdd</span><span class="o">-&gt;</span><span class="n">sgc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alloc_percpu</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_group_capacity</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">sdd</span><span class="o">-&gt;</span><span class="n">sgc</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="w">        </span><span class="c1">//上面已经完成当前层级Per-CPU变量，下面就遍历每个cpu分配sd/sds/sg/sgc，Per-CPU</span>
<span class="c1">//遍历将一一对应指向。</span>
<span class="w">        </span><span class="n">for_each_cpu</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">cpu_map</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_domain</span><span class="w"> </span><span class="o">*</span><span class="n">sd</span><span class="p">;</span>
<span class="w">            </span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_domain_shared</span><span class="w"> </span><span class="o">*</span><span class="n">sds</span><span class="p">;</span>
<span class="w">            </span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_group</span><span class="w"> </span><span class="o">*</span><span class="n">sg</span><span class="p">;</span>
<span class="w">            </span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_group_capacity</span><span class="w"> </span><span class="o">*</span><span class="n">sgc</span><span class="p">;</span>
<span class="w">            </span><span class="n">sd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kzalloc_node</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_domain</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">cpumask_size</span><span class="p">(),</span>
<span class="w">                    </span><span class="n">GFP_KERNEL</span><span class="p">,</span><span class="w"> </span><span class="n">cpu_to_node</span><span class="p">(</span><span class="n">j</span><span class="p">));</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">sd</span><span class="p">)</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="w">            </span><span class="o">*</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">sdd</span><span class="o">-&gt;</span><span class="n">sd</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sd</span><span class="p">;</span>
<span class="w">            </span><span class="c1">//如对应cpu0来说，sdd-sd[0] = sd,sdd-sd[0]是一个指针，指向当前分配的sd空间。</span>
<span class="w">            </span><span class="n">sds</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kzalloc_node</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_domain_shared</span><span class="p">),</span>
<span class="w">                    </span><span class="n">GFP_KERNEL</span><span class="p">,</span><span class="w"> </span><span class="n">cpu_to_node</span><span class="p">(</span><span class="n">j</span><span class="p">));</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">sds</span><span class="p">)</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="w">            </span><span class="o">*</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">sdd</span><span class="o">-&gt;</span><span class="n">sds</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sds</span><span class="p">;</span>
<span class="w">            </span><span class="n">sg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kzalloc_node</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_group</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">cpumask_size</span><span class="p">(),</span>
<span class="w">                    </span><span class="n">GFP_KERNEL</span><span class="p">,</span><span class="w"> </span><span class="n">cpu_to_node</span><span class="p">(</span><span class="n">j</span><span class="p">));</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">sg</span><span class="p">)</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="w">            </span><span class="n">sg</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sg</span><span class="p">;</span>
<span class="w">            </span><span class="o">*</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">sdd</span><span class="o">-&gt;</span><span class="n">sg</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sg</span><span class="p">;</span>
<span class="w">            </span><span class="n">sgc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kzalloc_node</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_group_capacity</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">cpumask_size</span><span class="p">(),</span>
<span class="w">                    </span><span class="n">GFP_KERNEL</span><span class="p">,</span><span class="w"> </span><span class="n">cpu_to_node</span><span class="p">(</span><span class="n">j</span><span class="p">));</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">sgc</span><span class="p">)</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="w">            </span><span class="o">*</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">sdd</span><span class="o">-&gt;</span><span class="n">sgc</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sgc</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>执行完__sdt_alloc，层次结构就如下所示，如对应DIE层次，sdd-sd[0~7]分别指向各自cpu分配的sd区域。</p>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_93ac6fcf2c164a26ffc7776cbd62875a.jpg"><img alt="" src="/laumy.github.io/assets/doc/01-linux/进程调度/10-负载均衡之调度组和调度域/images/wp_editor_md_93ac6fcf2c164a26ffc7776cbd62875a.jpg"/></a></p>
<h3 id="sd">初始化调度域sd</h3>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">int</span>
<span class="nf">build_sched_domains</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">cpumask</span><span class="w"> </span><span class="o">*</span><span class="n">cpu_map</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_domain_attr</span><span class="w"> </span><span class="o">*</span><span class="n">attr</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">enum</span><span class="w"> </span><span class="n">s_alloc</span><span class="w"> </span><span class="n">alloc_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sa_none</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_domain</span><span class="w"> </span><span class="o">*</span><span class="n">sd</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">s_data</span><span class="w"> </span><span class="n">d</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">rq</span><span class="w"> </span><span class="o">*</span><span class="n">rq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">has_asym</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">    </span><span class="p">........</span>
<span class="c1">//遍历每个CPU，从下往上初始化SDTL的sd，先初始化MC再初始化DIE。</span>
<span class="c1">// DIE的sd 其child指向MC的sd，MC的sd 其parent指向DIE的sd。</span>
<span class="w">    </span><span class="n">for_each_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">cpu_map</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_domain_topology_level</span><span class="w"> </span><span class="o">*</span><span class="n">tl</span><span class="p">;</span>
<span class="w">        </span><span class="n">sd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">        </span><span class="n">for_each_sd_topology</span><span class="p">(</span><span class="n">tl</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">topology_span_sane</span><span class="p">(</span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">cpu_map</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">)))</span>
<span class="w">                </span><span class="k">goto</span><span class="w"> </span><span class="n">error</span><span class="p">;</span>
<span class="w">            </span><span class="c1">//初始化调度域</span>
<span class="w">            </span><span class="n">sd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">build_sched_domain</span><span class="p">(</span><span class="n">tl</span><span class="p">,</span><span class="w"> </span><span class="n">cpu_map</span><span class="p">,</span><span class="w"> </span><span class="n">attr</span><span class="p">,</span><span class="w"> </span><span class="n">sd</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>

<span class="w">            </span><span class="n">has_asym</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">SD_ASYM_CPUCAPACITY</span><span class="p">;</span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">sched_domain_topology</span><span class="p">)</span>
<span class="w">                </span><span class="o">*</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">d</span><span class="p">.</span><span class="n">sd</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sd</span><span class="p">;</span>
<span class="w">            </span><span class="c1">//将最低层级的sd保存到s_data.sd的per_cpu变量中，最底层为MC level的sd</span>
<span class="w">            </span><span class="c1">//为下一步建立sg做准备。</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tl</span><span class="o">-&gt;</span><span class="n">flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">SDTL_OVERLAP</span><span class="p">)</span>
<span class="w">                </span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">flags</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">SD_OVERLAP</span><span class="p">;</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cpumask_equal</span><span class="p">(</span><span class="n">cpu_map</span><span class="p">,</span><span class="w"> </span><span class="n">sched_domain_span</span><span class="p">(</span><span class="n">sd</span><span class="p">)))</span>
<span class="w">                </span><span class="k">break</span><span class="p">;</span>
<span class="w">            </span><span class="c1">//sched_domain_span(sd)用于获取给定调度域sd的范围cpu，也就是说当前调度域   </span>
<span class="c1">//中覆盖的cpu是那几个。</span>
<span class="c1">//调度域都有一个范围，表示该调度域可以管理的CPU范围，这个范围通常有一</span>
<span class="c1">//个cpumask表示，其中每个位都对应一个cpu，调度域的范围定义了该调度域影//响的cpu集合。</span>
<span class="w">        </span><span class="p">}</span>
<span class="p">}</span>
<span class="p">........</span>
<span class="p">}</span>
</code></pre></div>
<p>for_each_cpu遍历每一个cpu，接着for_each_sd_topology(tl)对每个cpu从最底层依次往上构建调度域，先构建MC再DIE。build_sched_domain中会调用sd_init对调度域进行初始化，主要是struct sched_domain结构体成员赋值，同时建立起MC与DIE层级sd的父子联系，如下对于DIE层级，每cpu的sd.child指向MC层级的sd，而MC层级sd.parent指向DIE层级的sd。在初始化调度域是会设置其span，span为调度域作用的cpu范围，实际是根据span的作用范围来对当前调度域层级进行分组。如MC层级，按照4.2.1.2的拓扑结构，有两个MC调度域名，CPU0~CPU3是一组，所以CPU0~CPU3的sd-&gt;span是相同的，CPU4~CPU7是一组，所以CPU4~CPU7的sd-&gt;span相同的。sd-&gt;span非常重要，在后续章节中也会使用该信息来建立sg之间的联系。</p>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_977a5d176cdc2259262d23e5536bbb5f.jpg"><img alt="" src="/laumy.github.io/assets/doc/01-linux/进程调度/10-负载均衡之调度组和调度域/images/wp_editor_md_977a5d176cdc2259262d23e5536bbb5f.jpg"/></a></p>
<h3 id="sg">初始化调度组sg</h3>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">int</span>
<span class="nf">build_sched_domains</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">cpumask</span><span class="w"> </span><span class="o">*</span><span class="n">cpu_map</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_domain_attr</span><span class="w"> </span><span class="o">*</span><span class="n">attr</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">enum</span><span class="w"> </span><span class="n">s_alloc</span><span class="w"> </span><span class="n">alloc_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sa_none</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_domain</span><span class="w"> </span><span class="o">*</span><span class="n">sd</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">s_data</span><span class="w"> </span><span class="n">d</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">rq</span><span class="w"> </span><span class="o">*</span><span class="n">rq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">has_asym</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="p">........</span>
<span class="w">    </span><span class="cm">/* Build the groups for the domains */</span>
<span class="n">for_each_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">cpu_map</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">//d.sd是最底层得调度域，这里是MC，即每cpu的sd</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">sd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">d</span><span class="p">.</span><span class="n">sd</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span><span class="w"> </span><span class="n">sd</span><span class="p">;</span><span class="w"> </span><span class="n">sd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">span_weight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cpumask_weight</span><span class="p">(</span><span class="n">sched_domain_span</span><span class="p">(</span><span class="n">sd</span><span class="p">));</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">SD_OVERLAP</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">build_overlap_sched_groups</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">))</span>
<span class="w">                    </span><span class="k">goto</span><span class="w"> </span><span class="n">error</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">build_sched_groups</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">))</span>
<span class="w">                    </span><span class="k">goto</span><span class="w"> </span><span class="n">error</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">........</span>
<span class="p">}</span>
</code></pre></div>
<p>for_each_cpu遍历每个cpu，for (sd = *per_cpu_ptr(d.sd, i); sd; sd = sd-&gt;parent)遍历当前cpu的调度域，从MC调度域往上开始，调用build_sched_groups构建当前调度域的调度组。</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">int</span>
<span class="nf">build_sched_groups</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_domain</span><span class="w"> </span><span class="o">*</span><span class="n">sd</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_group</span><span class="w"> </span><span class="o">*</span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">last</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">sd_data</span><span class="w"> </span><span class="o">*</span><span class="n">sdd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">cpumask</span><span class="w"> </span><span class="o">*</span><span class="n">span</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sched_domain_span</span><span class="p">(</span><span class="n">sd</span><span class="p">);</span>
<span class="c1">//获取当前调度域的cpu作用范围，对于DIE层级，span是cpu0~cpu7而对于MC层级</span>
<span class="c1">//span是core_siblings，即cpu0~cpu3或cpu4~cpu7。</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">cpumask</span><span class="w"> </span><span class="o">*</span><span class="n">covered</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>

<span class="w">    </span><span class="n">lockdep_assert_held</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sched_domains_mutex</span><span class="p">);</span>
<span class="w">    </span><span class="n">covered</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sched_domains_tmpmask</span><span class="p">;</span>

<span class="n">cpumask_clear</span><span class="p">(</span><span class="n">covered</span><span class="p">);</span>
<span class="c1">//从当前cpu开始遍历整个sd span。</span>
<span class="w">    </span><span class="n">for_each_cpu_wrap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">span</span><span class="p">,</span><span class="w"> </span><span class="n">cpu</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_group</span><span class="w"> </span><span class="o">*</span><span class="n">sg</span><span class="p">;</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">covered</span><span class="p">))</span><span class="w"> </span>
<span class="c1">//已经在coverd msk中的cpu，继续执行，与下面的cpumask_or配合，避免重复指向。</span>
<span class="w">            </span><span class="k">continue</span><span class="p">;</span>

<span class="w">        </span><span class="c1">//获取cpu i的调度组sg</span>
<span class="w">        </span><span class="n">sg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_group</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">sdd</span><span class="p">);</span>

<span class="w">        </span><span class="n">cpumask_or</span><span class="p">(</span><span class="n">covered</span><span class="p">,</span><span class="w"> </span><span class="n">covered</span><span class="p">,</span><span class="w"> </span><span class="n">sched_group_span</span><span class="p">(</span><span class="n">sg</span><span class="p">));</span>
<span class="w">        </span><span class="c1">//coverd = coverd | sched_group_span(sg)</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">first</span><span class="p">)</span>
<span class="w">            </span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sg</span><span class="p">;</span><span class="c1">//每个cpu进来的第一个sg</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">last</span><span class="p">)</span>
<span class="w">            </span><span class="n">last</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sg</span><span class="p">;</span><span class="c1">//每个sg的下一个sg</span>
<span class="w">        </span><span class="n">last</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sg</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">last</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">first</span><span class="p">;</span><span class="w"> </span><span class="c1">//最后一个sg再指向第一个sg，就形成环形链表了。</span>
<span class="w">    </span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">groups</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">first</span><span class="p">;</span><span class="w"> </span><span class="c1">//sd-&gt;groups指向第一个sg，对于MC是自己的sg</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>在MC调度域层级，根据调度域sd-&gt;span定义的cpu范围内的sg形成环形链表，下面就是两个环形链表，对应的就是MC调度域层级的两个调度域实体。 在DIE区域，sg取的是子调度域所在的第一个cpu，即cpu0所在的sg和cpu4所在的sg。</p>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_f9ca1c7f1149e85701f9b533ebdd5eab.jpg"><img alt="" src="/laumy.github.io/assets/doc/01-linux/进程调度/10-负载均衡之调度组和调度域/images/wp_editor_md_f9ca1c7f1149e85701f9b533ebdd5eab.jpg"/></a></p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_group</span><span class="w"> </span><span class="o">*</span><span class="n">get_group</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">cpu</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">sd_data</span><span class="w"> </span><span class="o">*</span><span class="n">sdd</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_domain</span><span class="w"> </span><span class="o">*</span><span class="n">sd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">sdd</span><span class="o">-&gt;</span><span class="n">sd</span><span class="p">,</span><span class="w"> </span><span class="n">cpu</span><span class="p">);</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_domain</span><span class="w"> </span><span class="o">*</span><span class="n">child</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_group</span><span class="w"> </span><span class="o">*</span><span class="n">sg</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">already_visited</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
<span class="w">        </span><span class="n">cpu</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cpumask_first</span><span class="p">(</span><span class="n">sched_domain_span</span><span class="p">(</span><span class="n">child</span><span class="p">));</span>
<span class="c1">//如果调度域存在子调度域，则cpu获取子调度域的第一个cpu，只有DIE层级才有子调度//域，所以这里是cpu0或cpu4</span>

<span class="w">    </span><span class="n">sg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">sdd</span><span class="o">-&gt;</span><span class="n">sg</span><span class="p">,</span><span class="w"> </span><span class="n">cpu</span><span class="p">);</span><span class="w"> </span><span class="c1">//获取当前层级cpu上的sg</span>
<span class="w">    </span><span class="n">sg</span><span class="o">-&gt;</span><span class="n">sgc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">sdd</span><span class="o">-&gt;</span><span class="n">sgc</span><span class="p">,</span><span class="w"> </span><span class="n">cpu</span><span class="p">);</span><span class="c1">//获取当前层级cpu上的sgc，将sg-&gt;sgc指向sgc</span>

<span class="w">    </span><span class="cm">/* Increase refcounts for claim_allocations: */</span>
<span class="w">    </span><span class="n">already_visited</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">atomic_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/* sgc visits should follow a similar trend as sg */</span>
<span class="w">    </span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">already_visited</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="p">(</span><span class="n">atomic_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sg</span><span class="o">-&gt;</span><span class="n">sgc</span><span class="o">-&gt;</span><span class="n">ref</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span>

<span class="w">    </span><span class="cm">/* If we have already visited that group, it\'s already initialized. */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">already_visited</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">sg</span><span class="p">;</span>
<span class="w">    </span><span class="c1">//如果是DIE层级</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">child</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">cpumask_copy</span><span class="p">(</span><span class="n">sched_group_span</span><span class="p">(</span><span class="n">sg</span><span class="p">),</span><span class="w"> </span><span class="n">sched_domain_span</span><span class="p">(</span><span class="n">child</span><span class="p">));</span>
<span class="w">        </span><span class="c1">//将子调度域的cpu范围赋值到调度组sg的cpu范围，子sd-&gt;span = 父sg-&gt;cpumask</span>
<span class="w">        </span><span class="n">cpumask_copy</span><span class="p">(</span><span class="n">group_balance_mask</span><span class="p">(</span><span class="n">sg</span><span class="p">),</span><span class="w"> </span><span class="n">sched_group_span</span><span class="p">(</span><span class="n">sg</span><span class="p">));</span>
<span class="w">        </span><span class="c1">//将调度组sg的cpu范围赋值到sg的平衡掩码balance mask</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span><span class="w"> </span><span class="n">sched_group_span</span><span class="p">(</span><span class="n">sg</span><span class="p">));</span>
<span class="w">        </span><span class="c1">//将cpu添加到调度组sg的cpu范围中</span>
<span class="w">        </span><span class="n">cpumask_set_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span><span class="w"> </span><span class="n">group_balance_mask</span><span class="p">(</span><span class="n">sg</span><span class="p">));</span>
<span class="w">        </span><span class="c1">//将cpu添加到调度组sg平衡掩码中</span>
<span class="w">    </span><span class="p">}</span>

<span class="n">sg</span><span class="o">-&gt;</span><span class="n">sgc</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SCHED_CAPACITY_SCALE</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cpumask_weight</span><span class="p">(</span><span class="n">sched_group_span</span><span class="p">(</span><span class="n">sg</span><span class="p">));</span>
<span class="c1">//计算调度组能力。</span>
<span class="w">    </span><span class="n">sg</span><span class="o">-&gt;</span><span class="n">sgc</span><span class="o">-&gt;</span><span class="n">min_capacity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SCHED_CAPACITY_SCALE</span><span class="p">;</span>
<span class="w">    </span><span class="n">sg</span><span class="o">-&gt;</span><span class="n">sgc</span><span class="o">-&gt;</span><span class="n">max_capacity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SCHED_CAPACITY_SCALE</span><span class="p">;</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">sg</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>MC层级基本是一个cpu对应一个调度组sg，而对于DIE层级一个cluster对应一个调度组，调度组表示一般选择每个cluster的第一个cpu，该sg代表的不是一个cpu，而是整个cluster上的cpu，所以cpu上的sg-&gt;cpumask为子调度域的sd-&gt;span。</p>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_de708bbcaf7fa6f9463cb50c1df39411.jpg"><img alt="" src="/laumy.github.io/assets/doc/01-linux/进程调度/10-负载均衡之调度组和调度域/images/wp_editor_md_de708bbcaf7fa6f9463cb50c1df39411.jpg"/></a></p>
<h3 id="sgc">构建调度组能力sgc</h3>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">int</span>
<span class="nf">build_sched_domains</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">cpumask</span><span class="w"> </span><span class="o">*</span><span class="n">cpu_map</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_domain_attr</span><span class="w"> </span><span class="o">*</span><span class="n">attr</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="p">......</span>
<span class="cm">/* Calculate CPU capacity for physical packages and nodes */</span>
<span class="c1">//遍历每个CPU，从大到小开始遍历，然后依次遍历MC到DIE，初始化sg的cpu_capacity</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nr_cpumask_bits</span><span class="mi">-1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">--</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">cpumask_test_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">cpu_map</span><span class="p">))</span>
<span class="w">            </span><span class="k">continue</span><span class="p">;</span>
<span class="w">        </span><span class="c1">//还是从底层MC开始往上遍历，初始化sgc</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">sd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">d</span><span class="p">.</span><span class="n">sd</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span><span class="w"> </span><span class="n">sd</span><span class="p">;</span><span class="w"> </span><span class="n">sd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">claim_allocations</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">sd</span><span class="p">);</span>
<span class="w">            </span><span class="n">init_sched_groups_capacity</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">sd</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="p">}</span>
<span class="p">......</span>
<span class="p">}</span>
</code></pre></div>
<p>遍历每个cpu，然后从MC层级往上到DIE层级，初始化每cpu各层级的sgc。</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">init_sched_groups_capacity</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">cpu</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_domain</span><span class="w"> </span><span class="o">*</span><span class="n">sd</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_group</span><span class="w"> </span><span class="o">*</span><span class="n">sg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">;</span>

<span class="w">    </span><span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">sg</span><span class="p">);</span>
<span class="w">    </span><span class="c1">//循环，对sg环形链表中所有的sg-&gt;group_weight进行初始化。</span>
<span class="w">    </span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">cpu</span><span class="p">,</span><span class="w"> </span><span class="n">max_cpu</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>

<span class="w">        </span><span class="n">sg</span><span class="o">-&gt;</span><span class="n">group_weight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cpumask_weight</span><span class="p">(</span><span class="n">sched_group_span</span><span class="p">(</span><span class="n">sg</span><span class="p">));</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">SD_ASYM_PACKING</span><span class="p">))</span>
<span class="w">            </span><span class="k">goto</span><span class="w"> </span><span class="n">next</span><span class="p">;</span>

<span class="w">        </span><span class="n">for_each_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span><span class="w"> </span><span class="n">sched_group_span</span><span class="p">(</span><span class="n">sg</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">max_cpu</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">                </span><span class="n">max_cpu</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cpu</span><span class="p">;</span>
<span class="w">            </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sched_asym_prefer</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span><span class="w"> </span><span class="n">max_cpu</span><span class="p">))</span>
<span class="w">                </span><span class="n">max_cpu</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cpu</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">sg</span><span class="o">-&gt;</span><span class="n">asym_prefer_cpu</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max_cpu</span><span class="p">;</span>

<span class="nl">next</span><span class="p">:</span>
<span class="w">        </span><span class="n">sg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sg</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">sg</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">groups</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cpu</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">group_balance_cpu</span><span class="p">(</span><span class="n">sg</span><span class="p">))</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>

<span class="w">    </span><span class="n">update_group_capacity</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span><span class="w"> </span><span class="n">cpu</span><span class="p">);</span><span class="w"> </span><span class="c1">//更新group 的capacity。</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="cpumcsdrootdomaincpu-rq">将每cpu的MC层级sd、rootdomain与cpu rq绑定</h3>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">int</span>
<span class="nf">build_sched_domains</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">cpumask</span><span class="w"> </span><span class="o">*</span><span class="n">cpu_map</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_domain_attr</span><span class="w"> </span><span class="o">*</span><span class="n">attr</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">......</span>
<span class="c1">//遍历每个cpu，获取最底层的调度域MC，将其与d.rd以及cpu rq绑定起来</span>
<span class="w">    </span><span class="n">for_each_cpu</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">cpu_map</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">rq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cpu_rq</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="w">        </span><span class="n">sd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">per_cpu_ptr</span><span class="p">(</span><span class="n">d</span><span class="p">.</span><span class="n">sd</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/* Use READ_ONCE()/WRITE_ONCE() to avoid load/store tearing: */</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cpu_capacity_orig</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">READ_ONCE</span><span class="p">(</span><span class="n">d</span><span class="p">.</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">max_cpu_capacity</span><span class="p">))</span>
<span class="w">            </span><span class="n">WRITE_ONCE</span><span class="p">(</span><span class="n">d</span><span class="p">.</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">max_cpu_capacity</span><span class="p">,</span><span class="w"> </span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">cpu_capacity_orig</span><span class="p">);</span>

<span class="w">        </span><span class="n">cpu_attach_domain</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">rd</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
<span class="w">    </span><span class="p">......</span>
<span class="p">}</span>
</code></pre></div>
<p>for_each_cpu遍历所有cpu，sd = *per_cpu_ptr(d.sd, i)获取的是MC层级的调度域，最后调用cpu_attach_domain进行绑定。</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">cpu_attach_domain</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_domain</span><span class="w"> </span><span class="o">*</span><span class="n">sd</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">root_domain</span><span class="w"> </span><span class="o">*</span><span class="n">rd</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">cpu</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="p">......</span>
<span class="w">    </span><span class="n">sched_domain_debug</span><span class="p">(</span><span class="n">sd</span><span class="p">,</span><span class="w"> </span><span class="n">cpu</span><span class="p">);</span>

<span class="n">rq_attach_root</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span><span class="w"> </span><span class="n">rd</span><span class="p">);</span><span class="w"> </span><span class="c1">// 将新的root domain与cpu rq绑定，rd-&gt;rd = rd。</span>

<span class="w">    </span><span class="n">tmp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">sd</span><span class="p">;</span>
<span class="w">    </span><span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">sd</span><span class="p">,</span><span class="w"> </span><span class="n">sd</span><span class="p">);</span><span class="w"> </span><span class="c1">//将新的sd与rd-&gt;sd 绑定</span>
<span class="w">    </span><span class="n">dirty_sched_domain_sysctl</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="w">    </span><span class="n">destroy_sched_domains</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>

<span class="w">    </span><span class="n">update_top_cache_domain</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>将每个cpu的MC层级的调度域sd赋值给当前cpu调度队列的rq-&gt;sd，将root domain 赋值为当前cpu调度队列的rq-&gt;rd。 总结：</p>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_4eddbc7922c08a5aa49fb18e019c2ad6.jpg"><img alt="" src="/laumy.github.io/assets/doc/01-linux/进程调度/10-负载均衡之调度组和调度域/images/wp_editor_md_4eddbc7922c08a5aa49fb18e019c2ad6.jpg"/></a></p>
<ul>
<li>根据CPU架构的层次，从下到上，分为MC层级-&gt;DIE层级，每个层级使用struct sched_domain_topology_levels（SDTL）数据结构描述。</li>
<li>考虑多核的锁竞争访问，每层级SDTL为每个cpu定义了sd/sds/sg/sgc数据结构。</li>
<li>在同一层级（如MC层级）由SOC架构（DTS描述）来确定那些是兄弟关系(core_siblings)，兄弟关系在调度域sd中使用sd-&gt;span来描述，在调度组中sg中使用sg-&gt;cpumask来描述，属于兄弟关系的cpu核属于一个调度域。DIE层级的sg-&gt;cpumask = MC层级sd-&gt;span。</li>
<li>对于MC层级来说每个cpu就是一个调度组sg，兄弟关系的sg归属为一个调度域，该调度域的sg形成一个环形链表，但不同cpu指向的环形链表首元素是不同的，首元素指向的都是自己cpu所在的sg，如cpu0的链表顺序是(0,1,2,3)，cpu1的链表顺序是(1,2,3,0)。</li>
<li>对于DIE层级来说每个cluster是一个调度组，每个调度组有多个cpu，调度组覆盖的cpu范围子调度域的cpu覆盖范围，也可以认为是每个cluster的cpu范围。同时调度组选取的是子调度域cpu范围的第一顺序cpu作为调度组，也可以认为是每个cluster的第一个cpu。</li>
<li>对于DIE层其每cpu的调度域sd.child指向下一级MC层每cpu调度域sd，而MC层其每cpu调度域sd.parent指向上一级DIE层每cpu调度域sd。</li>
<li>负载均衡时会优先从最底层级进行均衡，从下往上意味着可选择的cpu会越来越多，但是均衡的代价也会越来越大。</li>
</ul>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_72cca7be11d43af0b4877e54f6989813.jpg"><img alt="" src="/laumy.github.io/assets/doc/01-linux/进程调度/10-负载均衡之调度组和调度域/images/wp_editor_md_72cca7be11d43af0b4877e54f6989813.jpg"/></a></p></div>
  <div class="post-nav">
    <a class="prev" href="/laumy.github.io/posts/linux/负载均衡之均衡.html">← 负载均衡之均衡</a>
    <a class="next" href="/laumy.github.io/posts/linux/负载均衡之负载跟踪.html">负载均衡之负载跟踪 →</a>
  </div>
</article>

      </section>

      <aside class="right-panel">
        
      </aside>
    </main>

    <footer class="site-footer">
      <div class="container">Copyright ©2022-2025 laumy 版权所有</div>
    </footer>

    <script src="/laumy.github.io/assets/site.js"></script>
  </body>
  </html>

