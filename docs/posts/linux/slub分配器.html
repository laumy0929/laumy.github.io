<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>slub分配器 - Laumy的技术栈</title>
    <link rel="stylesheet" href="/note_page/assets/style.css">
    <!-- MathJax支持LaTeX数学公式 -->
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          ignoreHtmlClass: 'tex2jax_ignore',
          processHtmlClass: 'tex2jax_process'
        }
      };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  </head>
  <body>
    <header class="site-header">
      <div class="container">
        <a class="logo" href="/note_page/">Laumy的技术栈</a>
        <div class="search">
          <input id="search-input" type="text" placeholder="输入关键词回车搜索">
        </div>
        <div class="theme-toggle" title="切换主题" id="theme-toggle">☾</div>
        <nav class="top-nav">
          <div class="nav-item"><a href="/note_page/">首页</a></div>
        </nav>
      </div>
    </header>

    <main class="container layout">
      <aside class="left-nav">
        
        <div class="card">
          <div class="card-title">文章目录</div>
          <nav id="toc"><ul><li><a href="#_1">乒乓球的管理</a><ul><li><a href="#_2">借球</a></li><li><a href="#_3">还球</a></li><li><a href="#_4">再论借球</a></li></ul></li><li><a href="#slub">slub 基本原理</a><ul><li><a href="#slub_1">slub函数接口</a></li></ul></li><li><a href="#_5">关键数据结构</a><ul><li><a href="#_6">设计思想</a></li><li><a href="#kmem_cache">kmem_cache</a></li><li><a href="#kmem_cache_cpu">kmem_cache_cpu</a></li><li><a href="#kmem_cache_node">kmem_cache_node</a></li><li><a href="#struct-page">struct page</a></li></ul></li><li><a href="#slub_2">slub重要概念</a><ul><li><a href="#_7">对象内存组织</a></li><li><a href="#slubslub">slub的挂载和活动的slub</a></li></ul></li><li><a href="#kmem_cache_1">创建kmem_cache</a><ul></ul></li><li><a href="#slub-cache">分配slub cache</a><ul><li><a href="#_8">第一次分配</a></li><li><a href="#per-cpu-partial">从Per CPU partial中分配获取</a></li><li><a href="#node-partial">从Node Partial中获取</a></li></ul></li><li><a href="#slub-cache_1">释放slub cache</a><ul></ul></li><li><a href="#kmalloc">kmalloc</a><ul><li><a href="#_9">函数接口</a></li><li><a href="#kmalloc_1">kmalloc实现</a></li></ul></li><li><a href="#kmem_cache_2">启动阶段创建kmem_cache</a><ul></ul></li></ul></nav>
        </div>
        
      </aside>

      <section class="content">
        
<article class="card post">
  <h1>slub分配器</h1>
  <div class="meta">2023-08-13 · linux</div>
  <div class="post-content"><p>伙伴系统内存分配是以物理页面4KB为单位，但是实际使用的时候不会一下使用到4KB。实际使用中很多情况会以字节为单位。因此为了更精确的划分使用内存，linux内核在伙伴系统之上使用slab分配器来进行管理。截止目前linux内核中从最初slab发展到现在，衍生了slub，slob三种方式。Linux内核通过配置，选择其中一种。本章节主要围绕slub分配器进行说明。</p>
<h2 id="_1">乒乓球的管理</h2>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_b83b6edbd01e56ece49cfe743e233112.jpg"><img alt="" src="/note_page/assets/doc/01-linux/内存管理/slub分配器/images/wp_editor_md_b83b6edbd01e56ece49cfe743e233112.jpg"/></a></p>
<p>某公司的组织架构如上，公司划分为多个中心（事业部），各事业部再划分为多个二级部门，员工所在的部门就在各二级部门。 公司有一批数量有限的乒乓球作为全公司的公有资产，提供给员工用于日常借用。乒乓球以盒装为单位，每盒有4个，并对盒和球都进行了编号，球归还是也要与盒子对应。为了有限管理这批乒乓球，假设有如下规定： - 兵乓球被借出去需要明确知道谁借出去了，便于兵乓球资产追溯管理。 - 闲置的球能尽快收回，以便其他人能够使用，使兵乓球利用最大化。 - 员工在借用乒乓球时需要经过部门-&gt;中心-&gt;公司各级领导的审批。 当前出现一个问题，就是员工想打球的时候，每次都要跨多级走流程，时间周期比较长。好不容易有个空闲个时间想打个球，等漫长的流程走完活又来了，没时间打了，但是也不能提前先把球借了，闲置屯着，这样别人想打也打不了，每个人都这样，那实际想打球的也无球可打。 为了解决这个问题，小明同学于是设计了这么一套方案，让员工想打球的时候能够快速获得兵乓球，也让公司的球能够利用最大化。</p>
<h3 id="_2">借球</h3>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_9e6c3b47b56405bf9d41718b77bf1586.jpg"><img alt="" src="/note_page/assets/doc/01-linux/内存管理/slub分配器/images/wp_editor_md_9e6c3b47b56405bf9d41718b77bf1586.jpg"/></a></p>
<p>部门主管向公司申请一盒的球（每盒有4个），然后将球分给D同学。并将该盒乒乓球做标记，在部门内部宣导，此后谁要是向借用球，可直接从该盒从获取，自觉做好登记皆可（不再需要走漫长流程）。 有一天部门集体运动，一下子需要多个球，部门主管发现原来的一盒已经不够了，所以又向公司再借了3盒（公司以盒为单位借出，方便管理）。 <a href="http://8.134.108.235/wp-content/uploads/2023/11/wp_editor_md_2be39df509597edd968b9502698ebfca.jpg"><img alt="" src="images/wp_editor_md_2be39df509597edd968b9502698ebfca.jpg"/></a></p>
<p>1、2、3号盒球已经全部借出，所以部门没有再管理了（盒子没啥好管理的，由对应借出的同学共同保管盒子，盒子变成没人要的“孩子”），部门当前管理的是4号盒子（盒子里面还有球，如果还有谁要借，自己拿并自觉做好登记就行）。</p>
<h3 id="_3">还球</h3>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_37a62c7885bfb80d7d4d1485aaba9bb4.jpg"><img alt="" src="/note_page/assets/doc/01-linux/内存管理/slub分配器/images/wp_editor_md_37a62c7885bfb80d7d4d1485aaba9bb4.jpg"/></a></p>
<p>借球人借球时需记住自己从那个盒子里面拿的球，还球时需要找到对应的盒子还球。1号、2号、3号盒分别有人归还了球，但是还没有还满，此前的空盒子是不需要管理的，但是现在盒子里面现在有球了，那必须得管理起来了（一旦盒子非空，就需要管理起来了），直接退还给公司也不行啊，一个是盒子没还满，另外一个就是下次又有大需求量还得走流程申请慢。 所以索性部门先将这些盒子管理起来，当前部门累计球数有9个球，闲置在二级部门太多球，也不行，每个二级部门都闲置很多球，球总有耗尽的时候，就有可能其他二级部门的员工没法获得球了，于是公司做了规定，每个部门闲置的球数不能大于4个，因此只有1号和2号盒子可以继续由部门管理，而3号盒子可以不归还公司，但可以由中心先保管。 当盒子不再为空时，先由部门进行管理，当部门的球数闲置超过一定数量后，需要交给由中心管理，交给中心管理的单位也是以盒子为单位（还球的人是根据盒子编号找还球的），这样的好处就是，当有该中心的其他二级部门需要借用球是，发现部门没球了，可以先中心是否有球，如果中心有，那就从中心拿就行，不用从公司申请，这样流程虽然没这么快，但相比跟公司申请的流程也有些优化。 长期进行下去，中心可能会很多个盒子，同时有些盒子是满的（球都还完了），中心也不能由太多闲置球，否则其他中心就可能没法从公司申请到球了，所以公司规定，对中心管理的盒子数量进行了闲置，如盒子数量不能超过10个，当超过10个时，满盒子的球需要归还给公司。</p>
<h3 id="_4">再论借球</h3>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_98a78dcc581757d8149a2b91938600a3.jpg"><img alt="" src="/note_page/assets/doc/01-linux/内存管理/slub分配器/images/wp_editor_md_98a78dcc581757d8149a2b91938600a3.jpg"/></a></p>
<p>当二级部门员工进行借球时，可以从4号盒子免报备申请直接登记拿球就好，这样的借球周期是最短的。而1号和2号盒子虽也归部门管理，但是员工不能从这些盒子里面拿，为了管理效率，二级部门只开个了一个盒子的权限（免报备直接登记即可获取），所以借球只能先从4号盒子拿，当4号盒子被拿完了之后，就需要跟主管报备，看部门还没有备用，发现还有，那就将1号盒子再拿出去，此后大家就又可以从1号盒子免报备借球。当部门没有备用球了，就先问中心有没有，如果中心有，那就将先用中心的，从中心拿到的盒子就归部门管理了。如果中心也没有了，那就只能走流程从公司申请了。 <a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_e149a38e8ace7d615d04422b5acdfb2f.jpg"><img alt="" src="/note_page/assets/doc/01-linux/内存管理/slub分配器/images/wp_editor_md_e149a38e8ace7d615d04422b5acdfb2f.jpg"/></a></p>
<h2 id="slub">slub 基本原理</h2>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_d2e423fac043162af675713060eceb21.jpg"><img alt="" src="/note_page/assets/doc/01-linux/内存管理/slub分配器/images/wp_editor_md_d2e423fac043162af675713060eceb21.jpg"/></a></p>
<p>一块缓存 = n_slab，slab = m * obj，slab = k_ page。系统从伙伴系统中分配一个或多个连续的物理页组成一个slab，然后将slab切分为n个相同大小的内存（obj），提供给linux内核系统使用，这些相同obj大小组成一个集合。 可以通过cat /proc/slabinfo查看系统中slab的信息。 <a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_753fd991abca385d39baea2b4845fd88.jpg"><img alt="" src="/note_page/assets/doc/01-linux/内存管理/slub分配器/images/wp_editor_md_753fd991abca385d39baea2b4845fd88.jpg"/></a></p>
<ul>
<li>actives_objs:已经分配出去的对象数量</li>
<li>num_objs:一共有多少个对象，包含使用的和未使用的。</li>
<li>objsize:每个对象的大小是多少，单位是字节</li>
<li>objperslab:每个slab中的对象数量是多少。</li>
<li>pagesperslab:每个slab对应的page数量</li>
<li>limit/batchcount/sharedfactor：这些是可调整的参数，使用slub分配器没有使用</li>
<li>actives_slabs: 非游离状态的slab数量</li>
<li>nums_slabs:一共有多少slab</li>
<li>sharedavail:待记录</li>
</ul>
<h3 id="slub_1">slub函数接口</h3>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_563cf8c3223ffedd5adb16ad8b4866e9.jpg"><img alt="" src="/note_page/assets/doc/01-linux/内存管理/slub分配器/images/wp_editor_md_563cf8c3223ffedd5adb16ad8b4866e9.jpg"/></a></p>
<h2 id="_5">关键数据结构</h2>
<h3 id="_6">设计思想</h3>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_ee95ea2ae5680a77e1e99049f8fb2d03.jpg"><img alt="" src="/note_page/assets/doc/01-linux/内存管理/slub分配器/images/wp_editor_md_ee95ea2ae5680a77e1e99049f8fb2d03.jpg"/></a></p>
<p>为什么kmem_cache中分为每个cpu分配对应有缓存池，每个节点有对应的缓存池。每个cpu分配的缓存池又再划分为当前正在使用的缓存slab，以及备用缓存slab（Per-CPU partial）？ <a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_dc364d8ab10a4fb7dfbff038f2e95dea.jpg"><img alt="" src="/note_page/assets/doc/01-linux/内存管理/slub分配器/images/wp_editor_md_dc364d8ab10a4fb7dfbff038f2e95dea.jpg"/></a></p>
<p>访问Per-CPU slab是不需要加锁的，所以获取速度很快。访问node slab是需要加锁的，因为这是多个cpu共享的slab，访问速度慢。 而中间的Partial slab是方便Current slab的，系统分配slab必须要从current slab中分区对象，当current slab对象使用完时，就会从依次L2从L3中获取新的slab变成Per-CPU current。因为L3是需要加锁，为了进一步解决这速率问题，中间加了Per-CPU partial slab，当Per-CPU current slab中的所有对象被分配完后将会被移除变成游离状态，而当系统释放当前处理游离状态的full slab中对象时其就会变成部分full 对象的slab，其会被再次从游离状态添加到链表中等待系统从中分配，因此这个slab就会被添加到Partial slab链表中，当下次current slab中没有可用对象时，再将其Partial 链表中的slab置为current slab，这样就不用从Node Partial slab中获取，减少锁的使用，提高系统使用率。</p>
<h3 id="kmem_cache">kmem_cache</h3>
<p>struct kmem_cache是管理slub分配器的的基础数据结构。</p>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">kmem_cache</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">kmem_cache_cpu</span><span class="w"> </span><span class="n">__percpu</span><span class="w"> </span><span class="o">*</span><span class="n">cpu_slab</span><span class="p">;</span><span class="w"> </span><span class="n">一个cpu对应一个本地内存缓存池</span><span class="w">    </span>
<span class="w">    </span><span class="n">slab_flags_t</span><span class="w"> </span><span class="n">flags</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">min_partial</span><span class="p">;</span><span class="w"> </span><span class="n">限制struct</span><span class="w"> </span><span class="n">kmem_cache_node中partial链表slab的数量</span><span class="err">，</span><span class="n">如果slab数量超过这个值</span><span class="err">，</span><span class="n">那么多余的slab需要被释放会伙伴系统</span><span class="err">。</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w">  </span><span class="n">分配object的大小</span><span class="err">，</span><span class="n">包含一些管理数据</span><span class="err">。</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">object_size</span><span class="p">;</span><span class="w"> </span><span class="n">object对象的内存大小</span><span class="err">，</span><span class="n">用户层每次分配大小</span><span class="err">。</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">reciprocal_value</span><span class="w"> </span><span class="n">reciprocal_size</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">offset</span><span class="p">;</span><span class="w">  </span><span class="n">用于寻找object的地址</span>
<span class="cp">#ifdef CONFIG_SLUB_CPU_PARTIAL</span>
<span class="w">    </span><span class="cm">/* Number of per cpu partial objects to keep around */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">cpu_partial</span><span class="p">;</span><span class="w"> </span><span class="n">每CPU中slab的空闲对象最大值</span><span class="err">，</span><span class="n">当超过这个值</span><span class="err">，</span><span class="n">需要将slab转移到kmem_cache_node的partial链表</span>
<span class="cp">#endif</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">kmem_cache_order_objects</span><span class="w"> </span><span class="n">oo</span><span class="p">;</span><span class="w"> </span><span class="n">低16代表一个slab中的object数量</span><span class="err">，</span><span class="n">高16代表一个slab需要多个page数量</span><span class="err">。</span>
<span class="w">    </span><span class="cm">/* Allocation and freeing of slabs */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">kmem_cache_order_objects</span><span class="w"> </span><span class="n">max</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">kmem_cache_order_objects</span><span class="w"> </span><span class="n">min</span><span class="p">;</span>
<span class="w">    </span><span class="n">gfp_t</span><span class="w"> </span><span class="n">allocflags</span><span class="p">;</span><span class="w">   </span><span class="cm">/* gfp flags to use on each alloc */</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">refcount</span><span class="p">;</span><span class="w">       </span><span class="cm">/* Refcount for slab cache destroy */</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">ctor</span><span class="p">)(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">inuse</span><span class="p">;</span><span class="w">     </span><span class="cm">/* Offset to metadata */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">align</span><span class="p">;</span><span class="w">     </span><span class="cm">/* Alignment */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">red_left_pad</span><span class="p">;</span><span class="w">  </span><span class="cm">/* Left redzone padding size */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p">;</span><span class="w">   </span><span class="cm">/* Name (only for display!) */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w"> </span><span class="n">list</span><span class="p">;</span><span class="w">  </span><span class="cm">/* List of slab caches */</span>
<span class="cp">#ifdef CONFIG_SYSFS</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">kobject</span><span class="w"> </span><span class="n">kobj</span><span class="p">;</span><span class="w">    </span><span class="cm">/* For sysfs */</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_SLAB_FREELIST_HARDENED</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">random</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_NUMA</span>
<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Defragmentation by allocating from a remote node.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">remote_node_defrag_ratio</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_SLAB_FREELIST_RANDOM</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">random_seq</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_KASAN</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">kasan_cache</span><span class="w"> </span><span class="n">kasan_info</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">useroffset</span><span class="p">;</span><span class="w">    </span><span class="cm">/* Usercopy region offset */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">usersize</span><span class="p">;</span><span class="w">      </span><span class="cm">/* Usercopy region size */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">kmem_cache_node</span><span class="w"> </span><span class="o">*</span><span class="n">node</span><span class="p">[</span><span class="n">MAX_NUMNODES</span><span class="p">];</span><span class="n">NUMA系统中</span><span class="err">，</span><span class="n">每个node都有一个slab缓存池</span><span class="err">。</span>
<span class="p">};</span>
</code></pre></div>
<h3 id="kmem_cache_cpu">kmem_cache_cpu</h3>
<p>每个cpu都有个自己的slab缓存池，使用struct kmem_cache_cpu来描述每个cpu自己所属的缓存池.</p>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">kmem_cache_cpu</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">**</span><span class="n">freelist</span><span class="p">;</span><span class="w">    </span><span class="n">指向下一个可用的object地址</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">tid</span><span class="p">;</span><span class="w">  </span><span class="cm">/* Globally unique transaction id */</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">page</span><span class="w"> </span><span class="o">*</span><span class="n">page</span><span class="p">;</span><span class="w">  </span><span class="n">指向当前正在使用的slab地址</span><span class="err">，</span><span class="n">只有一个slab</span><span class="err">。</span><span class="n">复用struct</span><span class="w"> </span><span class="n">page来描述一个slab</span>
<span class="cp">#ifdef CONFIG_SLUB_CPU_PARTIAL</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">page</span><span class="w"> </span><span class="o">*</span><span class="n">partial</span><span class="p">;</span><span class="w"> </span><span class="n">指向slab中只有一部分空闲object的地址</span><span class="err">，</span><span class="n">可能存在多个部分空闲对象的slab</span><span class="err">，</span><span class="n">slab直接通过struct</span><span class="w"> </span><span class="n">page中的next链表进行串联起来</span><span class="err">。</span>
<span class="n">与上一个的区别</span><span class="err">：</span><span class="n">这是一个slab集合</span><span class="err">，</span><span class="n">而上一个只有一个slab</span><span class="err">，</span><span class="n">表示正在使用的slab</span><span class="w"> </span><span class="err">，</span><span class="n">当正在使用的slab中object对象全部用完后</span><span class="err">，</span><span class="n">就会变成一个full</span><span class="w"> </span><span class="n">slab将会被游离出去</span><span class="err">，</span><span class="n">而当slab中某个object被释放后</span><span class="err">，</span><span class="n">就变成了存在部分空闲对象的slab</span><span class="err">，</span><span class="n">这个slab将会被重新被添加到partial中去</span><span class="err">。</span>
<span class="cp">#endif</span>
<span class="w">    </span><span class="n">local_lock_t</span><span class="w"> </span><span class="n">lock</span><span class="p">;</span><span class="w">  </span><span class="cm">/* Protects the fields above */</span>
<span class="cp">#ifdef CONFIG_SLUB_STATS</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">stat</span><span class="p">[</span><span class="n">NR_SLUB_STAT_ITEMS</span><span class="p">];</span>
<span class="cp">#endif</span>
<span class="p">};</span>
</code></pre></div>
<h3 id="kmem_cache_node">kmem_cache_node</h3>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">kmem_cache_node</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">spinlock_t</span><span class="w"> </span><span class="n">list_lock</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_SLUB</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">nr_partial</span><span class="p">;</span><span class="w">  </span><span class="n">节点中slab的数量</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w"> </span><span class="n">partial</span><span class="p">;</span><span class="w">    </span><span class="n">用于将各个slab串起来的链表</span>
<span class="cp">#ifdef CONFIG_SLUB_DEBUG</span>
<span class="w">    </span><span class="n">atomic_long_t</span><span class="w"> </span><span class="n">nr_slabs</span><span class="p">;</span>
<span class="w">    </span><span class="n">atomic_long_t</span><span class="w"> </span><span class="n">total_objects</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w"> </span><span class="n">full</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="cp">#endif</span>
<span class="p">};</span>
</code></pre></div>
<h3 id="struct-page">struct page</h3>
<p>复用struct page结构体来描述slub。</p>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">page</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">flags</span><span class="p">;</span><span class="w"> </span><span class="n">设置标志位</span><span class="err">，</span><span class="n">PG_slab</span><span class="err">，</span><span class="n">表示页属于SLUB内存管理器</span>
<span class="w">    </span><span class="k">union</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w">    </span><span class="cm">/* slab, slob and slub */</span>
<span class="w">            </span><span class="k">union</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w"> </span><span class="n">slab_list</span><span class="p">;</span><span class="w">  </span><span class="n">用于将slab添加到partial部分空闲链表</span>
<span class="w">                </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w">    </span><span class="cm">/* Partial pages */</span>
<span class="w">                    </span><span class="k">struct</span><span class="w"> </span><span class="nc">page</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="w">                    </span><span class="kt">int</span><span class="w"> </span><span class="n">pages</span><span class="p">;</span><span class="w">  </span><span class="cm">/* Nr of pages left */</span>
<span class="w">                    </span><span class="kt">int</span><span class="w"> </span><span class="n">pobjects</span><span class="p">;</span><span class="w">   </span><span class="cm">/* Approximate count */</span>
<span class="w">                </span><span class="p">};</span>
<span class="w">            </span><span class="p">};</span>
<span class="w">            </span><span class="k">struct</span><span class="w"> </span><span class="nc">kmem_cache</span><span class="w"> </span><span class="o">*</span><span class="n">slab_cache</span><span class="p">;</span><span class="w"> </span><span class="cm">/* not slob */</span><span class="n">索引page所所属的kmem_cache</span>
<span class="w">            </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">freelist</span><span class="p">;</span><span class="w">     </span><span class="cm">/* first free object */</span><span class="w"> </span><span class="n">指向slab中第一个空闲对象</span>
<span class="w">            </span><span class="k">union</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">s_mem</span><span class="p">;</span><span class="w">    </span><span class="cm">/* slab: first object */</span>
<span class="w">                </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">counters</span><span class="p">;</span><span class="w">     </span><span class="cm">/* SLUB */</span>
<span class="w">                </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span><span class="w">            </span><span class="cm">/* SLUB */</span>
<span class="w">                    </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">inuse</span><span class="o">:</span><span class="mi">16</span><span class="p">;</span><span class="w">   </span><span class="n">当前slab已分配对象的数量</span>
<span class="w">                    </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">objects</span><span class="o">:</span><span class="mi">15</span><span class="p">;</span><span class="w">  </span><span class="n">当slab所包含对象的总数</span>
<span class="w">                    </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">frozen</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span><span class="w">    </span><span class="n">slab是否缓存到Per</span><span class="o">-</span><span class="n">CPU缓存池</span><span class="err">（</span><span class="n">冻结</span><span class="err">），</span>
<span class="w">                </span><span class="p">};</span>
<span class="w">            </span><span class="p">};</span>
<span class="w">        </span><span class="p">};</span><span class="w">   </span>
<span class="p">}</span><span class="w"> </span><span class="n">_struct_page_alignment</span><span class="p">;</span>
</code></pre></div>
<h2 id="slub_2">slub重要概念</h2>
<p>内核中通过一下配置来使能SLUB内存管理。</p>
<div class="codehilite"><pre><span></span><code><span class="n">CONFIG_SLUB_DEBUG</span><span class="o">=</span><span class="n">y</span>
<span class="n">CONFIG_SLUB</span><span class="o">=</span><span class="n">y</span>
<span class="n">CONFIG_SLAB_MERGE_DEFAULT</span><span class="o">=</span><span class="n">y</span>
<span class="n">CONFIG_SLUB_CPU_PARTIAL</span><span class="o">=</span><span class="n">y</span>
<span class="n">CONFIG_MEMCG_KMEM</span><span class="o">=</span><span class="n">y</span>
<span class="cp"># CONFIG_SLAB_FREELIST_RANDOM is not set</span>
<span class="cp"># CONFIG_SLAB_FREELIST_HARDENED is not set</span>
</code></pre></div>
<h3 id="_7">对象内存组织</h3>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_2ca3c317e5c0470a5c218235e6d78430.jpg"><img alt="" src="/note_page/assets/doc/01-linux/内存管理/slub分配器/images/wp_editor_md_2ca3c317e5c0470a5c218235e6d78430.jpg"/></a></p>
<p>对象的内部组织如上，有两种布局方式，主要区别是指向下一个空闲对象的指针存储方式不同。当flags设置了SLAB_TYPESAFE_BY_RCU/SLAB_POISON/ctor构造函数不为空则使用第一种方式，即下一个空闲对象的指针放到当前空闲对象的末端，占据8个字节（64bit）空间；反之使用第二种方式，复用当前对象的空间，存放下一个对象的地址再起始地址。 同时如果使能了CONFIG_SLUB_DEBUG，对象内部的布局会新增用于跟踪分配/释放的用户，便于调试。下面是4个对象的示意图。 <a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_4d9e3578cf11cd8278a717e86c3ed8e3.jpg"><img alt="" src="/note_page/assets/doc/01-linux/内存管理/slub分配器/images/wp_editor_md_4d9e3578cf11cd8278a717e86c3ed8e3.jpg"/></a></p>
<p>struct kmem_cache_cpu::freelist和struct page::freelist这两个都是用于指向第一个空闲对象的地址，其中struct page * page-&gt;freelist指向内存节点空闲链表slab中的第一个空闲对象，当这个slab被设置为活动slab后，表示当前该slab正在被使用，page-&gt;frozen=1，表示已经处于冻结，那么page-&gt;freelist=NULL，slab中第一个空闲对象地址被存放到cpu_slab-&gt;freelist中。在分配对象时，值需要将当前freelist地址返回，让后将freelist地址更新到下一个空闲对象的起始地址即可。</p>
<h3 id="slubslub">slub的挂载和活动的slub</h3>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_ab55dab03ebfd37d374b79213d8b0499.jpg"><img alt="" src="/note_page/assets/doc/01-linux/内存管理/slub分配器/images/wp_editor_md_ab55dab03ebfd37d374b79213d8b0499.jpg"/></a></p>
<p>系统中的Slub的可以认为被挂载在4个地方： - 正在使用的slub（只有一个slub）：cpu_slab-&gt;page指向的slub。 - Per-CPU partial上的slub：cpu_slab-&gt;partial指向的slub，用链表组织起来，可以存在多个。 - Node节点partial的slub：node-&gt;partial指向的slub，用链表组织起来，每个节点对应一个链表，每个链表有可以多个slub。 - 游离状态的slub：前三种slub中的至少还有有部分对象未被使用，处于空闲，当slub中所有对象都被用完时，将会移除，相当于游离状态，如果打开了SLUB_DEBUG，这些slub会被串到链表上。 分配内存对象，都是从kmem_cache中cpu_slab-&gt;freelist上获取，该slub为正在使用的slub，也称为活动的slub（自己命名的），即使当cpu_slab-&gt;freelist为空或者cpu_slab-&gt;page为空，从Per-CPU partial或者Node partial中获取slub时，其就会被设置为活动的slub。</p>
<h2 id="kmem_cache_1">创建kmem_cache</h2>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_52b81791e52f98324a09dde1981ec659.jpg"><img alt="" src="/note_page/assets/doc/01-linux/内存管理/slub分配器/images/wp_editor_md_52b81791e52f98324a09dde1981ec659.jpg"/></a></p>
<h2 id="slub-cache">分配slub cache</h2>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_b50834f2fd4279793ca5cc8f3e1fc692.jpg"><img alt="" src="/note_page/assets/doc/01-linux/内存管理/slub分配器/images/wp_editor_md_b50834f2fd4279793ca5cc8f3e1fc692.jpg"/></a></p>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_d77ea0917008dc2a2524637c3ae93d2b.jpg"><img alt="" src="/note_page/assets/doc/01-linux/内存管理/slub分配器/images/wp_editor_md_d77ea0917008dc2a2524637c3ae93d2b.jpg"/></a></p>
<h3 id="_8">第一次分配</h3>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_2603a9a69067421499455acbc63aaf20.jpg"><img alt="" src="/note_page/assets/doc/01-linux/内存管理/slub分配器/images/wp_editor_md_2603a9a69067421499455acbc63aaf20.jpg"/></a></p>
<p>Slub刚创建的时候并没有实际分配内存，所以kmem_cache中无论时cpu_slab还是node节点中，都没有slab缓存，第一次申请的时候会从伙伴系统分配页面生成一个slab，然后取其中一个object返回给系统。此后，在没有分配完成当前slab中的object时，分配内存直接返回freelist就是对应的空闲object内存。</p>
<h3 id="per-cpu-partial">从Per CPU partial中分配获取</h3>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_5f2df8f679ae53aea0691957fd0c0fff.jpg"><img alt="" src="/note_page/assets/doc/01-linux/内存管理/slub分配器/images/wp_editor_md_5f2df8f679ae53aea0691957fd0c0fff.jpg"/></a></p>
<p>从当前活动的slab中无法分配到object，那就从Per CPU partial上进行获取一个slab进行分配，设置为活动的slab，此前的活动的slab就会被游离出去（full slab，如果开了SLUB DEBUG，会添加到这个debug链表中，如果没有开，就相当于没有要的孩子，当释放对象的时候会通过对应的slab描述符号相关成员找出来。）。</p>
<h3 id="node-partial">从Node Partial中获取</h3>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_756f8a15f366411f8fd704ebbb01d228.jpg"><img alt="" src="/note_page/assets/doc/01-linux/内存管理/slub分配器/images/wp_editor_md_756f8a15f366411f8fd704ebbb01d228.jpg"/></a></p>
<p>如果从Per CPU partial中依旧没法后去到slab，就会从node partial中获取slab，然后将其设置为活动的slab，此前活动的slab设置为游离状态。</p>
<h2 id="slub-cache_1">释放slub cache</h2>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_bbea0b0ab5250e02cc835b66b3c86ee0.jpg"><img alt="" src="/note_page/assets/doc/01-linux/内存管理/slub分配器/images/wp_editor_md_bbea0b0ab5250e02cc835b66b3c86ee0.jpg"/></a></p>
<ul>
<li>Slab中对象部分被使用（非游离）：① ② ③场景 （1）释放了obj后，slab中还存在部分obj未释放：直接释放，建立好空闲obj之间的联系即可。 （2）释放了obj后，slab所有的obj都为空闲：如果在node partial上，nr_partial&gt;min_partial,表明节点上存在的slab数量超过上限，空闲的slab会回收到伙伴系统中；如果是在Per-CPU partial上，管理的slab中空闲object数量大于cpu_partial（kmem_cache成员），将该slab移动到node partial链表上管理。</li>
<li>Slab中对象全部被使用（游离）：④⑤场景 释放了obj之后，slab变成部分空闲的slab，由于此前是处于游离状态，没有添加到对应链表管理（未开SLUB DEBUG），当变成部分空闲是，就需要将其进行管理。首先尝试将slab添加到Per-CPU partial中，如果Per-CPU超过阈值没法管理了，就添加到Node parital中。</li>
</ul>
<h2 id="kmalloc">kmalloc</h2>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_b9b1b588d8745f1f452b8a5b0b39e786.jpg"><img alt="" src="/note_page/assets/doc/01-linux/内存管理/slub分配器/images/wp_editor_md_b9b1b588d8745f1f452b8a5b0b39e786.jpg"/></a></p>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_1be9df4d345344549521c4f9dead6fd7.jpg"><img alt="" src="/note_page/assets/doc/01-linux/内存管理/slub分配器/images/wp_editor_md_1be9df4d345344549521c4f9dead6fd7.jpg"/></a></p>
<h3 id="_9">函数接口</h3>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_9cce9a90fb4ee93f4147df74d9b3f5fd.jpg"><img alt="" src="/note_page/assets/doc/01-linux/内存管理/slub分配器/images/wp_editor_md_9cce9a90fb4ee93f4147df74d9b3f5fd.jpg"/></a></p>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_83a00cef0ca52ab3aa3819e0a41794d4.jpg"><img alt="" src="/note_page/assets/doc/01-linux/内存管理/slub分配器/images/wp_editor_md_83a00cef0ca52ab3aa3819e0a41794d4.jpg"/></a></p>
<h3 id="kmalloc_1">kmalloc实现</h3>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="n">__always_inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">kmalloc</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">gfp_t</span><span class="w"> </span><span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="mf">1.</span><span class="n">判断参数是否为常数</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">__builtin_constant_p</span><span class="p">(</span><span class="n">size</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="cp">#ifndef CONFIG_SLOB</span>
<span class="w">        </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">KMALLOC_MAX_CACHE_SIZE</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">kmalloc_large</span><span class="p">(</span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span>
<span class="cp">#ifndef CONFIG_SLOB</span>
<span class="w">        </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kmalloc_index</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">index</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">ZERO_SIZE_PTR</span><span class="p">;</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">kmem_cache_alloc_trace</span><span class="p">(</span>
<span class="w">                </span><span class="n">kmalloc_caches</span><span class="p">[</span><span class="n">kmalloc_type</span><span class="p">(</span><span class="n">flags</span><span class="p">)][</span><span class="n">index</span><span class="p">],</span>
<span class="w">                </span><span class="n">flags</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="w">    </span><span class="p">}</span>
<span class="k">return</span><span class="w"> </span><span class="n">__kmalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span>
<span class="mf">2.</span><span class="n">直接走这里</span>
<span class="p">}</span>
</code></pre></div>
<div class="codehilite"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="nf">__kmalloc</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">gfp_t</span><span class="w"> </span><span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">kmem_cache</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">ret</span><span class="p">;</span>
<span class="w">    </span><span class="mf">1.</span><span class="n">如果分配空间大于KMALLOC_MAX_CACHE_SIZE</span><span class="err">，</span><span class="n">直接从伙伴系统进行分配</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">KMALLOC_MAX_CACHE_SIZE</span><span class="p">))</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">kmalloc_large</span><span class="p">(</span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span>
<span class="mf">2.</span><span class="n">创建slab的数据结构</span><span class="err">，</span><span class="n">实际上建立的是全局kmem_cache</span>
<span class="w">    </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kmalloc_slab</span><span class="p">(</span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ZERO_OR_NULL_PTR</span><span class="p">(</span><span class="n">s</span><span class="p">)))</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="w">    </span><span class="mf">3.</span><span class="n">slab分配器</span>
<span class="w">    </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">slab_alloc</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">,</span><span class="w"> </span><span class="n">_RET_IP_</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">);</span>

<span class="w">    </span><span class="n">trace_kmalloc</span><span class="p">(</span><span class="n">_RET_IP_</span><span class="p">,</span><span class="w"> </span><span class="n">ret</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span>

<span class="w">    </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kasan_kmalloc</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">ret</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">kmem_cache</span><span class="w"> </span><span class="o">*</span><span class="n">kmalloc_slab</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">gfp_t</span><span class="w"> </span><span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">kmem_cache</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">192</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">size</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">ZERO_SIZE_PTR</span><span class="p">;</span>
<span class="mf">1.</span><span class="n">根据分配大小找到对应的index系数</span><span class="err">，</span><span class="n">用于后续查找对应的kmem_cache</span>
<span class="w">        </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">size_index</span><span class="p">[</span><span class="n">size_index_elem</span><span class="p">(</span><span class="n">size</span><span class="p">)];</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">WARN_ON_ONCE</span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">KMALLOC_MAX_CACHE_SIZE</span><span class="p">))</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span>
<span class="w">        </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fls</span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">trace_android_vh_kmalloc_slab</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="w">    </span><span class="mf">2.</span><span class="n">在全局kmalloc_caches数组中找到对应的kmem_cache示例返回</span><span class="err">。</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">kmalloc_caches</span><span class="p">[</span><span class="n">kmalloc_type</span><span class="p">(</span><span class="n">flags</span><span class="p">)][</span><span class="n">index</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="n">u8</span><span class="w"> </span><span class="n">size_index</span><span class="p">[</span><span class="mi">24</span><span class="p">]</span><span class="w"> </span><span class="n">__ro_after_init</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="mi">3</span><span class="p">,</span><span class="w">  </span><span class="cm">/* 8 */</span>
<span class="w">    </span><span class="mi">4</span><span class="p">,</span><span class="w">  </span><span class="cm">/* 16 */</span>
<span class="w">    </span><span class="mi">5</span><span class="p">,</span><span class="w">  </span><span class="cm">/* 24 */</span>
<span class="w">    </span><span class="mi">5</span><span class="p">,</span><span class="w">  </span><span class="cm">/* 32 */</span>
<span class="w">    </span><span class="mi">6</span><span class="p">,</span><span class="w">  </span><span class="cm">/* 40 */</span>
<span class="w">    </span><span class="mi">6</span><span class="p">,</span><span class="w">  </span><span class="cm">/* 48 */</span>
<span class="w">    </span><span class="mi">6</span><span class="p">,</span><span class="w">  </span><span class="cm">/* 56 */</span>
<span class="w">    </span><span class="mi">6</span><span class="p">,</span><span class="w">  </span><span class="cm">/* 64 */</span>
<span class="w">    </span><span class="mi">1</span><span class="p">,</span><span class="w">  </span><span class="cm">/* 72 */</span>
<span class="w">    </span><span class="mi">1</span><span class="p">,</span><span class="w">  </span><span class="cm">/* 80 */</span>
<span class="w">    </span><span class="mi">1</span><span class="p">,</span><span class="w">  </span><span class="cm">/* 88 */</span>
<span class="w">    </span><span class="mi">1</span><span class="p">,</span><span class="w">  </span><span class="cm">/* 96 */</span>
<span class="w">    </span><span class="mi">7</span><span class="p">,</span><span class="w">  </span><span class="cm">/* 104 */</span>
<span class="w">    </span><span class="mi">7</span><span class="p">,</span><span class="w">  </span><span class="cm">/* 112 */</span>
<span class="w">    </span><span class="mi">7</span><span class="p">,</span><span class="w">  </span><span class="cm">/* 120 */</span>
<span class="w">    </span><span class="mi">7</span><span class="p">,</span><span class="w">  </span><span class="cm">/* 128 */</span>
<span class="w">    </span><span class="mi">2</span><span class="p">,</span><span class="w">  </span><span class="cm">/* 136 */</span>
<span class="w">    </span><span class="mi">2</span><span class="p">,</span><span class="w">  </span><span class="cm">/* 144 */</span>
<span class="w">    </span><span class="mi">2</span><span class="p">,</span><span class="w">  </span><span class="cm">/* 152 */</span>
<span class="w">    </span><span class="mi">2</span><span class="p">,</span><span class="w">  </span><span class="cm">/* 160 */</span>
<span class="w">    </span><span class="mi">2</span><span class="p">,</span><span class="w">  </span><span class="cm">/* 168 */</span>
<span class="w">    </span><span class="mi">2</span><span class="p">,</span><span class="w">  </span><span class="cm">/* 176 */</span>
<span class="w">    </span><span class="mi">2</span><span class="p">,</span><span class="w">  </span><span class="cm">/* 184 */</span>
<span class="w">    </span><span class="mi">2</span><span class="w">   </span><span class="cm">/* 192 */</span>
<span class="p">};</span>
</code></pre></div>
<h2 id="kmem_cache_2">启动阶段创建kmem_cache</h2>
<p>系统启动初期调用create_kmalloc_caches创建多个管理不同大小对应的kmem_cache，最大的size一般是8K，也就是对应的是kmalloc-8192，当系统通过kmalloc申请内存时，会直接从其中获取。</p>
<div class="codehilite"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="n">__init</span><span class="w"> </span><span class="nf">create_kmalloc_caches</span><span class="p">(</span><span class="n">slab_flags_t</span><span class="w"> </span><span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">    </span><span class="k">enum</span><span class="w"> </span><span class="n">kmalloc_cache_type</span><span class="w"> </span><span class="n">type</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">android_kmalloc_64_create</span><span class="p">)</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">KMALLOC_NORMAL</span><span class="p">;</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">KMALLOC_RECLAIM</span><span class="p">;</span><span class="w"> </span><span class="n">type</span><span class="o">++</span><span class="p">)</span>
<span class="w">            </span><span class="n">new_kmalloc_cache</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Including KMALLOC_CGROUP if CONFIG_MEMCG_KMEM defined</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">KMALLOC_NORMAL</span><span class="p">;</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">KMALLOC_RECLAIM</span><span class="p">;</span><span class="w"> </span><span class="n">type</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">KMALLOC_SHIFT_LOW</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">KMALLOC_SHIFT_HIGH</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">kmalloc_caches</span><span class="p">[</span><span class="n">type</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
<span class="w">                </span><span class="n">new_kmalloc_cache</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span>

<span class="w">            </span><span class="cm">/*</span>
<span class="cm">             * Caches that are not of the two-to-the-power-of size.</span>
<span class="cm">             * These have to be created immediately after the</span>
<span class="cm">             * earlier power of two caches</span>
<span class="cm">             */</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">KMALLOC_MIN_SIZE</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">32</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">                    </span><span class="o">!</span><span class="n">kmalloc_caches</span><span class="p">[</span><span class="n">type</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
<span class="w">                </span><span class="n">new_kmalloc_cache</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">KMALLOC_MIN_SIZE</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">64</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">                    </span><span class="o">!</span><span class="n">kmalloc_caches</span><span class="p">[</span><span class="n">type</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>
<span class="w">                </span><span class="n">new_kmalloc_cache</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/* Kmalloc array is now usable */</span>
<span class="w">    </span><span class="n">slab_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UP</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_ZONE_DMA</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">KMALLOC_SHIFT_HIGH</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">kmem_cache</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kmalloc_caches</span><span class="p">[</span><span class="n">KMALLOC_NORMAL</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">kmalloc_caches</span><span class="p">[</span><span class="n">KMALLOC_DMA</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">create_kmalloc_cache</span><span class="p">(</span>
<span class="w">                </span><span class="n">kmalloc_info</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">[</span><span class="n">KMALLOC_DMA</span><span class="p">],</span>
<span class="w">                </span><span class="n">kmalloc_info</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">,</span>
<span class="w">                </span><span class="n">SLAB_CACHE_DMA</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">flags</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">                </span><span class="n">kmalloc_info</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="cp">#endif</span>
<span class="p">}</span>
</code></pre></div>
<div class="codehilite"><pre><span></span><code><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">kmalloc_info_struct</span><span class="w"> </span><span class="n">kmalloc_info</span><span class="p">[]</span><span class="w"> </span><span class="n">__initconst</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">INIT_KMALLOC_INFO</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span>
<span class="w">    </span><span class="n">INIT_KMALLOC_INFO</span><span class="p">(</span><span class="mi">96</span><span class="p">,</span><span class="w"> </span><span class="mi">96</span><span class="p">),</span>
<span class="w">    </span><span class="n">INIT_KMALLOC_INFO</span><span class="p">(</span><span class="mi">192</span><span class="p">,</span><span class="w"> </span><span class="mi">192</span><span class="p">),</span>
<span class="w">    </span><span class="n">INIT_KMALLOC_INFO</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">),</span>
<span class="w">    </span><span class="n">INIT_KMALLOC_INFO</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">),</span>
<span class="w">    </span><span class="n">INIT_KMALLOC_INFO</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="p">),</span>
<span class="w">    </span><span class="n">INIT_KMALLOC_INFO</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span><span class="w"> </span><span class="mi">64</span><span class="p">),</span>
<span class="w">    </span><span class="n">INIT_KMALLOC_INFO</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="p">),</span>
<span class="w">    </span><span class="n">INIT_KMALLOC_INFO</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span><span class="w"> </span><span class="mi">256</span><span class="p">),</span>
<span class="w">    </span><span class="n">INIT_KMALLOC_INFO</span><span class="p">(</span><span class="mi">512</span><span class="p">,</span><span class="w"> </span><span class="mi">512</span><span class="p">),</span>
<span class="w">    </span><span class="n">INIT_KMALLOC_INFO</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="n">k</span><span class="p">),</span>
<span class="w">    </span><span class="n">INIT_KMALLOC_INFO</span><span class="p">(</span><span class="mi">2048</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="n">k</span><span class="p">),</span>
<span class="w">    </span><span class="n">INIT_KMALLOC_INFO</span><span class="p">(</span><span class="mi">4096</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="n">k</span><span class="p">),</span>
<span class="w">    </span><span class="n">INIT_KMALLOC_INFO</span><span class="p">(</span><span class="mi">8192</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="n">k</span><span class="p">),</span>
<span class="w">    </span><span class="n">INIT_KMALLOC_INFO</span><span class="p">(</span><span class="mi">16384</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="n">k</span><span class="p">),</span>
<span class="w">    </span><span class="n">INIT_KMALLOC_INFO</span><span class="p">(</span><span class="mi">32768</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="n">k</span><span class="p">),</span>
<span class="w">    </span><span class="n">INIT_KMALLOC_INFO</span><span class="p">(</span><span class="mi">65536</span><span class="p">,</span><span class="w"> </span><span class="mi">64</span><span class="n">k</span><span class="p">),</span>
<span class="w">    </span><span class="n">INIT_KMALLOC_INFO</span><span class="p">(</span><span class="mi">131072</span><span class="p">,</span><span class="w"> </span><span class="mi">128</span><span class="n">k</span><span class="p">),</span>
<span class="w">    </span><span class="n">INIT_KMALLOC_INFO</span><span class="p">(</span><span class="mi">262144</span><span class="p">,</span><span class="w"> </span><span class="mi">256</span><span class="n">k</span><span class="p">),</span>
<span class="w">    </span><span class="n">INIT_KMALLOC_INFO</span><span class="p">(</span><span class="mi">524288</span><span class="p">,</span><span class="w"> </span><span class="mi">512</span><span class="n">k</span><span class="p">),</span>
<span class="w">    </span><span class="n">INIT_KMALLOC_INFO</span><span class="p">(</span><span class="mi">1048576</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="n">M</span><span class="p">),</span>
<span class="w">    </span><span class="n">INIT_KMALLOC_INFO</span><span class="p">(</span><span class="mi">2097152</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="n">M</span><span class="p">),</span>
<span class="w">    </span><span class="n">INIT_KMALLOC_INFO</span><span class="p">(</span><span class="mi">4194304</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="n">M</span><span class="p">),</span>
<span class="w">    </span><span class="n">INIT_KMALLOC_INFO</span><span class="p">(</span><span class="mi">8388608</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="n">M</span><span class="p">),</span>
<span class="w">    </span><span class="n">INIT_KMALLOC_INFO</span><span class="p">(</span><span class="mi">16777216</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="n">M</span><span class="p">),</span>
<span class="w">    </span><span class="n">INIT_KMALLOC_INFO</span><span class="p">(</span><span class="mi">33554432</span><span class="p">,</span><span class="w"> </span><span class="mi">32</span><span class="n">M</span><span class="p">)</span>
<span class="p">};</span>
</code></pre></div>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="n">__always_inline</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">__kmalloc_index</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">,</span>
<span class="w">                            </span><span class="kt">bool</span><span class="w"> </span><span class="n">size_is_constant</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">size</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">android_kmalloc_64_create</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">64</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">6</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">KMALLOC_MIN_SIZE</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">KMALLOC_SHIFT_LOW</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">KMALLOC_MIN_SIZE</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">32</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">64</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">96</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">KMALLOC_MIN_SIZE</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">64</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">128</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">192</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">&lt;=</span><span class="w">          </span><span class="mi">8</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">&lt;=</span><span class="w">         </span><span class="mi">16</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">&lt;=</span><span class="w">         </span><span class="mi">32</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">&lt;=</span><span class="w">         </span><span class="mi">64</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">6</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">&lt;=</span><span class="w">        </span><span class="mi">128</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">7</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">&lt;=</span><span class="w">        </span><span class="mi">256</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">&lt;=</span><span class="w">        </span><span class="mi">512</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">9</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">&lt;=</span><span class="w">       </span><span class="mi">1024</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">&lt;=</span><span class="w">   </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1024</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">11</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">&lt;=</span><span class="w">   </span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1024</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">12</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">&lt;=</span><span class="w">   </span><span class="mi">8</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1024</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">13</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">&lt;=</span><span class="w">  </span><span class="mi">16</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1024</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">14</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">&lt;=</span><span class="w">  </span><span class="mi">32</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1024</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">15</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">&lt;=</span><span class="w">  </span><span class="mi">64</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1024</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">128</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1024</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">17</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">256</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1024</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">18</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">512</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1024</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">19</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">1024</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1024</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">&lt;=</span><span class="w">  </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1024</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1024</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">21</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">&lt;=</span><span class="w">  </span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1024</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1024</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">22</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">&lt;=</span><span class="w">  </span><span class="mi">8</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1024</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1024</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">23</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">&lt;=</span><span class="w">  </span><span class="mi">16</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1024</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1024</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">24</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">size</span><span class="w"> </span><span class="o">&lt;=</span><span class="w">  </span><span class="mi">32</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1024</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1024</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">25</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">IS_ENABLED</span><span class="p">(</span><span class="n">CONFIG_CC_IS_GCC</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">CONFIG_CLANG_VERSION</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">110000</span><span class="p">)</span>
<span class="w">        </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">IS_ENABLED</span><span class="p">(</span><span class="n">CONFIG_PROFILE_ALL_BRANCHES</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">size_is_constant</span><span class="p">)</span>
<span class="w">        </span><span class="n">BUILD_BUG_ON_MSG</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="err">\\\\\\\</span><span class="s">"unexpected size in kmalloc_index()</span><span class="se">\\\\\\\"</span><span class="s">);</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">        </span><span class="n">BUG</span><span class="p">();</span>

<span class="w">    </span><span class="cm">/* Will never be reached. Needed because the compiler may complain */</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
  <div class="post-nav">
    <a class="prev" href="/note_page/posts/linux/连续内存分配器cma.html">← 连续内存分配器CMA</a>
    <a class="next" href="/note_page/posts/linux/伙伴系统.html">伙伴系统 →</a>
  </div>
</article>

      </section>

      <aside class="right-panel">
        
      </aside>
    </main>

    <footer class="site-footer">
      <div class="container">Copyright ©2022-2025 laumy 版权所有</div>
    </footer>

    <script src="/note_page/assets/site.js"></script>
  </body>
  </html>

