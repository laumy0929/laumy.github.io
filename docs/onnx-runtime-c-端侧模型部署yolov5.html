<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>ONNX Runtime C++端侧模型部署YOLOv5 - Laumy的技术栈</title>
    <link rel="stylesheet" href="../note_page/assets/style.css">
    <!-- MathJax支持LaTeX数学公式 -->
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          ignoreHtmlClass: 'tex2jax_ignore',
          processHtmlClass: 'tex2jax_process'
        }
      };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  </head>
  <body>
    <header class="site-header">
      <div class="container">
        <a class="logo" href="../note_page/">Laumy的技术栈</a>
        <div class="search">
          <input id="search-input" type="text" placeholder="输入关键词回车搜索">
        </div>
        <div class="theme-toggle" title="切换主题" id="theme-toggle">☾</div>
        <nav class="top-nav">
          <div class="nav-item"><a href="../note_page/">首页</a></div>
        </nav>
      </div>
    </header>

    <main class="container layout">
      <aside class="left-nav">
        
        <div class="card">
          <div class="card-title">文章目录</div>
          <nav id="toc"><ul><li><a href="#_1">加载准备</a><ul><li><a href="#onnxruntime">初始化ONNXRuntime环境</a></li><li><a href="#_2">设置会话参数</a></li></ul></li><li><a href="#_3">模型加载</a><ul></ul></li><li><a href="#_4">获取输入和输出信息</a><ul><li><a href="#_5">输入名称</a></li><li><a href="#_6">输入张量维度</a></li><li><a href="#_7">输出名称</a></li></ul></li><li><a href="#_8">输入预处理</a><ul></ul></li><li><a href="#_9">模型推理</a><ul></ul></li><li><a href="#_10">输出后处理</a><ul></ul></li></ul></nav>
        </div>
        
      </aside>

      <section class="content">
        
<article class="card post">
  <h1>ONNX Runtime C++端侧模型部署YOLOv5</h1>
  <div class="meta">2025-06-19 · ai</div>
  <div class="post-content"><h2 id="_1">加载准备</h2>
<h3 id="onnxruntime">初始化ONNXRuntime环境</h3>
<div class="codehilite"><pre><span></span><code><span class="n">Ort</span><span class="o">::</span><span class="n">Env</span><span class="w"> </span><span class="n">env</span><span class="p">(</span><span class="n">ORT_LOGGING_LEVEL_WARNING</span><span class="p">,</span><span class="w"> </span><span class="s">"YOLOv5Inference"</span><span class="p">);</span>
</code></pre></div>
<p>Ort::Env 是 ONNX Runtime C++ API 中用于初始化运行环境的类，有多个重载的构造函数，下面是一个构造函数原型及参数作用如下。</p>
<div class="codehilite"><pre><span></span><code><span class="n">Ort</span><span class="o">::</span><span class="n">Env</span><span class="p">(</span>
<span class="w">    </span><span class="n">OrtLoggingLevel</span><span class="w"> </span><span class="n">logging_level</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">logid</span><span class="p">,</span>
<span class="w">    </span><span class="n">OrtLoggingFunction</span><span class="w"> </span><span class="n">logging_fn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span>
<span class="w">    </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">logger_param</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span>
<span class="p">);</span>
</code></pre></div>
<ul>
<li>logging_level:控制日志输出级别</li>
<li>logid: 自定义日志标签，用于区分不同模块的日志来源</li>
<li>logging_fn:自定义日志回调函数，若为 nullptr 则使用默认日志输出到控制台。</li>
<li>logger_param:传递给自定义日志函数的用户参数（如上下文对象）</li>
</ul>
<h3 id="_2">设置会话参数</h3>
<div class="codehilite"><pre><span></span><code><span class="n">Ort</span><span class="o">::</span><span class="n">SessionOptions</span><span class="w"> </span><span class="n">session_options</span><span class="p">;</span>

<span class="n">session_options</span><span class="p">.</span><span class="n">SetIntraOpNumThreads</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">session_options</span><span class="p">.</span><span class="n">SetGraphOptimizationLevel</span><span class="p">(</span><span class="n">GraphOptimizationLevel</span><span class="o">::</span><span class="n">ORT_ENABLE_ALL</span><span class="p">);</span>
</code></pre></div>
<p>初始化一个空的会话配置对象session_options，SetIntraOpNumThreads限制单个算子（Intra-op）内部使用的线程数为 1，适用于轻量级任务或避免多线程竞争，SetGraphOptimizationLevel启用所有图优化策略（如算子融合、常量折叠），提升推理性能。</p>
<h2 id="_3">模型加载</h2>
<div class="codehilite"><pre><span></span><code><span class="n">Ort</span><span class="o">::</span><span class="n">Session</span><span class="w"> </span><span class="nf">session_</span><span class="p">(</span><span class="n">env</span><span class="p">,</span><span class="w"> </span><span class="n">modelPath</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span><span class="w"> </span><span class="n">session_options</span><span class="p">);</span>
</code></pre></div>
<p>Ort::Session 是 ONNX Runtime C++ API 中用于加载 ONNX 模型并创建推理会话的核心类，其功能分解如下。</p>
<div class="codehilite"><pre><span></span><code><span class="n">Ort</span><span class="o">::</span><span class="n">Session</span><span class="p">(</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">Ort</span><span class="o">::</span><span class="n">Env</span><span class="o">&amp;</span><span class="w"> </span><span class="n">env</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">model_path</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">Ort</span><span class="o">::</span><span class="n">SessionOptions</span><span class="o">&amp;</span><span class="w"> </span><span class="n">options</span>
<span class="p">);</span>
</code></pre></div>
<ul>
<li>env：全局运行环境对象，管理线程池和内存分配等资源，需优先初始化。</li>
<li>model_path：ONNX 模型文件的路径，c语言的字符串类型。</li>
<li>options：会话参数，配置会话行为，如线程数、优化级别、硬件后端等。</li>
</ul>
<h2 id="_4">获取输入和输出信息</h2>
<h3 id="_5">输入名称</h3>
<div class="codehilite"><pre><span></span><code><span class="w">    </span><span class="n">Ort</span><span class="o">::</span><span class="n">AllocatorWithDefaultOptions</span><span class="w"> </span><span class="n">allocator</span><span class="p">;</span>
<span class="w">    </span><span class="c1">//创建默认内存分配器对象，用于管理 ONNX Runtime 中的内存分配（如节点名称字符串的内存</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*&gt;</span><span class="w"> </span><span class="n">input_node_names_</span><span class="p">;</span>
<span class="w">    </span><span class="c1">//存储 C 风格字符串指针，用于直接传递给 ONNX Runtime 的推理接口</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">input_names_</span><span class="p">;</span>
<span class="w">    </span><span class="c1">//存储标准字符串对象的vector，用于长期维护字符串内存</span>

<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">num_inputs_</span><span class="p">;</span>
<span class="w">    </span><span class="n">num_inputs_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">session_</span><span class="p">.</span><span class="n">GetInputCount</span><span class="p">();</span>
<span class="w">    </span><span class="c1">//获取输入节点的个数，有多少个节点就决定了多个个name，一般都是1个。</span>
<span class="w">    </span><span class="n">input_node_names_</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">num_inputs_</span><span class="p">);</span>
<span class="w">    </span><span class="n">input_names_</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">num_inputs_</span><span class="p">,</span><span class="w"> </span><span class="s">""</span><span class="p">);</span>
<span class="w">    </span><span class="c1">//预分配容器空间，避免动态扩容的开销</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"num_inputs = "</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">num_inputs_</span><span class="o">&lt;&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_inputs_</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">input_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">session_</span><span class="p">.</span><span class="n">GetInputNameAllocated</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">allocator</span><span class="p">);</span>
<span class="w">        </span><span class="c1">//通过分配器安全获取第 i 个输入节点的名称（返回 Ort::AllocatedStringPtr 对象）</span>
<span class="w">        </span><span class="n">input_names_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">input_name</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
<span class="w">        </span><span class="c1">//获取名称的原始指针，存入 input_names_ 的字符串中</span>
<span class="w">        </span><span class="n">input_node_names_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">input_names_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">c_str</span><span class="p">();</span>
<span class="w">        </span><span class="c1">//将 std::string 转换为 C 风格指针，供 input_node_names_ 使用</span>
<span class="w">    </span><span class="p">}</span>
</code></pre></div>
<p>上面函数示例了如何获取输入节点name，首先通过session_.GetInputCount()获取到输入的节点，然后使用for循环进行遍历每个节点，通过session_.GetInputNameAllocated(i, allocator)获取每个节点的名称，返回一个Ort::AllocatedStringPtr智能指针，需要通过.get方法返回c字符串，由于智能指针指向的存储空间退出for后会销毁，所以上述代码将其复制到input_names_中。</p>
<h3 id="_6">输入张量维度</h3>
<div class="codehilite"><pre><span></span><code><span class="w">    </span><span class="n">Ort</span><span class="o">::</span><span class="n">TypeInfo</span><span class="w"> </span><span class="n">input_type_info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">session_</span><span class="p">.</span><span class="n">GetInputTypeInfo</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="c1">//获取模型第0个输入节点的类型信息对象，返回Ort::TypeInfo类型</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">input_tensor_info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">input_type_info</span><span class="p">.</span><span class="n">GetTensorTypeAndShapeInfo</span><span class="p">();</span>
<span class="w">    </span><span class="c1">//从类型信息中提取张量相关的形状和数据类型信息，返回Ort::TensorTypeAndShapeInfo对象</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">input_dims</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">input_tensor_info</span><span class="p">.</span><span class="n">GetShape</span><span class="p">();</span>
<span class="w">    </span><span class="c1">//获取输入张量的维度信息，返回std::vector&lt;int64_t&gt;容器，存储各维度大小</span>
<span class="w">    </span><span class="c1">//典型YOLO模型的输入维度为[batch, channel, height, width]</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">inputWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">input_dims</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">inputHeight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">input_dims</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</code></pre></div>
<p>上面函数示例获取输入张量形状，最终通过张量的形状获取到了输入图像的宽和高。实际上可以简化一下，按照下面的方式。</p>
<div class="codehilite"><pre><span></span><code><span class="k">auto</span><span class="w"> </span><span class="n">inputShapeInfo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">session_</span><span class="p">.</span><span class="n">GetInputTypeInfo</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">GetTensorTypeAndShapeInfo</span><span class="p">().</span><span class="n">GetShape</span><span class="p">();</span>
<span class="kt">int</span><span class="w"> </span><span class="n">ch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inputShapeInfo</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="n">inputWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inputShapeInfo</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="n">inputHeight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inputShapeInfo</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
</code></pre></div>
<h3 id="_7">输出名称</h3>
<div class="codehilite"><pre><span></span><code><span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*&gt;</span><span class="w"> </span><span class="n">output_node_names_</span><span class="p">;</span>
<span class="w">    </span><span class="c1">//存储C风格字符串指针的vector，用于兼容需要const char*的ONNX Runtime API调用</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">output_names_</span><span class="p">;</span>
<span class="w">    </span><span class="c1">//存储标准字符串对象的vector，用于长期维护字符串内存</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">num_outputs_</span><span class="p">;</span>
<span class="w">    </span><span class="n">num_outputs_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">session_</span><span class="p">.</span><span class="n">GetOutputCount</span><span class="p">();</span>
<span class="w">    </span><span class="c1">//获取模型输出节点数量</span>
<span class="w">    </span><span class="n">output_node_names_</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">num_outputs_</span><span class="p">);</span>
<span class="w">    </span><span class="n">output_names_</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">num_outputs_</span><span class="p">,</span><span class="w"> </span><span class="s">""</span><span class="p">);</span>
<span class="w">    </span><span class="c1">//预分配两个vector的空间</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_outputs_</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">output_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">session_</span><span class="p">.</span><span class="n">GetOutputNameAllocated</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">allocator</span><span class="p">);</span>
<span class="w">        </span><span class="n">output_names_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="n">output_name</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
<span class="w">        </span><span class="c1">//将名称存入std::string保证生命周期</span>
<span class="w">        </span><span class="n">output_node_names_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">output_names_</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">c_str</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">//循环获取每个输出节点名称</span>
</code></pre></div>
<p>上面示例了获取输出名称，与输入方法类似。</p>
<h2 id="_8">输入预处理</h2>
<div class="codehilite"><pre><span></span><code><span class="w">    </span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="w"> </span><span class="n">image</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">imread</span><span class="p">(</span><span class="n">imagePath</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">image</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cerr</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">"Error: Could not read image."</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="w"> </span><span class="n">originalImage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">image</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span>
<span class="w">    </span><span class="n">cv</span><span class="o">::</span><span class="n">Size</span><span class="w"> </span><span class="n">image_shape</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">originalImage</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// 图像预处理</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="w"> </span><span class="n">inputTensor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">preprocess</span><span class="p">(</span><span class="n">image</span><span class="p">,</span><span class="w"> </span><span class="n">inputWidth</span><span class="p">,</span><span class="w"> </span><span class="n">inputHeight</span><span class="p">);</span>
</code></pre></div>
<p>使用opencv读取图像，调用preprocess进行预处理。</p>
<div class="codehilite"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="w"> </span><span class="n">preprocess</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">&amp;</span><span class="w"> </span><span class="n">image</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">inputWidth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">320</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">inputHeight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">320</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="w"> </span><span class="n">resizedImage</span><span class="p">;</span>
<span class="w">    </span><span class="n">cv</span><span class="o">::</span><span class="n">resize</span><span class="p">(</span><span class="n">image</span><span class="p">,</span><span class="w"> </span><span class="n">resizedImage</span><span class="p">,</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">Size</span><span class="p">(</span><span class="n">inputWidth</span><span class="p">,</span><span class="w"> </span><span class="n">inputHeight</span><span class="p">));</span>
<span class="w">    </span><span class="c1">//图像缩放：使用OpenCV的resize函数将图像调整为指定尺寸（默认320x320）</span>
<span class="w">    </span><span class="n">cv</span><span class="o">::</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">resizedImage</span><span class="p">,</span><span class="w"> </span><span class="n">resizedImage</span><span class="p">,</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">COLOR_BGR2RGB</span><span class="p">);</span>
<span class="w">    </span><span class="c1">//颜色空间转换：从BGR转换为RGB格式（多数深度学习模型使用RGB输入）</span>
<span class="w">    </span><span class="n">resizedImage</span><span class="p">.</span><span class="n">convertTo</span><span class="p">(</span><span class="n">resizedImage</span><span class="p">,</span><span class="w"> </span><span class="n">CV_32F</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">255.0</span><span class="p">);</span>
<span class="w">    </span><span class="c1">//数值归一化：通过convertTo将像素值从[0,255]归一化到[0,1]范围</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="w"> </span><span class="n">inputTensor</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">inputHeight</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">h</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">inputWidth</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">w</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">inputTensor</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">resizedImage</span><span class="p">.</span><span class="n">at</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Vec3f</span><span class="o">&gt;</span><span class="p">(</span><span class="n">h</span><span class="p">,</span><span class="w"> </span><span class="n">w</span><span class="p">)[</span><span class="n">c</span><span class="p">]);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">//通过三重循环将OpenCV的HWC格式（Height-Width-Channel）转换为CHW格式</span>
<span class="w">    </span><span class="c1">//内存布局变为连续通道数据：RRR...GGG...BBB,最终输出std::vector&lt;float&gt;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">inputTensor</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>上面的代码实现了模型对输入数据的部分预处理，包括输入图片缩放固定尺寸，数值归一化，以及将格式转换为CHW张量格式，但是对于输入模型，需要的数据格式为Ort::Value类型。</p>
<div class="codehilite"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">input_shape</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">inputHeight</span><span class="p">,</span><span class="w"> </span><span class="n">inputWidth</span><span class="p">};</span>
<span class="c1">//input_shape采用NCHW格式（批次数-通道-高度-宽度），这是深度学习模型的通用输入布局</span>
<span class="k">auto</span><span class="w"> </span><span class="n">memory_info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Ort</span><span class="o">::</span><span class="n">MemoryInfo</span><span class="o">::</span><span class="n">CreateCpu</span><span class="p">(</span><span class="n">OrtArenaAllocator</span><span class="p">,</span><span class="w"> </span><span class="n">OrtMemTypeDefault</span><span class="p">);</span>
<span class="c1">//描述用于描述内存分配的信息，包括内存的位置(CPU 或 GPU)以及内存的具体类型(固定内存或常规内存)</span>

<span class="n">Ort</span><span class="o">::</span><span class="n">Value</span><span class="w"> </span><span class="n">input_tensor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Ort</span><span class="o">::</span><span class="n">Value</span><span class="o">::</span><span class="n">CreateTensor</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">memory_info</span><span class="p">,</span>
<span class="w">        </span><span class="n">inputTensor</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="n">inputTensor</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span>
<span class="w">        </span><span class="n">input_shape</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span><span class="w"> </span><span class="n">input_shape</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</code></pre></div>
<p>关于CreateTensor对象解析如下。</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="n">Ort</span><span class="o">::</span><span class="n">Value</span><span class="w"> </span><span class="n">CreateTensor</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">MemoryInfo</span><span class="o">&amp;</span><span class="w"> </span><span class="n">memory_info</span><span class="p">,</span><span class="w">  </span><span class="c1">// 内存管理策略</span>
<span class="w">    </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">p_data</span><span class="p">,</span><span class="w">                  </span><span class="c1">// 输入数据指针</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">p_data_length</span><span class="p">,</span><span class="w">           </span><span class="c1">// 输入的大小</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int64_t</span><span class="o">*</span><span class="w"> </span><span class="n">shape</span><span class="p">,</span><span class="w">           </span><span class="c1">// 维度数组指针</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">shape_length</span><span class="w">             </span><span class="c1">// 维度数量</span>
<span class="p">);</span>
</code></pre></div>
<ul>
<li>memory_info：指定张量内存分配策略，通常由Ort::MemoryInfo::CreateCpu创建。</li>
<li>inputTensor.data()：输入数据的地址（需确保内存连续）。</li>
<li>inputTensor.size()：输入数据的大小。</li>
<li>input_shape.data()：输入张量的形状数组信息（如NCHW格式的{1,3,640,640}）。</li>
<li>shape_length: 输入张量的形状信息维度数</li>
</ul>
<h2 id="_9">模型推理</h2>
<div class="codehilite"><pre><span></span><code><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Ort</span><span class="o">::</span><span class="n">Value</span><span class="o">&gt;</span><span class="w"> </span><span class="n">outputs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">session_</span><span class="p">.</span><span class="n">Run</span><span class="p">(</span>
<span class="w">    </span><span class="n">Ort</span><span class="o">::</span><span class="n">RunOptions</span><span class="p">{</span><span class="k">nullptr</span><span class="p">},</span>
<span class="w">    </span><span class="n">input_node_names_</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span>
<span class="w">    </span><span class="o">&amp;</span><span class="n">input_tensor</span><span class="p">,</span>
<span class="w">    </span><span class="mi">1</span><span class="p">,</span>
<span class="w">    </span><span class="n">output_node_names_</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span>
<span class="w">    </span><span class="n">output_node_names_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
</code></pre></div>
<p>下面是函数的参数</p>
<div class="codehilite"><pre><span></span><code><span class="n">OrtStatus</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">OrtApi</span><span class="o">::</span><span class="n">Run</span><span class="p">(</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">OrtRunOptions</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">run_options</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="o">*</span><span class="n">input_names</span><span class="p">,</span><span class="w">  </span><span class="c1">//输入节点名称的数组</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">OrtValue</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="o">*</span><span class="n">inputs</span><span class="p">,</span><span class="w">   </span><span class="c1">//模型输入的数据Ort::Value类型</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w">  </span><span class="n">input_len</span><span class="p">,</span><span class="w">  </span><span class="c1">//输入张量数量，需与input_names数组长度一致</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="o">*</span><span class="n">output_names</span><span class="p">,</span><span class="c1">//输出节点名称数组</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w">  </span><span class="n">output_names_len</span><span class="p">,</span><span class="c1">//输出节点名称的数量，与output_names数组数量保持一致。</span>
<span class="p">)</span>
</code></pre></div>
<h2 id="_10">输出后处理</h2>
<div class="codehilite"><pre><span></span><code><span class="w">    </span><span class="c1">//张量信息提取，outputs[0]指向坐标、分数张量指针，outputs[1]指向类别张量的指针</span>
<span class="w">    </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">dets_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">GetTensorMutableData</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">    </span><span class="c1">//坐标（格式为[x1,y1,x2,y2,score]）</span>
<span class="w">    </span><span class="kt">float</span><span class="o">*</span><span class="w"> </span><span class="n">labels_pred_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">outputs</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">GetTensorMutableData</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">    </span><span class="c1">//类别</span>

<span class="w">    </span><span class="c1">//张量维度的解析，用于获取检测框的数量</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">dets_tensor_info</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">GetTensorTypeAndShapeInfo</span><span class="p">();</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">dets_dims</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dets_tensor_info</span><span class="p">.</span><span class="n">GetShape</span><span class="p">();</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">num_detections</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dets_dims</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

<span class="w">    </span><span class="c1">//结构化重组，解析输出的张量将其存储dets、scores、lables_pred</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">dets</span><span class="p">(</span><span class="n">num_detections</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">4</span><span class="p">));</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="w"> </span><span class="n">scores</span><span class="p">(</span><span class="n">num_detections</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">labels_pred</span><span class="p">(</span><span class="n">num_detections</span><span class="p">);</span>

<span class="w">    </span><span class="c1">//遍历解析存储坐标dets、分数scores、标签类别lables_pred</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_detections</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">dets</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dets_data</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="p">];</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">scores</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dets_data</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="p">];</span>
<span class="w">        </span><span class="n">labels_pred</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">labels_pred_data</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">//将坐标信息进行缩放以适应正常的图片大小。</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">scale_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">image_shape</span><span class="p">.</span><span class="n">width</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">inputWidth</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">scale_y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">image_shape</span><span class="p">.</span><span class="n">height</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">inputHeight</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">det</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">dets</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">det</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">scale_x</span><span class="p">;</span>
<span class="w">        </span><span class="n">det</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">scale_y</span><span class="p">;</span>
<span class="w">        </span><span class="n">det</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">scale_x</span><span class="p">;</span>
<span class="w">        </span><span class="n">det</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">scale_y</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
</code></pre></div>
<p>上面的代码从输出张量信息中进行解析，将坐标、分数、标签类别依次存储到dets、scores、lables_pred中。</p>
<div class="codehilite"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">visualizeResults</span><span class="p">(</span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">&amp;</span><span class="w"> </span><span class="n">image</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&gt;&amp;</span><span class="w"> </span><span class="n">dets</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">scores</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">labels_pred</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">labels</span><span class="p">,</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">conf_threshold</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.4</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">dets</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">det</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dets</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">score</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">scores</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">score</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">conf_threshold</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">class_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">labels_pred</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">x1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">det</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">y1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">det</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">x2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">det</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">y2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">det</span><span class="p">[</span><span class="mi">3</span><span class="p">]);</span>
<span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">label</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">labels</span><span class="p">[</span><span class="n">class_id</span><span class="p">];</span>
<span class="w">            </span><span class="n">cv</span><span class="o">::</span><span class="n">rectangle</span><span class="p">(</span><span class="n">image</span><span class="p">,</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">Point</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span><span class="w"> </span><span class="n">y1</span><span class="p">),</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">Point</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span><span class="w"> </span><span class="n">y2</span><span class="p">),</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">Scalar</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">255</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="w">            </span><span class="n">cv</span><span class="o">::</span><span class="n">putText</span><span class="p">(</span><span class="n">image</span><span class="p">,</span><span class="w"> </span><span class="n">label</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">": "</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">score</span><span class="p">),</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">Point</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span><span class="w"> </span><span class="n">y1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">10</span><span class="p">),</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">FONT_HERSHEY_SIMPLEX</span><span class="p">,</span><span class="w"> </span><span class="mf">0.9</span><span class="p">,</span><span class="w"> </span><span class="n">cv</span><span class="o">::</span><span class="n">Scalar</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">255</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>最终将获取到的将坐标、分数、标签类别传入到visualizeResults进行绘制。</p>
<p>发现一个开源的ai toolkit，相对比较全。<a href="https://github.com/xlite-dev/lite.ai.toolkit/tree/main">https://github.com/xlite-dev/lite.ai.toolkit/tree/main</a></p></div>
  <div class="post-nav">
    <a class="prev" href="../note_page/pip-install.html">← pip install</a>
    <a class="next" href="../note_page/onnx-runtime-python端侧模型部署yolov5.html">ONNX Runtime Python端侧模型部署YOLOv5 →</a>
  </div>
</article>

      </section>

      <aside class="right-panel">
        
      </aside>
    </main>

    <footer class="site-footer">
      <div class="container">Copyright ©2022-2025 laumy 版权所有</div>
    </footer>

    <script src="../note_page/assets/site.js"></script>
  </body>
  </html>

