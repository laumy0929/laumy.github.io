<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>负载均衡之负载跟踪 - Laumy的技术栈</title>
    <link rel="stylesheet" href="assets/style.css">
    <!-- MathJax支持LaTeX数学公式 -->
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          ignoreHtmlClass: 'tex2jax_ignore',
          processHtmlClass: 'tex2jax_process'
        }
      };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  </head>
  <body>
    <header class="site-header">
      <div class="container">
        <a class="logo" href="./">Laumy的技术栈</a>
        <div class="search">
          <input id="search-input" type="text" placeholder="输入关键词回车搜索">
        </div>
        <div class="theme-toggle" title="切换主题" id="theme-toggle">☾</div>
        <nav class="top-nav">
          <div class="nav-item"><a href="./">首页</a></div>
        </nav>
      </div>
    </header>

    <main class="container layout">
      <aside class="left-nav">
        
        <div class="card">
          <div class="card-title">文章目录</div>
          <nav id="toc"><ul><li><a href="#pelt">PELT基本原理</a><ul><li><a href="#valyp">val*y^p计算</a></li><li><a href="#1024y1-y2-yp-1">1024*(y^1 + y^2 +......+ y^p-1)计算</a></li><li><a href="#_1">代码实现</a></li></ul></li><li><a href="#_2">负载更新</a><ul><li><a href="#_3">触发负载更新</a></li><li><a href="#taskcfs_rq">task与cfs_rq平均负载</a></li><li><a href="#_4">负载、运行负载、利用率计算</a></li><li><a href="#_5">负载传播</a></li></ul></li></ul></nav>
        </div>
        
      </aside>

      <section class="content">
        
<article class="card post">
  <h1>负载均衡之负载跟踪</h1>
  <div class="meta">2023-04-08 · linux</div>
  <div class="post-content"><p>各任务负载、各cpu的算力（频率+架构）、任务迁移开销（调度域，调度组）。</p>
<div class="codehilite"><pre><span></span><code><span class="n">root</span><span class="err">@</span><span class="n">Linux</span><span class="o">:/</span><span class="err">#</span><span class="w"> </span><span class="n">cat</span><span class="w"> </span><span class="o">/</span><span class="n">proc</span><span class="o">/</span><span class="n">loadavg</span><span class="w"> </span>
<span class="mf">3.49</span><span class="w"> </span><span class="mf">3.43</span><span class="w"> </span><span class="mf">3.54</span><span class="w"> </span><span class="mi">4</span><span class="o">/</span><span class="mi">131</span><span class="w"> </span><span class="mi">3065</span>
</code></pre></div>
<p>cat /proc/loadavg可以获取CPU全局平均负载，前面的三个值分别表示为1分钟、5分钟、15分钟系统平均负载，第四个字段正在运行的进程数量/总进程数量，第五个字段最后一个运行的进程ID。</p>
<div class="codehilite"><pre><span></span><code><span class="n">公式①</span><span class="err">：</span><span class="n">CPU负载</span><span class="o">=</span><span class="n">就绪队列总权重</span>
</code></pre></div>
<p>早期系统计算系统负载是所有CPU上就绪队列的总权重，但是使用权重来计算是比较局限的，因为负载考虑的是对CPU资源占用情况，而权重高的进程可能并不一定会一直运行，或许运行一会就一直睡眠，因此使用就绪队列的总权重并不合理。 在权重的基础上进行演化，从全局考虑整体就绪队列到追踪每一个调度实体对CPU资源的占用，从而调度器有更精细的控制。在一段时间内，将每个任务可运行时间考虑进去（可运行表示处于就绪队列中，但并不是在执行），这样就能够代表任务对CPU的资源占用情况。</p>
<div class="codehilite"><pre><span></span><code><span class="n">公式②</span><span class="err">：</span><span class="n">load</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">weight</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">/</span><span class="n">T</span>
</code></pre></div>
<p>采样一段时间T，任务处于运行状态时间为t,该任务对CPU的负载可运行时间与采样时间的比值再与权重相乘。 公式②看起来是比较合理，但是仍然存在问题，考虑一些场景，假设相同优先级A任务和B任务在某天同一时刻启动，A任务运行了半天就一直睡眠，而B任务一启动就睡眠半天，然后一直运行。按照公式②的计算A和B的负载是一样的，显然不合理，在最近的这段时间内任务B的负载要高于A，因此基于公式再进行了演化，加入历史运行情况的参数。</p>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_b725ab47056127971680f54b86cc9316.jpg"><img alt="" src="assets/doc/01-linux/进程调度/7-负载均衡之负载跟踪简介/images/wp_editor_md_b725ab47056127971680f54b86cc9316.jpg"/></a></p>
<div class="codehilite"><pre><span></span><code><span class="n">公式③</span><span class="err">：</span><span class="n">load</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">weight</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">t0</span><span class="o">*</span><span class="n">y</span><span class="o">^</span><span class="mi">0</span><span class="o">+</span><span class="w"> </span><span class="n">t1</span><span class="o">*</span><span class="n">y</span><span class="o">^</span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">t2</span><span class="o">*</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="p">...</span><span class="o">+</span><span class="n">tn</span><span class="o">*</span><span class="n">y</span><span class="o">^</span><span class="n">n</span><span class="p">)</span><span class="o">/</span><span class="n">T</span>
</code></pre></div>
<p>负载计算将历史运行因素考虑进去，但是历史因素的因素有一个衰减（decay）过程，也就是说离当前最近的影响最大，离当前时间越远影响程度越小，所以衰减因子y^32=0.5。为了便于系统计算对公式在进行了量化，采样周期为1ms，所以公式为</p>
<div class="codehilite"><pre><span></span><code><span class="n">公式④L</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">L0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">L1</span><span class="o">*</span><span class="n">y</span><span class="o">^</span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">L2</span><span class="o">*</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">L3</span><span class="o">*</span><span class="w"> </span><span class="n">y</span><span class="o">^</span><span class="mi">3</span><span class="w"> </span><span class="o">+</span><span class="p">....</span><span class="w"> </span><span class="n">Ln</span><span class="o">*</span><span class="n">y</span><span class="o">^</span><span class="n">n</span><span class="err">。</span>
</code></pre></div>
<p>下面是描述调度实体或就绪队列的负载信息。</p>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">sched_avg</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">u64</span><span class="w">             </span><span class="n">last_update_time</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="n">u64</span><span class="w">             </span><span class="n">load_sum</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="n">u64</span><span class="w">             </span><span class="n">runnable_sum</span><span class="p">;</span>
<span class="w">    </span><span class="n">u32</span><span class="w">             </span><span class="n">util_sum</span><span class="p">;</span>
<span class="w">    </span><span class="n">u32</span><span class="w">             </span><span class="n">period_contrib</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w">           </span><span class="n">load_avg</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w">           </span><span class="n">runnable_avg</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w">           </span><span class="n">util_avg</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">util_est</span><span class="w">         </span><span class="n">util_est</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">____cacheline_aligned</span><span class="p">;</span>
</code></pre></div>
<ul>
<li>last_update_time: 上次更新负载信息的时间点，可用于计算差值。</li>
<li>load_sum：调度实体来说是任务累计历史衰减总时间,包括running+runnable+blocked，对于调度队列来说是其所有任务累计工作总负载，前者统计的仅仅是时间，后者是工作负载即时间乘权重。</li>
<li>runnable_sum: 调度实体来说是running+runnable累计历史衰减总时间，</li>
<li>util_sum:调度实体来说正在运行状态下的累计衰减总时间，调度队列来说其所有正在运行任务的总时间。</li>
<li>period_contrib: 存放着上一次时间采样时，不能凑成一个周期的剩余时间。</li>
<li><em>_avg/util_avg:根据</em>_sum计算得到的负载均值。</li>
<li>util_est:辅助计算阻塞之前load avg信息。</li>
</ul>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_d3e07f2dcf618382b3e20e3893854ec0.jpg"><img alt="" src="assets/doc/01-linux/进程调度/7-负载均衡之负载跟踪简介/images/wp_editor_md_d3e07f2dcf618382b3e20e3893854ec0.jpg"/></a></p>
<p>上面是struct cfs_rq/struct sched_entity 与struct sched_avg之间的关系，也就是说在计算负载时有调度实体的负载和就绪队列的负载。</p>
<div class="codehilite"><pre><span></span><code><span class="cm">/*</span>
<span class="cm"> * sched_entity:</span>
<span class="cm"> *</span>
<span class="cm"> *   task:</span>
<span class="cm"> *     se_weight()   = se-&gt;load.weight</span>
<span class="cm"> *     se_runnable() = !!on_rq</span>
<span class="cm"> *</span>
<span class="cm"> *   group: [ see update_cfs_group() ]</span>
<span class="cm"> *     se_weight()   = tg-&gt;weight * grq-&gt;load_avg / tg-&gt;load_avg</span>
<span class="cm"> *     se_runnable() = grq-&gt;h_nr_running</span>
<span class="cm"> *</span>
<span class="cm"> *   runnable_sum = se_runnable() * runnable = grq-&gt;runnable_sum</span>
<span class="cm"> *   runnable_avg = runnable_sum</span>
<span class="cm"> *</span>
<span class="cm"> *   load_sum := runnable</span>
<span class="cm"> *   load_avg = se_weight(se) * load_sum</span>
<span class="cm"> *</span>
<span class="cm"> * cfq_rq:</span>
<span class="cm"> *</span>
<span class="cm"> *   runnable_sum = \\Sum se-&gt;avg.runnable_sum</span>
<span class="cm"> *   runnable_avg = \\Sum se-&gt;avg.runnable_avg</span>
<span class="cm"> *</span>
<span class="cm"> *   load_sum = \\Sum se_weight(se) * se-&gt;avg.load_sum</span>
<span class="cm"> *   load_avg = \\Sum se-&gt;avg.load_avg</span>
<span class="cm"> */</span>
</code></pre></div>
<h2 id="pelt">PELT基本原理</h2>
<div class="codehilite"><pre><span></span><code><span class="n">公式④L</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">L0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">L1</span><span class="o">*</span><span class="n">y</span><span class="o">^</span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">L2</span><span class="o">*</span><span class="n">y</span><span class="o">^</span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">L3</span><span class="o">*</span><span class="w"> </span><span class="n">y</span><span class="o">^</span><span class="mi">3</span><span class="w"> </span><span class="o">+</span><span class="p">....</span><span class="w"> </span><span class="n">Ln</span><span class="o">*</span><span class="n">y</span><span class="o">^</span><span class="n">n</span><span class="err">。</span>
</code></pre></div>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_04734f35001abd11014c5a2feacdeb16.jpg"><img alt="" src="assets/doc/01-linux/进程调度/7-负载均衡之负载跟踪简介/images/wp_editor_md_04734f35001abd11014c5a2feacdeb16.jpg"/></a></p>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_3fe802816882b87025091b235c00346e.jpg"><img alt="" src="assets/doc/01-linux/进程调度/7-负载均衡之负载跟踪简介/images/wp_editor_md_3fe802816882b87025091b235c00346e.jpg"/></a></p>
<p>在计算负载时，计算时刻并不能这么精确，这次计算的时间距离上一次计算负载的时间跨越了多个周期，如上图所示，last_update_time时刻表示上一次计算负载，而这次计算的负载为now时刻。时间可以分为3段d1、d2、d3，之所以这样划分当前计算时刻与上一次计算负载的时刻并不一定落在周期点。假设last_update_time时刻的计算出来的负载为，根据划分的3段，因此系统的负载计算为：Llast，先不考虑权重，那么当前时刻负载为：</p>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_b21a9590f46ed129a4f3cfabe249adb3.jpg"><img alt="" src="assets/doc/01-linux/进程调度/7-负载均衡之负载跟踪简介/images/wp_editor_md_b21a9590f46ed129a4f3cfabe249adb3.jpg"/></a></p>
<p>从这个公式来看，负载的计算可以分为3段。</p>
<h3 id="valyp">val*y^p计算</h3>
<p>先来看(d1+ Llast) * y^p 中代码的实现，由于y^p 的值是浮点，为了避免浮点运算可以转化为y^p = y^p * 2^32 &gt;&gt; 32，相当于先乘以2^32 再右移32（右移就是除），而y^p * 2^32 再系统中提前计算好了存放再数组runable_avg_yN_inv中，如下：</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">u32</span><span class="w"> </span><span class="n">runnable_avg_yN_inv</span><span class="p">[]</span><span class="w"> </span><span class="n">__maybe_unused</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="mh">0xffffffff</span><span class="p">,</span><span class="w"> </span><span class="mh">0xfa83b2da</span><span class="p">,</span><span class="w"> </span><span class="mh">0xf5257d14</span><span class="p">,</span><span class="w"> </span><span class="mh">0xefe4b99a</span><span class="p">,</span><span class="w"> </span><span class="mh">0xeac0c6e6</span><span class="p">,</span><span class="w"> </span><span class="mh">0xe5b906e6</span><span class="p">,</span>
<span class="w">    </span><span class="mh">0xe0ccdeeb</span><span class="p">,</span><span class="w"> </span><span class="mh">0xdbfbb796</span><span class="p">,</span><span class="w"> </span><span class="mh">0xd744fcc9</span><span class="p">,</span><span class="w"> </span><span class="mh">0xd2a81d91</span><span class="p">,</span><span class="w"> </span><span class="mh">0xce248c14</span><span class="p">,</span><span class="w"> </span><span class="mh">0xc9b9bd85</span><span class="p">,</span>
<span class="w">    </span><span class="mh">0xc5672a10</span><span class="p">,</span><span class="w"> </span><span class="mh">0xc12c4cc9</span><span class="p">,</span><span class="w"> </span><span class="mh">0xbd08a39e</span><span class="p">,</span><span class="w"> </span><span class="mh">0xb8fbaf46</span><span class="p">,</span><span class="w"> </span><span class="mh">0xb504f333</span><span class="p">,</span><span class="w"> </span><span class="mh">0xb123f581</span><span class="p">,</span>
<span class="w">    </span><span class="mh">0xad583ee9</span><span class="p">,</span><span class="w"> </span><span class="mh">0xa9a15ab4</span><span class="p">,</span><span class="w"> </span><span class="mh">0xa5fed6a9</span><span class="p">,</span><span class="w"> </span><span class="mh">0xa2704302</span><span class="p">,</span><span class="w"> </span><span class="mh">0x9ef5325f</span><span class="p">,</span><span class="w"> </span><span class="mh">0x9b8d39b9</span><span class="p">,</span>
<span class="w">    </span><span class="mh">0x9837f050</span><span class="p">,</span><span class="w"> </span><span class="mh">0x94f4efa8</span><span class="p">,</span><span class="w"> </span><span class="mh">0x91c3d373</span><span class="p">,</span><span class="w"> </span><span class="mh">0x8ea4398a</span><span class="p">,</span><span class="w"> </span><span class="mh">0x8b95c1e3</span><span class="p">,</span><span class="w"> </span><span class="mh">0x88980e80</span><span class="p">,</span>
<span class="w">    </span><span class="mh">0x85aac367</span><span class="p">,</span><span class="w"> </span><span class="mh">0x82cd8698</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_263a57dc80207216c76839960bc69825.jpg"><img alt="" src="assets/doc/01-linux/进程调度/7-负载均衡之负载跟踪简介/images/wp_editor_md_263a57dc80207216c76839960bc69825.jpg"/></a></p>
<div class="codehilite"><pre><span></span><code><span class="c1">//计算val * y^n，y^32 = 0.5。</span>
<span class="k">static</span><span class="w"> </span><span class="n">u64</span><span class="w"> </span><span class="nf">decay_load</span><span class="p">(</span><span class="n">u64</span><span class="w"> </span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="n">u64</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">local_n</span><span class="p">;</span>
<span class="w">    </span><span class="c1">//经过LOAD_AVG_PERIOD * 63周期后，就衰减为0了</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">LOAD_AVG_PERIOD</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">63</span><span class="p">))</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* after bounds checking we can collapse to 32-bit */</span>
<span class="w">    </span><span class="n">local_n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<span class="w">    </span><span class="c1">//如果衰减周期大于32，则计算方式有调整如下，反之直接查表，</span>
<span class="c1">//val * y^p =val * (y^32)^(p/32) * y^(p%32) * 2^32 &gt;&gt;32, p=p/32 + p%32,</span>
<span class="c1">//而y^32=1/2,所以val * (y^32)^(p/32) =val &gt;&gt; (p/32),</span>
<span class="c1">//y^(p%32) * 2^32 就先计算p%32，然后从runnable_avg_yN_inv表中查询。</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">local_n</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">LOAD_AVG_PERIOD</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">val</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="n">local_n</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">LOAD_AVG_PERIOD</span><span class="p">;</span><span class="w"> </span><span class="c1">//val * (y^32)^(p/32) =val &gt;&gt; (p/32)</span>
<span class="w">        </span><span class="n">local_n</span><span class="w"> </span><span class="o">%=</span><span class="w"> </span><span class="n">LOAD_AVG_PERIOD</span><span class="p">;</span><span class="w"> </span><span class="c1">//p%32,便于从runnable_avg_yN_inv查询</span>
<span class="w">    </span><span class="p">}</span>

<span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mul_u64_u32_shr</span><span class="p">(</span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="n">runnable_avg_yN_inv</span><span class="p">[</span><span class="n">local_n</span><span class="p">],</span><span class="w"> </span><span class="mi">32</span><span class="p">);</span>
<span class="c1">//val * runnable_avg_yN_inv[local_n] &gt;&gt; 32</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">val</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="1024y1-y2-yp-1">1024*(y^1 + y^2 +......+ y^p-1)计算</h3>
<p>由等比求和公式</p>
<div class="codehilite"><pre><span></span><code><span class="n">y</span><span class="o">^</span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="o">^</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="o">^</span><span class="n">P</span><span class="o">+</span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="p">......</span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="o">^</span><span class="n">p</span><span class="o">+</span><span class="n">n</span><span class="o">=</span><span class="p">(</span><span class="n">y</span><span class="o">^</span><span class="n">p</span><span class="o">-</span><span class="n">y</span><span class="o">^</span><span class="n">p</span><span class="o">+</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">y</span><span class="p">),</span>
</code></pre></div>
<p>得</p>
<div class="codehilite"><pre><span></span><code><span class="n">y</span><span class="o">^</span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="o">^</span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="o">^</span><span class="mi">3</span><span class="w"> </span><span class="o">+</span><span class="p">......</span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="o">^</span><span class="n">p</span><span class="mi">-1</span><span class="w"> </span><span class="o">=</span><span class="p">(</span><span class="w"> </span><span class="n">y</span><span class="o">^</span><span class="mi">1</span><span class="o">-</span><span class="n">y</span><span class="o">^</span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="p">(</span><span class="w"> </span><span class="mi">1</span><span class="o">-</span><span class="n">y</span><span class="o">^</span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">y</span><span class="p">)</span><span class="o">=</span><span class="p">(</span><span class="w"> </span><span class="mi">1</span><span class="o">-</span><span class="n">y</span><span class="o">^</span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">y</span><span class="p">)</span><span class="mi">-1</span>
</code></pre></div>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_4c549128168cb87deb7aa84a0869dc68.jpg"><img alt="" src="assets/doc/01-linux/进程调度/7-负载均衡之负载跟踪简介/images/wp_editor_md_4c549128168cb87deb7aa84a0869dc68.jpg"/></a></p>
<p>因为0&lt;y&lt;1，所以当趋于0（体验下什么叫做0.99^n和1.11^n），所以上面的公式再次简化为如下：</p>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_711e3a444220a43fc18f8fec06c04b3b.jpg"><img alt="" src="assets/doc/01-linux/进程调度/7-负载均衡之负载跟踪简介/images/wp_editor_md_711e3a444220a43fc18f8fec06c04b3b.jpg"/></a></p>
<h3 id="_1">代码实现</h3>
<div class="codehilite"><pre><span></span><code><span class="n">Lnow</span><span class="w"> </span><span class="o">=</span><span class="n">d3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1024</span><span class="o">*</span><span class="p">(</span><span class="n">y</span><span class="o">^</span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="o">^</span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="o">^</span><span class="mi">3</span><span class="w"> </span><span class="o">+</span><span class="p">......</span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="o">^</span><span class="n">p</span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">d1</span><span class="o">+</span><span class="w"> </span><span class="n">Llast</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">y</span><span class="o">^</span><span class="n">p</span><span class="w"> </span>
<span class="o">=</span><span class="w"> </span><span class="n">Llast</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">y</span><span class="o">^</span><span class="n">p</span><span class="err">（</span><span class="n">step1</span><span class="err">）</span><span class="o">+</span><span class="w"> </span><span class="p">[</span><span class="n">d1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">y</span><span class="o">^</span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">LOAD_AVG_MAX</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="o">*</span><span class="n">LOAD_AVG_MAX</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1024</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">d3</span><span class="p">]</span><span class="err">（</span><span class="n">step2</span><span class="err">）</span>
</code></pre></div>
<p>accumulate_sum是计算负载的核心函数，计算的负载结果并不是会增加而有可能是减少，负载的变化都在这个函数中实现，当调度实体没有在就绪队列时，随着时间的增加其对CPU的负载会逐渐减弱，而如果调度实体在就绪队列时，对CPU的负载就会逐渐增加。</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="n">__always_inline</span><span class="w"> </span><span class="n">u32</span>
<span class="n">accumulate_sum</span><span class="p">(</span><span class="n">u64</span><span class="w"> </span><span class="n">delta</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_avg</span><span class="w"> </span><span class="o">*</span><span class="n">sa</span><span class="p">,</span>
<span class="w">           </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">load</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">runnable</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">running</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">u32</span><span class="w"> </span><span class="n">contrib</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">delta</span><span class="p">;</span><span class="w"> </span><span class="cm">/* p == 0 -&gt; delta &lt; 1024 */</span>
<span class="w">    </span><span class="n">u64</span><span class="w"> </span><span class="n">periods</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// sa-&gt;period_contrib是上次更新负载不足1024us周期的时间，delta是上次更新负载到现在要计算负载经过的时间，要计算有多少个周期需要加上period_contrib，见4.1.1的图。</span>
<span class="w">    </span><span class="n">delta</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">period_contrib</span><span class="p">;</span>
<span class="w">    </span><span class="n">periods</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">delta</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">1024</span><span class="p">;</span><span class="w"> </span><span class="cm">/* A period is 1024us (~1ms) */</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Step 1: decay old *_sum if we crossed period boundaries.</span>
<span class="cm">     */</span>
<span class="w">     </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">periods</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">//step1: 分别计算 Llast * y^p，历史负载的衰减</span>
<span class="w">        </span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">load_sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">decay_load</span><span class="p">(</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">load_sum</span><span class="p">,</span><span class="w"> </span><span class="n">periods</span><span class="p">);</span>
<span class="w">        </span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">runnable_sum</span><span class="w"> </span><span class="o">=</span>
<span class="w">            </span><span class="n">decay_load</span><span class="p">(</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">runnable_sum</span><span class="p">,</span><span class="w"> </span><span class="n">periods</span><span class="p">);</span>
<span class="w">        </span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">util_sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">decay_load</span><span class="p">((</span><span class="n">u64</span><span class="p">)(</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">util_sum</span><span class="p">),</span><span class="w"> </span><span class="n">periods</span><span class="p">);</span>

<span class="w">        </span><span class="cm">/*</span>
<span class="cm">         * Step 2</span>
<span class="cm">         */</span>

<span class="w">        </span><span class="n">delta</span><span class="w"> </span><span class="o">%=</span><span class="w"> </span><span class="mi">1024</span><span class="p">;</span>
<span class="w">        </span><span class="c1">//当load=0时，说明当前的调度实体不处于running或runnable，因此不需要计算新增负载负载贡献，而只计算负载衰减，过了一段时间周期，一直没得到运行，累计的负载衰减step1的操作就是衰减。</span>
<span class="c1">//step2: 计算[d1 * y^p + LOAD_AVG_MAX - *LOAD_AVG_MAX - 1024 +d3]，period即P。</span>
<span class="c1">//当load !=0，说明调度实体处于running或runnable，就需要计算增加的负载贡献。</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">load</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">//d1= 1024 - sa-&gt;period_contrib, d3=delta % 1024。</span>
<span class="w">            </span><span class="n">contrib</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__accumulate_pelt_segments</span><span class="p">(</span><span class="n">periods</span><span class="p">,</span>
<span class="w">                    </span><span class="mi">1024</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">period_contrib</span><span class="p">,</span><span class="w"> </span><span class="n">delta</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="p">}</span>
<span class="c1">//更新不足一个周期贡献值</span>
<span class="w">    </span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">period_contrib</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">delta</span><span class="p">;</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">load</span><span class="p">)</span>
<span class="w">        </span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">load_sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">load</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">contrib</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">runnable</span><span class="p">)</span>
<span class="w">        </span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">runnable_sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">runnable</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">contrib</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">SCHED_CAPACITY_SHIFT</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">running</span><span class="p">)</span>
<span class="w">        </span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">util_sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">contrib</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">SCHED_CAPACITY_SHIFT</span><span class="p">;</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">periods</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_fab570115ff24bb938c3978344275490.jpg"><img alt="" src="assets/doc/01-linux/进程调度/7-负载均衡之负载跟踪简介/images/wp_editor_md_fab570115ff24bb938c3978344275490.jpg"/></a></p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="n">u32</span><span class="w"> </span><span class="nf">__accumulate_pelt_segments</span><span class="p">(</span><span class="n">u64</span><span class="w"> </span><span class="n">periods</span><span class="p">,</span><span class="w"> </span><span class="n">u32</span><span class="w"> </span><span class="n">d1</span><span class="p">,</span><span class="w"> </span><span class="n">u32</span><span class="w"> </span><span class="n">d3</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">u32</span><span class="w"> </span><span class="n">c1</span><span class="p">,</span><span class="w"> </span><span class="n">c2</span><span class="p">,</span><span class="w"> </span><span class="n">c3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d3</span><span class="p">;</span><span class="w"> </span><span class="cm">/* y^0 == 1 */</span>

<span class="w">    </span><span class="n">c1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">decay_load</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">d1</span><span class="p">,</span><span class="w"> </span><span class="n">periods</span><span class="p">);</span><span class="w"> </span><span class="c1">//计算d1 * y^p </span>
<span class="n">c2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LOAD_AVG_MAX</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">decay_load</span><span class="p">(</span><span class="n">LOAD_AVG_MAX</span><span class="p">,</span><span class="w"> </span><span class="n">periods</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1024</span><span class="p">;</span>
<span class="c1">//计算LOAD_AVG_MAX - *LOAD_AVG_MAX - 1024</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">c1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">c2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">c3</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="_2">负载更新</h2>
<p>负载使用的是struct sched结构体来进行描述，负载的描述对象分为调度实体se负载（包含group se和task se）和调度实体所在的就绪队列cfs_rq负载。cfs_rq的负载可以先简单的理解为是其队列中所有调度实体se的贡献，当然不能简单是相加关系，需要考虑权重、cpu算力等因素，顶层的cfs_rq负载实际就等于CPU的负载。   追踪调度实体se的负载是基础，当调度实体se的负载变化时进而也会影响到其所在cfs_rq队列的负载变化，cfs_rq.load = f(se.load)，负载更新的核心函数使用update_load_avg来实现，因此本小结主要就是围绕该函数进行解读。 负载的更新实际是基于某个时间刻进行计算，对于一个调度实体来说其有不同的运行状态，每个状态对CPU的负载计算是不相同的。 - 当一个任务处于running（正在运行）或runnable（就绪队列中）时，那么对系统的负载计算是贡献的，因此负载需要在原来的基础上（上一个时刻的负载衰减值）加上当前新增的贡献负载，也就是说任务处于就绪队列或者正在运行对于CPU来说就是有负荷的。 - 当一个任务没有正运行或没有处于就绪队列中如处于睡眠态，那么也要考虑其任务的历史负载，睡眠的任务必然是此前运行过因为得不到某个资源而从就绪队列中移除，而该任务此前的任务负载也需要考虑进去，只不过会随着时间的增加，任务的负载会不断的衰减，最终趋于0（要是中间没有再次运行）。   如下图负载更新可以分为四部分，触发负载更新，更新task和所属cfs_rq平均负载，负载、运行负载、利用率计算，group se负载传播，本章节会按这四个部分依次展开。</p>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_04845bd8460640853e5219ce6ca1bbd2.jpg"><img alt="" src="assets/doc/01-linux/进程调度/7-负载均衡之负载跟踪简介/images/wp_editor_md_04845bd8460640853e5219ce6ca1bbd2.jpg"/></a></p>
<h3 id="_3">触发负载更新</h3>
<ul>
<li>en/dequeue_task_fair：任务被唤醒/睡眠、CPU/Cgroup迁移、任务调度参数变化等会导致任务出入队变化就会触发负载更新。</li>
<li>set_next_entity：进程切换设置下一个要运行的任务。</li>
<li>put_prev_entity：进程切换将被抢占的任务重新放入队列。</li>
<li>entity_tick：周期性的tick触发。</li>
<li>__sched_group_set_shares：修改task group的调度参数。</li>
<li>de/attach_entity_cfs_rq:唤醒新创建任务、非CFS调度类切换CFS调度类等，cfs_rq在cgroup的迁移等等。</li>
</ul>
<p>上面列出了一部分场景会触发负载更新，如任务的出入队列、设置下一个要运行的任务、被抢占的任务重新入队、周期性调度更新等，下面以几个场景来进行说明。</p>
<p>（1）任务入队enqueue_task_fair-&gt;enqueue_entity。</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">enqueue_task_fair</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">rq</span><span class="w"> </span><span class="o">*</span><span class="n">rq</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="p">......</span>
<span class="n">for_each_sched_entity</span><span class="p">(</span><span class="n">se</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">on_rq</span><span class="p">)</span><span class="w"> </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="n">enqueue_entity</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span><span class="w"> </span><span class="n">se</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span><span class="w">  </span>
<span class="w">        </span><span class="p">...</span>
<span class="p">}</span>
<span class="c1">//se入队所属cfs_rq，并向上遍历直到对应的组调度实体被加入到cfs_rq为止（se要调度，//其父实体也必须入队），enqueue_entity中会更新一次负载，见下，此次的负载更新主要//负责从下到上对应的父调度实体加入到就绪队列为止，再往上就调用下面的code来进行//更新了，如下图示例只更新到cfs_rq2层级权重。</span>

<span class="w">    </span><span class="n">for_each_sched_entity</span><span class="p">(</span><span class="n">se</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">update_load_avg</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span><span class="w"> </span><span class="n">se</span><span class="p">,</span><span class="w"> </span><span class="n">UPDATE_TG</span><span class="p">);</span>
<span class="w">        </span><span class="n">se_update_runnable</span><span class="p">(</span><span class="n">se</span><span class="p">);</span><span class="w"> </span><span class="c1">//更新se所属cfs_rq上的任务数量，负载跟该值也有关系。</span>
<span class="w">        </span><span class="n">update_cfs_group</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//这里就是补全了再往上层级剩余部分se和cfs_rq负载信息，如下如更新cfs_rq1+cfs_rq0</span>
<span class="c1">//权重</span>
<span class="p">....</span>
<span class="p">}</span>
</code></pre></div>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">enqueue_entity</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">cfs_rq</span><span class="w"> </span><span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_entity</span><span class="w"> </span><span class="o">*</span><span class="n">se</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="p">......</span>
<span class="n">update_load_avg</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span><span class="w"> </span><span class="n">se</span><span class="p">,</span><span class="w"> </span><span class="n">UPDATE_TG</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">DO_ATTACH</span><span class="p">);</span><span class="w"> </span>
<span class="c1">//更新load avg多传递了一个DO_ATTACH的flag，当一个任务从一个队列迁移到一个新队</span>
<span class="c1">//列，那么PELT的层级结构发生了变化，这时候需要负载的传播过程。</span>
<span class="w">    </span><span class="n">se_update_runnable</span><span class="p">(</span><span class="n">se</span><span class="p">);</span><span class="w"> </span>
<span class="w">    </span><span class="n">update_cfs_group</span><span class="p">(</span><span class="n">se</span><span class="p">);</span><span class="w"> </span>
<span class="w">    </span><span class="n">account_entity_enqueue</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span><span class="w"> </span><span class="n">se</span><span class="p">);</span><span class="w"> </span>
<span class="p">....</span>
<span class="p">}</span>
</code></pre></div>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_a6be6f9781f30fe48c40a71973d2ea92.jpg"><img alt="" src="assets/doc/01-linux/进程调度/7-负载均衡之负载跟踪简介/images/wp_editor_md_a6be6f9781f30fe48c40a71973d2ea92.jpg"/></a></p>
<p>当调度实体se入队时，自然调度实体se的负载是要更新的，又因为se所属的cfs_rq是其下所有se的负载和，所以当其他se变化时，那么cfs_rq的负载也需要做对应的更新，所以可以在update_load_avg函数中可以看到会先更新se再更新se所属的cfs_rq。而在一个cpu的调度队列中，由于组调度的引入，会有多个层级的情况，因此当最底层的se变化时，对应的cfs_rq变化继而在影响上一层级gse变化，再影响ges所属cfs_rq的变化直到最顶层。简而言之，最底层的se和cfs_rq负载变化会导致上一层的se（gse）和cfs_rq负载也随之变化，直至顶层的cfs_rq。</p>
<p>（2）任务出队dequeue_task_fair-&gt;dequeue_entity。 这是入队的逆过程，</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">dequeue_task_fair</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">rq</span><span class="w"> </span><span class="o">*</span><span class="n">rq</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">task_struct</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="p">......</span>
<span class="n">for_each_sched_entity</span><span class="p">(</span><span class="n">se</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="n">dequeue_entity</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span><span class="w"> </span><span class="n">se</span><span class="p">,</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span>
<span class="p">...</span>
<span class="p">}</span>

<span class="w">    </span><span class="n">for_each_sched_entity</span><span class="p">(</span><span class="n">se</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">update_load_avg</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span><span class="w"> </span><span class="n">se</span><span class="p">,</span><span class="w"> </span><span class="n">UPDATE_TG</span><span class="p">);</span>
<span class="w">        </span><span class="n">se_update_runnable</span><span class="p">(</span><span class="n">se</span><span class="p">);</span><span class="w"> </span>
<span class="w">        </span><span class="n">update_cfs_group</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">....</span>
<span class="p">}</span>
</code></pre></div>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">enqueue_entity</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">cfs_rq</span><span class="w"> </span><span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_entity</span><span class="w"> </span><span class="o">*</span><span class="n">se</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="p">......</span>
<span class="n">update_load_avg</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span><span class="w"> </span><span class="n">se</span><span class="p">,</span><span class="w"> </span><span class="n">UPDATE_TG</span><span class="p">);</span><span class="w"> </span>
<span class="c1">//更新调度实体及所属cfs_rq的负载</span>
<span class="n">se_update_runnable</span><span class="p">(</span><span class="n">se</span><span class="p">);</span><span class="w"> </span>
<span class="c1">//如果是group se，任务已经出队（如进入阻塞状态），那么其runnable_weight需要更新。</span>
<span class="c1">//因为对于group se，只有在计算runnable_sum才会考虑任务数量，但是任务已经出队了</span>
<span class="c1">//就不再是runnable状态了，是block或者dead状态了。</span>
<span class="c1">//这里并没有更新，那么任务阻塞出队cfs rq的负载没有变化，只不</span>
<span class="n">account_entity_enqueue</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span><span class="w"> </span><span class="n">se</span><span class="p">);</span>
<span class="c1">//将调度实体的load weight从cfs rq中加上。</span>
<span class="n">update_cfs_group</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="p">....</span>
<span class="p">}</span>
</code></pre></div>
<p>从上述队列出队来看，并没有将load_avg负载减去，而是变化了runnable相关的负载计算，所以即使任务出队进入阻塞状态，其负载依旧在load_avg中，只不过随着时间的增长而衰减。</p>
<h3 id="taskcfs_rq">task与cfs_rq平均负载</h3>
<p>这一小节我们主要来分析一下update_load_avg函数主要的作用，直接上代码吧。</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">update_load_avg</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">cfs_rq</span><span class="w"> </span><span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_entity</span><span class="w"> </span><span class="o">*</span><span class="n">se</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
<span class="n">u64</span><span class="w"> </span><span class="n">now</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cfs_rq_clock_pelt</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="c1">//获取当前的时刻，减去了空闲时间，也就是该调度实体时间运行的时刻。</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">decayed</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Track task load average for carrying it to new CPU after migrated, and</span>
<span class="cm">     * track group sched_entity load average for task_h_load calc in migration</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="c1">//先计算调度实体的调度负载。</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">last_update_time</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="n">flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">SKIP_AGE_LOAD</span><span class="p">))</span>
<span class="w">        </span><span class="n">__update_load_avg_se</span><span class="p">(</span><span class="n">now</span><span class="p">,</span><span class="w"> </span><span class="n">cfs_rq</span><span class="p">,</span><span class="w"> </span><span class="n">se</span><span class="p">);</span>
<span class="w">    </span><span class="c1">//计算调度实体所属cfs_rq的负载。</span>
<span class="n">decayed</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">update_cfs_rq_load_avg</span><span class="p">(</span><span class="n">now</span><span class="p">,</span><span class="w"> </span><span class="n">cfs_rq</span><span class="p">);</span>

<span class="c1">//group se负载传播：如果调度实体是group se，其下任务有新增或移除等变化，则需要重//新更新group se所在层次的负载，group se下的cfs rq，负载变化要传播到上一层级（group se所在层级）。</span>
<span class="w">    </span><span class="n">decayed</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">propagate_entity_load_avg</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="w">    </span><span class="c1">//se-&gt;avg.last_update_time为0且DO_ATTACH，表示任务从其他队列迁移过来新入队的。</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">last_update_time</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">DO_ATTACH</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>

<span class="w">        </span><span class="cm">/*</span>
<span class="cm">         * DO_ATTACH means we\'re here from enqueue_entity().</span>
<span class="cm">         * !last_update_time means we\'ve passed through</span>
<span class="cm">         * migrate_task_rq_fair() indicating we migrated.</span>
<span class="cm">         *</span>
<span class="cm">         * IOW we\'re enqueueing a task on a new CPU.</span>
<span class="cm">         */</span>
<span class="w">        </span><span class="c1">//刚加入队列，计算se的负载主要是根据当前所属cfs_rq以及cpu算力等信息进行计//算，接着再将se的负载信息load、runnable、tutil传播到所属cfs_rq的负载。最后会//调用add_tg_cfs_propagate启动负载传播，只有调用了这个函数上面的//propagate_entity_load_avg才会具体执行传播动作。</span>
<span class="w">        </span><span class="n">attach_entity_load_avg</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span><span class="w"> </span><span class="n">se</span><span class="p">);</span>

<span class="w">        </span><span class="c1">//更新group的平均负载。</span>
<span class="w">        </span><span class="n">update_tg_load_avg</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>

<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">decayed</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">//负载有变化</span>
<span class="w">        </span><span class="n">cfs_rq_util_change</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="c1">//触发是否需要调频</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">flags</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">UPDATE_TG</span><span class="p">)</span>
<span class="w">            </span><span class="n">update_tg_load_avg</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="_4">负载、运行负载、利用率计算</h3>
<p>负载计算可以分为两类，调度实体（task se、group se）和调度实体所属的cfs_rq；调度实体的计算是调用函数__update_load_avg_se实现，cfs_rq的计算是调用__update_load_avg_cfs_rq来实现，但是最终都会调用___update_load_sum来计算，只是传入的参数不一样。但两类都使用struct sched_avg结构体来进行描述，主要的核心就是需要先计算出{load|runnable|utils}_sum|avg，计算方法总结如下，后续的代码实际也是围绕这个计算公式来执行。</p>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_aceec63d297054f3c848cccf47e5ef8f.jpg"><img alt="" src="assets/doc/01-linux/进程调度/7-负载均衡之负载跟踪简介/images/wp_editor_md_aceec63d297054f3c848cccf47e5ef8f.jpg"/></a></p>
<ul>
<li>{load|runnable|utils}_sum’：上一时刻计算的负载。</li>
<li>contrib：上一个时刻到当前时刻负载贡献。</li>
<li>SCHED_CAPACITY_SHIFT:归一化处理，一般是2^10=1024。</li>
<li>divider：LOAD_AVG_MAX - (1024 - avg-&gt;period_contrib)，最大负载。</li>
</ul>
<p>无论load,runnable,running为任何值，只要更新负载上一时刻计算的{load|runnable|utils}_sum’都会衰减。   当load=0时，runable和running也都为0，因为load的取值为se-&gt;on_rq，该值为1就已经包含了runnable+running；若该值为0，那么就不是runnable或running，那自然runnable和running为0。   当load≠0，runnable≠0或running≠0，其对应的{load|runnable|utils}_sum会有新增负载贡献。   处于blocked状态的调度实体，不会带来新增负载贡献（load=runnable=running=0），但是会对历史负载进行衰减（step1计算的就是历史负载衰减）。</p>
<div class="codehilite"><pre><span></span><code><span class="n">root</span><span class="err">@</span><span class="n">TinaLinux</span><span class="o">:/</span><span class="err">#</span><span class="w"> </span><span class="n">cat</span><span class="w"> </span><span class="o">/</span><span class="n">proc</span><span class="o">/</span><span class="mi">1214</span><span class="o">/</span><span class="n">task</span><span class="o">/</span><span class="mi">1214</span><span class="o">/</span><span class="n">sched</span>
<span class="n">wifi_daemon</span><span class="w"> </span><span class="p">(</span><span class="mi">1214</span><span class="p">,</span><span class="w"> </span><span class="err">#</span><span class="n">threads</span><span class="o">:</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="o">-------------------------------------------------------------------</span>
<span class="n">se</span><span class="p">.</span><span class="n">exec_start</span><span class="w">                                </span><span class="o">:</span><span class="w">         </span><span class="mf">19745.413299</span>
<span class="n">se</span><span class="p">.</span><span class="n">vruntime</span><span class="w">                                  </span><span class="o">:</span><span class="w">          </span><span class="mf">2705.836320</span>
<span class="n">se</span><span class="p">.</span><span class="n">sum_exec_runtime</span><span class="w">                          </span><span class="o">:</span><span class="w">             </span><span class="mf">0.599750</span>
<span class="n">se</span><span class="p">.</span><span class="n">nr_migrations</span><span class="w">                             </span><span class="o">:</span><span class="w">                    </span><span class="mi">0</span>
<span class="nl">nr_switches</span><span class="w">                                  </span><span class="p">:</span><span class="w">                    </span><span class="mi">1</span>
<span class="nl">nr_voluntary_switches</span><span class="w">                        </span><span class="p">:</span><span class="w">                    </span><span class="mi">1</span>
<span class="nl">nr_involuntary_switches</span><span class="w">                      </span><span class="p">:</span><span class="w">                    </span><span class="mi">0</span>
<span class="n">se</span><span class="p">.</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span><span class="w">                               </span><span class="o">:</span><span class="w">              </span><span class="mi">1048576</span>
<span class="n">se</span><span class="p">.</span><span class="n">avg</span><span class="p">.</span><span class="n">load_sum</span><span class="w">                              </span><span class="o">:</span><span class="w">                </span><span class="mi">47234</span>
<span class="n">se</span><span class="p">.</span><span class="n">avg</span><span class="p">.</span><span class="n">runnable_sum</span><span class="w">                          </span><span class="o">:</span><span class="w">             </span><span class="mi">17325956</span>
<span class="n">se</span><span class="p">.</span><span class="n">avg</span><span class="p">.</span><span class="n">util_sum</span><span class="w">                              </span><span class="o">:</span><span class="w">             </span><span class="mi">17325956</span>
<span class="n">se</span><span class="p">.</span><span class="n">avg</span><span class="p">.</span><span class="n">load_avg</span><span class="w">                              </span><span class="o">:</span><span class="w">                 </span><span class="mi">1024</span>
<span class="n">se</span><span class="p">.</span><span class="n">avg</span><span class="p">.</span><span class="n">runnable_avg</span><span class="w">                          </span><span class="o">:</span><span class="w">                  </span><span class="mi">361</span>
<span class="n">se</span><span class="p">.</span><span class="n">avg</span><span class="p">.</span><span class="n">util_avg</span><span class="w">                              </span><span class="o">:</span><span class="w">                  </span><span class="mi">361</span>
<span class="n">se</span><span class="p">.</span><span class="n">avg</span><span class="p">.</span><span class="n">last_update_time</span><span class="w">                      </span><span class="o">:</span><span class="w">          </span><span class="mi">19745214464</span>
<span class="n">se</span><span class="p">.</span><span class="n">avg</span><span class="p">.</span><span class="n">util_est</span><span class="p">.</span><span class="n">ewma</span><span class="w">                         </span><span class="o">:</span><span class="w">                  </span><span class="mi">361</span>
<span class="n">se</span><span class="p">.</span><span class="n">avg</span><span class="p">.</span><span class="n">util_est</span><span class="p">.</span><span class="n">enqueued</span><span class="w">                     </span><span class="o">:</span><span class="w">                  </span><span class="mi">361</span>
<span class="nl">policy</span><span class="w">                                       </span><span class="p">:</span><span class="w">                    </span><span class="mi">0</span>
<span class="nl">prio</span><span class="w">                                         </span><span class="p">:</span><span class="w">                  </span><span class="mi">120</span>
<span class="n">clock</span><span class="o">-</span><span class="n">delta</span><span class="w">                                  </span><span class="o">:</span><span class="w">                   </span><span class="mi">83</span>
</code></pre></div>
<h4 id="__update_load_avg_se">__update_load_avg_se</h4>
<p>参数说明： - load：为se-&gt;on_rq，表示当前任务是否处于可运行态，包括runnable + running，对于调度实体来说load要么为0，要么为1。 - runnable：为se_runnable(se)，调度实体是task se则为se-&gt;on_rq，如果是group se，则为se-&gt;runnable_weight。对于group se来说只要其下有一个se是runnable或running，则group se为runnable或running。runnable_weigh等于处于runnable或running的任务数量。 - running：为cfs_rq-&gt;curr se，也就是说当前是否有任务正在运行。</p>
<p>对于task se来说load,runnable,running非0即1；对于group se来说，load,running非0即1，runnable为group se其下运行的任务数量。以下是传入的参数示例：   task se： load=runnable=1,running=1   group se： load = 1, runnable = se-&gt;runnable_weight, running =1</p>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_42aac48fc5555ee453ed5717657f29c7.jpg"><img alt="" src="assets/doc/01-linux/进程调度/7-负载均衡之负载跟踪简介/images/wp_editor_md_42aac48fc5555ee453ed5717657f29c7.jpg"/></a></p>
<p>从上面看出，对于task se与group se的计算，区别主要是runnabe_sum的计算方式不同，group se新增负载贡献需要乘以runnable_weight(group se其下的任务数量)。 {load|runnable|utils}_sum计算的负载只是时间没有权重，但是load_avg需要考虑权重，是权重*时间。</p>
<div class="codehilite"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">__update_load_avg_se</span><span class="p">(</span><span class="n">u64</span><span class="w"> </span><span class="n">now</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">cfs_rq</span><span class="w"> </span><span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_entity</span><span class="w"> </span><span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="c1">//计算{load|runnable|utils}_sum，这里传入三个参数load，runnable，running。</span>
<span class="w">   </span><span class="c1">//load：为se-&gt;on_rq，se-&gt;on_rq=1表示running+runnable</span>
<span class="w">   </span><span class="c1">//runnable：为se_runnable(se)，这里要考虑当前的调度实体是group se还是task se，如果是task se那就等于se-&gt;on_rq，但是如果是group se则为se-&gt;runnable_weight，该值实际等于该任务组中running+runnable的任务数量，对于组调度实体来说组内即使有一个任务处于running或runnable那么group se就是running或runnable。</span>
<span class="w">   </span><span class="c1">//running：代表当前正在运行的任务。</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">___update_load_sum</span><span class="p">(</span><span class="n">now</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">,</span><span class="w"> </span><span class="o">!!</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">on_rq</span><span class="p">,</span><span class="w"> </span><span class="n">se_runnable</span><span class="p">(</span><span class="n">se</span><span class="p">),</span>
<span class="w">                </span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">se</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">//计算{load|runnable|utils}_avg，其中对于load_sum需要乘以权重se_weight(se)。</span>
<span class="w">        </span><span class="n">___update_load_avg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">,</span><span class="w"> </span><span class="n">se_weight</span><span class="p">(</span><span class="n">se</span><span class="p">));</span>
<span class="w">        </span><span class="n">cfs_se_util_change</span><span class="p">(</span><span class="o">&amp;</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">);</span>
<span class="w">        </span><span class="n">trace_pelt_se_tp</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="update_cfs_rq_load_avg">update_cfs_rq_load_avg</h4>
<ul>
<li>load：为scale_load_down(cfs_rq-&gt;load.weight)，可以先简单理解为cfs_rq上所有任务的权重和。</li>
<li>runnable：为h_nr_running，表示当前在就绪队列中的任务数量，包含正在运行的任务。</li>
<li>running：为cfs_rq-&gt;curr != NULL，cfs_rq队列有任务运行。</li>
</ul>
<p>下面示例对比task se与cfs_rq。   Task se: load=runnable=1,running=1   group se：load = cfs_rq-&gt;load.weight,runnable = cfs_rq-&gt;h_nr_running, running =1</p>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_285567189c9839ddcf0895bd8f22ea0f.jpg"><img alt="" src="assets/doc/01-linux/进程调度/7-负载均衡之负载跟踪简介/images/wp_editor_md_285567189c9839ddcf0895bd8f22ea0f.jpg"/></a></p>
<p>从上面公式可以看出，task se和cfs-rq的差别 ① task （group）se的load_sum不考虑权重只考虑时间，而cfs_rq需要考虑整个队列的权重。 ② task se是一个任务，所以 runnable_sum新增负载贡献乘1，而task group 、cfs_rq 计算的runnable_sum需要乘以任务数量。 ③ load_avg对于cfs_rq是不需要乘以权重的，而task se需要相乘权重。</p>
<div class="codehilite"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">__update_load_avg_cfs_rq</span><span class="p">(</span><span class="n">u64</span><span class="w"> </span><span class="n">now</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">cfs_rq</span><span class="w"> </span><span class="o">*</span><span class="n">cfs_rq</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="c1">//计算cfs_rq的{load|runnable|utils}_sum，</span>
<span class="w">   </span><span class="c1">//load = cfs_rq-&gt;load.weight为当前cfs_rq队列上的权重和，对于64为系统做了缩放。</span>
<span class="w">   </span><span class="c1">//runnable = cfs_rq-&gt;h_nr_running，当前队列上的任务数量。</span>
<span class="w">   </span><span class="c1">//running = cfs_rq-&gt;curr != NULL</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">___update_load_sum</span><span class="p">(</span><span class="n">now</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">,</span>
<span class="w">                </span><span class="n">scale_load_down</span><span class="p">(</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">.</span><span class="n">weight</span><span class="p">),</span>
<span class="w">                </span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">h_nr_running</span><span class="p">,</span>
<span class="w">                </span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>

<span class="w">        </span><span class="n">___update_load_avg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="n">trace_pelt_cfs_tp</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>实际上cfs_rq的负载初值，就是其下task （group）的和，得到初值后，如果没有任务出入队列的情况下，就按照上面的公式进行更新负载，如果说有任务出入队列那么就需要重新更新初值，这个过程叫负载传播。</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">enqueue_load_avg</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">cfs_rq</span><span class="w"> </span><span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_entity</span><span class="w"> </span><span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">load_avg</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">load_avg</span><span class="p">;</span>
<span class="w">    </span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">load_sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">se_weight</span><span class="p">(</span><span class="n">se</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">load_sum</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">util_avg</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">util_avg</span><span class="p">;</span>
<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">util_sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">util_sum</span><span class="p">;</span>
<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">runnable_avg</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">runnable_avg</span><span class="p">;</span>
<span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">runnable_sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">runnable_sum</span><span class="p">;</span>
</code></pre></div>
<h4 id="___update_load_sum">___update_load_sum</h4>
<p>__update_load_avg_se和__update_load_avg_cfs_rq最终都要调用___update_load_sum来计算调度实体负载。</p>
<div class="codehilite"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">___update_load_sum</span><span class="p">(</span><span class="n">u64</span><span class="w"> </span><span class="n">now</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_avg</span><span class="w"> </span><span class="o">*</span><span class="n">sa</span><span class="p">,</span>
<span class="w">          </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">load</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">runnable</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">running</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">u64</span><span class="w"> </span><span class="n">delta</span><span class="p">;</span>
<span class="w">    </span><span class="c1">//delta为当前时刻与上一次计算负载的时间差</span>
<span class="w">    </span><span class="n">delta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">now</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">last_update_time</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * This should only happen when time goes backwards, which it</span>
<span class="cm">     * unfortunately does during sched clock init when we swap over to TSC.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">s64</span><span class="p">)</span><span class="n">delta</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">last_update_time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">now</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Use 1024ns as the unit of measurement since it\'s a reasonable</span>
<span class="cm">     * approximation of 1us and fast to compute.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="n">delta</span><span class="w"> </span><span class="o">&gt;&gt;=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">delta</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">last_update_time</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">delta</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * running is a subset of runnable (weight) so running can\'t be set if</span>
<span class="cm">     * runnable is clear. But there are some corner cases where the current</span>
<span class="cm">     * se has been already dequeued but cfs_rq-&gt;curr still points to it.</span>
<span class="cm">     * This means that weight will be 0 but not running for a sched_entity</span>
<span class="cm">     * but also for a cfs_rq if the latter becomes idle. As an example,</span>
<span class="cm">     * this happens during idle_balance() which calls</span>
<span class="cm">     * update_blocked_averages().</span>
<span class="cm">     *</span>
<span class="cm">     * Also see the comment in accumulate_sum().</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">load</span><span class="p">)</span>
<span class="w">        </span><span class="n">runnable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">running</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="c1">//如果load=0，即cfs_rq-&gt;0为0，那么任务不会处于running、runnable，因此也不需要计</span>
<span class="c1">//算runnable、running的新增负载贡献。正在运行的任务即使出队了，但是cfs_rq=1。</span>
<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Now we know we crossed measurement unit boundaries. The *_avg</span>
<span class="cm">     * accrues by two steps:</span>
<span class="cm">     *</span>
<span class="cm">     * Step 1: accumulate *_sum since last_update_time. If we haven\'t</span>
<span class="cm">     * crossed period boundaries, finish.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="c1">//计算*_sum负载。</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">accumulate_sum</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span><span class="w"> </span><span class="n">sa</span><span class="p">,</span><span class="w"> </span><span class="n">load</span><span class="p">,</span><span class="w"> </span><span class="n">runnable</span><span class="p">,</span><span class="w"> </span><span class="n">running</span><span class="p">))</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>delta为计算当前与上一次更新负载权重的差值，用于后续计算调度负载信息。该函数中会判断load是否等于0，如果为0，说明当前调度实体没有处于running或runnable状态，没有在就绪队列中就不需要计算新增调度负载贡献（注意是贡献，表增量），同时调度实体应该要进行调度负载衰减（没得运行，那么自然对CPU的消耗要降低），因此会调用decay_load对load_sum、runnable_sum、util_sum进行衰减；反之如果load不为0，那么说明调度实体处于running或runnable，那么就需要计算调度负载贡献，最后调度负载等于衰减的负载+新增贡献负载。</p>
<h3 id="_5">负载传播</h3>
<p>当一个新创建或从其他cpu迁移的task se加入到一个新的cfs_rq队列时，会导致整个层级的cfs_rq负载发生变化。任务的休眠导致出队的不算？   会调用attach_entity_load_avg/detach_entity_load_avg来更新cfs_rq load_avg。本章节我们以task se从一个cpu迁移到另外一个cpu的cfs_rq为例说明，update_load_avg-&gt;attach_entity_load_avg。</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">attach_entity_load_avg</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">cfs_rq</span><span class="w"> </span><span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_entity</span><span class="w"> </span><span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * cfs_rq-&gt;avg.period_contrib can be used for both cfs_rq and se.</span>
<span class="cm">     * See ___update_load_avg() for details.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="n">u32</span><span class="w"> </span><span class="n">divider</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_pelt_divider</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">);</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * When we attach the @se to the @cfs_rq, we must align the decay</span>
<span class="cm">     * window because without that, really weird and wonderful things can</span>
<span class="cm">     * happen.</span>
<span class="cm">     *</span>
<span class="cm">     * XXX illustrate</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="c1">//当前调度实体的参数从所属cfs_rq中更新</span>
<span class="w">    </span><span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">last_update_time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">last_update_time</span><span class="p">;</span>
<span class="w">    </span><span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">period_contrib</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">period_contrib</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Hell(o) Nasty stuff.. we need to recompute _sum based on the new</span>
<span class="cm">     * period_contrib. This isn\'t strictly correct, but since we\'re</span>
<span class="cm">     * entirely outside of the PELT hierarchy, nobody cares if we truncate</span>
<span class="cm">     * _sum a little.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="c1">//重新计算utils_sum、runnable_sum、load_sum。</span>
<span class="w">    </span><span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">util_sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">util_avg</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">divider</span><span class="p">;</span>

<span class="w">    </span><span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">runnable_sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">runnable_avg</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">divider</span><span class="p">;</span>

<span class="w">    </span><span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">load_sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">load_avg</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">divider</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">se_weight</span><span class="p">(</span><span class="n">se</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">load_sum</span><span class="p">)</span>
<span class="w">        </span><span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">load_sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">div_u64</span><span class="p">(</span><span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">load_sum</span><span class="p">,</span><span class="w"> </span><span class="n">se_weight</span><span class="p">(</span><span class="n">se</span><span class="p">));</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">        </span><span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">load_sum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="c1">//将负载信息{load|runnable|util}_更新累加到cfs_rq中。</span>
<span class="w">    </span><span class="n">enqueue_load_avg</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span><span class="w"> </span><span class="n">se</span><span class="p">);</span>
<span class="w">    </span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">util_avg</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">util_avg</span><span class="p">;</span>
<span class="w">    </span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">util_sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">util_sum</span><span class="p">;</span>
<span class="w">    </span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">runnable_avg</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">runnable_avg</span><span class="p">;</span>
<span class="w">    </span><span class="n">cfs_rq</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">runnable_sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">runnable_sum</span><span class="p">;</span>
<span class="c1">//启动负载传播，使能了这个标志，对于gse类型的调度实体才能调用</span>
<span class="c1">//propagate_entity_load_avg进行负载传播。</span>
<span class="w">    </span><span class="n">add_tg_cfs_propagate</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span><span class="w"> </span><span class="n">se</span><span class="o">-&gt;</span><span class="n">avg</span><span class="p">.</span><span class="n">load_sum</span><span class="p">);</span>
<span class="w">    </span><span class="c1">//触发调频</span>
<span class="w">    </span><span class="n">cfs_rq_util_change</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="w">    </span><span class="n">trace_pelt_cfs_tp</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>对于组任务调度实体，还需要调用propagate_entity_load_avg函数更新当前层级的负载信息。</p>
<div class="codehilite"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">propagate_entity_load_avg</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">sched_entity</span><span class="w"> </span><span class="o">*</span><span class="n">se</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">cfs_rq</span><span class="w"> </span><span class="o">*</span><span class="n">cfs_rq</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">gcfs_rq</span><span class="p">;</span>
<span class="w">    </span><span class="c1">//如果时task直接返回，只有gse才需要传播和更新负载。</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">entity_is_task</span><span class="p">(</span><span class="n">se</span><span class="p">))</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="c1">//获取gse其下的cfs_rq</span>
<span class="n">gcfs_rq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">group_cfs_rq</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>
<span class="c1">//如果没有启动传播，直接返回，有变化才需要更新，没有就直接返回。</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">gcfs_rq</span><span class="o">-&gt;</span><span class="n">propagate</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">gcfs_rq</span><span class="o">-&gt;</span><span class="n">propagate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="c1">//获取gse所属的cfs_rq</span>
<span class="n">cfs_rq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cfs_rq_of</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>

<span class="w">    </span><span class="c1">//将gcfs_rq上的runnable_sum传递到其所属的cfs_rq上，后续会不断的往上循环更新。</span>
<span class="w">    </span><span class="n">add_tg_cfs_propagate</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span><span class="w"> </span><span class="n">gcfs_rq</span><span class="o">-&gt;</span><span class="n">prop_runnable_sum</span><span class="p">);</span>

<span class="c1">//更新gse的utis_avg/sum，所属cfs的utis_avg/sum</span>
<span class="n">update_tg_cfs_util</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span><span class="w"> </span><span class="n">se</span><span class="p">,</span><span class="w"> </span><span class="n">gcfs_rq</span><span class="p">);</span>
<span class="c1">//更新gse的runnable_avg/sum，所属cfs的runnable_avg/sum</span>
<span class="n">update_tg_cfs_runnable</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span><span class="w"> </span><span class="n">se</span><span class="p">,</span><span class="w"> </span><span class="n">gcfs_rq</span><span class="p">);</span>
<span class="c1">//更新gse的laod_avg/sum，所属cfs的load_avg/sum</span>
<span class="w">    </span><span class="n">update_tg_cfs_load</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">,</span><span class="w"> </span><span class="n">se</span><span class="p">,</span><span class="w"> </span><span class="n">gcfs_rq</span><span class="p">);</span>

<span class="w">    </span><span class="n">trace_pelt_cfs_tp</span><span class="p">(</span><span class="n">cfs_rq</span><span class="p">);</span>
<span class="w">    </span><span class="n">trace_pelt_se_tp</span><span class="p">(</span><span class="n">se</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>在更新{utils|runnable|load}_sum|avg的时候，更新gse和所属的cfs_rq，这里的更新与__update_load_avg_se和__update_load_avg_cfs_rq的调用计算是不是重复了？毕竟调用关系是update_load_avg中先调用__update_load_avg_se和__update_load_avg_cfs_rq分别计算se和cfs_rq，然后再调用propagate_entity_load_avg进行更新。答案显然不是，这里的更新可以认为是设置初始值，因为并不是每次都会调用且必须是group se类型才会调用propagate_entity_load_avg计算。__update_load_avg_se和__update_load_avg_cfs_rq是在其初始值的基础上进行更新负载。</p></div>
  <div class="post-nav">
    <a class="prev" href="负载均衡之调度组和调度域.html">← 负载均衡之调度组和调度域</a>
    <a class="next" href="cfs调度实现.html">CFS调度实现 →</a>
  </div>
</article>

      </section>

      <aside class="right-panel">
        
      </aside>
    </main>

    <footer class="site-footer">
      <div class="container">Copyright ©2022-2025 laumy 版权所有</div>
    </footer>

    <script src="assets/site.js"></script>
  </body>
  </html>

