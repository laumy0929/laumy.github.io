<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>一切皆文件之块设备驱动（一） - Laumy的技术栈</title>
    <link rel="stylesheet" href="../assets/style.css">
    <!-- MathJax支持LaTeX数学公式 -->
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          ignoreHtmlClass: 'tex2jax_ignore',
          processHtmlClass: 'tex2jax_process'
        }
      };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  </head>
  <body>
    <header class="site-header">
      <div class="container">
        <a class="logo" href="../">Laumy的技术栈</a>
        <div class="search">
          <input id="search-input" type="text" placeholder="输入关键词回车搜索">
        </div>
        <div class="theme-toggle" title="切换主题" id="theme-toggle">☾</div>
        <nav class="top-nav">
          <div class="nav-item"><a href="../">首页</a></div>
        </nav>
      </div>
    </header>

    <main class="container layout">
      <aside class="left-nav">
        
        <div class="card">
          <div class="card-title">文章目录</div>
          <nav id="toc"><ul><li><a href="#_1">块设备驱动简介</a><ul></ul></li><li><a href="#_2">关键数据结构</a><ul><li><a href="#block_device">block_device</a></li><li><a href="#gendisk">gendisk</a></li></ul></li><li><a href="#biorequestrequest_queue">bio,request,request_queue</a><ul><li><a href="#generic-block-layer">Generic Block layer</a></li><li><a href="#io-scheduler-layer">I/O Scheduler Layer</a></li></ul></li></ul></nav>
        </div>
        
      </aside>

      <section class="content">
        
<article class="card post">
  <h1>一切皆文件之块设备驱动（一）</h1>
  <div class="meta">2023-06-03 · linux</div>
  <div class="post-content"><h2 id="_1">块设备驱动简介</h2>
<p>在linux系统中，有3大驱动类型，分别是：字符设备驱动、块设备驱动、网络设备驱动。块设备驱动与文件系统有着密不可分的关系，块设备是文件系统实际的数据传输单位，通常存储设备有eMMC，Nand/Nor flash，机械硬盘，固态硬盘等，这里所说的块设备驱动，实际就是这些存储设备驱动。块设备驱动与字符设备驱动有较大差异，块设备驱动是以块位单位进行读写，而字符设备驱动以字节为单位进行传输。块设备驱动可以进行随机访问，块设备驱动一般都有缓冲区来暂存数据，当对块设备进行写入时会先将数据写到缓冲区中，累计到一定数据量后才一次性刷到设备中，这样既可以提高读写的速度也可以提高快设备驱动的寿命；相对字符设备数据的操作都是字节流的方式，字符设备没有缓冲区。</p>
<h2 id="_2">关键数据结构</h2>
<h3 id="block_device">block_device</h3>
<p>linux系统中使用strcut block_device来表示块设备,可以表示磁盘或一个特定的分区。下面我们看一下strcut block_device数据结构，该数据结构表示块设备。</p>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">block_device</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">sector_t</span><span class="w">        </span><span class="n">bd_start_sect</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">disk_stats</span><span class="w"> </span><span class="n">__percpu</span><span class="w"> </span><span class="o">*</span><span class="n">bd_stats</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w">       </span><span class="n">bd_stamp</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w">            </span><span class="n">bd_read_only</span><span class="p">;</span><span class="w">   </span><span class="cm">/* read-only policy */</span>
<span class="w">    </span><span class="kt">dev_t</span><span class="w">           </span><span class="n">bd_dev</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w">         </span><span class="n">bd_openers</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="w">      </span><span class="n">bd_inode</span><span class="p">;</span><span class="w">   </span><span class="cm">/* will die */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">super_block</span><span class="w"> </span><span class="o">*</span><span class="w">    </span><span class="n">bd_super</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w">          </span><span class="n">bd_claiming</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">device</span><span class="w">       </span><span class="n">bd_device</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="w">          </span><span class="n">bd_holder</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w">         </span><span class="n">bd_holders</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w">            </span><span class="n">bd_write_holder</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">kobject</span><span class="w">      </span><span class="o">*</span><span class="n">bd_holder_dir</span><span class="p">;</span>
<span class="w">    </span><span class="n">u8</span><span class="w">          </span><span class="n">bd_partno</span><span class="p">;</span>
<span class="w">    </span><span class="n">spinlock_t</span><span class="w">      </span><span class="n">bd_size_lock</span><span class="p">;</span><span class="w"> </span><span class="cm">/* for bd_inode-&gt;i_size updates */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">gendisk</span><span class="w"> </span><span class="o">*</span><span class="w">    </span><span class="n">bd_disk</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* The counter of freeze processes */</span>
<span class="w">    </span><span class="kt">int</span><span class="w">         </span><span class="n">bd_fsfreeze_count</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/* Mutex for freeze */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">mutex</span><span class="w">        </span><span class="n">bd_fsfreeze_mutex</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">super_block</span><span class="w">  </span><span class="o">*</span><span class="n">bd_fsfreeze_sb</span><span class="p">;</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">partition_meta_info</span><span class="w"> </span><span class="o">*</span><span class="n">bd_meta_info</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_FAIL_MAKE_REQUEST</span>
<span class="w">    </span><span class="kt">bool</span><span class="w">            </span><span class="n">bd_make_it_fail</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="p">}</span><span class="w"> </span><span class="n">__randomize_layout</span><span class="p">;</span>
</code></pre></div>
<ul>
<li>bd_dev: 该块设备（分区）的设备号</li>
<li>bd_inode: 设备的文件inode，bdev文件系统将通过该inode来标识块设备。</li>
<li>bd_disk: 指向描述整个设备的gendisk。</li>
</ul>
<p>block_device是bdevfs伪文件系统对块设备或设备分区的抽象，它与设备号唯一对应。</p>
<h3 id="gendisk">gendisk</h3>
<p>linux系统中，struct gendisk是通用存储设备描述，跟具体的硬件设备关联，一个具体的硬件存储设备可以分为多个分区，而每个分区的对应用block_device描述。</p>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">gendisk</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* major, first_minor and minors are input parameters only,</span>
<span class="cm">     * don't use directly.  Use disk_devt() and disk_max_parts().</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">major</span><span class="p">;</span><span class="w">          </span><span class="cm">/* major number of driver */</span><span class="n">磁盘主设备号</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">first_minor</span><span class="p">;</span><span class="w">    </span><span class="n">磁盘第一个次设备</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">minors</span><span class="p">;</span><span class="w">                     </span><span class="cm">/* maximum number of minors, =1 for 次设备的数量，也是分区数量</span>
<span class="cm">                                         * disks that can't be partitioned. */</span>

<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">disk_name</span><span class="p">[</span><span class="n">DISK_NAME_LEN</span><span class="p">];</span><span class="w">  </span><span class="cm">/* name of major driver */</span>

<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="n">events</span><span class="p">;</span><span class="w">      </span><span class="cm">/* supported events */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="n">event_flags</span><span class="p">;</span><span class="w"> </span><span class="cm">/* flags related to event processing */</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">xarray</span><span class="w"> </span><span class="n">part_tbl</span><span class="p">;</span><span class="w"> </span><span class="n">对应分区表</span><span class="err">，</span><span class="n">每一项对应要给分区信息</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">block_device</span><span class="w"> </span><span class="o">*</span><span class="n">part0</span><span class="p">;</span>

<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">block_device_operations</span><span class="w"> </span><span class="o">*</span><span class="n">fops</span><span class="p">;</span><span class="n">磁盘操作函数集</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">request_queue</span><span class="w"> </span><span class="o">*</span><span class="n">queue</span><span class="p">;</span><span class="w"> </span><span class="n">磁盘对应的请求队列</span><span class="err">，</span><span class="n">对磁盘操作的请求都放在这个队列中</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">private_data</span><span class="p">;</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">state</span><span class="p">;</span>
<span class="cp">#define GD_NEED_PART_SCAN       0</span>
<span class="cp">#define GD_READ_ONLY            1</span>
<span class="cp">#define GD_DEAD             2</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">mutex</span><span class="w"> </span><span class="n">open_mutex</span><span class="p">;</span><span class="w">    </span><span class="cm">/* open/close mutex */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">open_partitions</span><span class="p">;</span><span class="w">   </span><span class="cm">/* number of open partitions */</span><span class="w"> </span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">backing_dev_info</span><span class="w"> </span><span class="o">*</span><span class="n">bdi</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">kobject</span><span class="w"> </span><span class="o">*</span><span class="n">slave_dir</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_BLOCK_HOLDER_DEPRECATED</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w"> </span><span class="n">slave_bdevs</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">timer_rand_state</span><span class="w"> </span><span class="o">*</span><span class="n">random</span><span class="p">;</span>
<span class="w">    </span><span class="n">atomic_t</span><span class="w"> </span><span class="n">sync_io</span><span class="p">;</span><span class="w">       </span><span class="cm">/* RAID */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">disk_events</span><span class="w"> </span><span class="o">*</span><span class="n">ev</span><span class="p">;</span>
<span class="cp">#ifdef  CONFIG_BLK_DEV_INTEGRITY</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">kobject</span><span class="w"> </span><span class="n">integrity_kobj</span><span class="p">;</span>
<span class="cp">#endif  </span><span class="cm">/* CONFIG_BLK_DEV_INTEGRITY */</span>
<span class="cp">#if IS_ENABLED(CONFIG_CDROM)</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">cdrom_device_info</span><span class="w"> </span><span class="o">*</span><span class="n">cdi</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">node_id</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">badblocks</span><span class="w"> </span><span class="o">*</span><span class="n">bb</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">lockdep_map</span><span class="w"> </span><span class="n">lockdep_map</span><span class="p">;</span>
<span class="w">    </span><span class="n">u64</span><span class="w"> </span><span class="n">diskseq</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li>major: 存储设备的主设备号</li>
<li>first_minor: 存储设备的第一个次设备号</li>
<li>minors:存储设备的次设备号数量，也对应存储设备的分区数量。</li>
<li>part_tbl:存储设备对应的分区表</li>
<li>fops:存储设备块操作集合，与字符设备的file_operations一样。</li>
<li>queue:存储设备对应的请求队列，对磁盘的请求都会放到该队列中。</li>
</ul>
<p>下面是磁盘的操作函数集合block_device_operations，与字符设备驱动file_operations类似。</p>
<div class="codehilite"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">block_device_operations</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">blk_qc_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">submit_bio</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">bio</span><span class="w"> </span><span class="o">*</span><span class="n">bio</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">open</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">block_device</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">fmode_t</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">release</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">gendisk</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">fmode_t</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">rw_page</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">block_device</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">sector_t</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">page</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">ioctl</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">block_device</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">fmode_t</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">compat_ioctl</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">block_device</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">fmode_t</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">);</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="nf">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">check_events</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">gendisk</span><span class="w"> </span><span class="o">*</span><span class="n">disk</span><span class="p">,</span>
<span class="w">                      </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">clearing</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">unlock_native_capacity</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">gendisk</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">getgeo</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">block_device</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">hd_geometry</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">set_read_only</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">block_device</span><span class="w"> </span><span class="o">*</span><span class="n">bdev</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">ro</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* this callback is with swap_lock and sometimes page table lock held */</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">swap_slot_free_notify</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">block_device</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">report_zones</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">gendisk</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">sector_t</span><span class="w"> </span><span class="n">sector</span><span class="p">,</span>
<span class="w">            </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">nr_zones</span><span class="p">,</span><span class="w"> </span><span class="n">report_zones_cb</span><span class="w"> </span><span class="n">cb</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">);</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">devnode</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">gendisk</span><span class="w"> </span><span class="o">*</span><span class="n">disk</span><span class="p">,</span><span class="w"> </span><span class="n">umode_t</span><span class="w"> </span><span class="o">*</span><span class="n">mode</span><span class="p">);</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">module</span><span class="w"> </span><span class="o">*</span><span class="n">owner</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">pr_ops</span><span class="w"> </span><span class="o">*</span><span class="n">pr_ops</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Special callback for probing GPT entry at a given sector.</span>
<span class="cm">     * Needed by Android devices, used by GPT scanner and MMC blk</span>
<span class="cm">     * driver.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">alternative_gpt_sector</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">gendisk</span><span class="w"> </span><span class="o">*</span><span class="n">disk</span><span class="p">,</span><span class="w"> </span><span class="n">sector_t</span><span class="w"> </span><span class="o">*</span><span class="n">sector</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div>
<ul>
<li>submit_bio: 对存储设备读写操作，但不一定会使用submit_bio来传输，而是通过请求队列来完成。</li>
<li>open: 打开指定的块设备</li>
<li>rw_page:读写指定的页</li>
<li>ioctl:块设备的I/O控制</li>
</ul>
<p>在block_device_operations结构中不像字符设备驱动有对应的read和write函数，有些内核版本甚至没有submit_bio，对于块设备的读写操作，主要是通过request_queue，request和bio来实现的。</p>
<ul>
<li>request_queue:内核对存储设备的读写操作会先发送到request_queue中，该队列中包含有一系列的request，在request中具体的基本单元是bio，bio保存了对存储设备读写的实际数据，包括从存储设备的那个地址读写，具体的长度等信息。</li>
<li>request: 存储设备的请求队列中，包含多个内核对存储设备的多个request，每个请求包含多个bio。</li>
<li>bio:内核对存储设备读写会构造一个或者多个的bio，bio数据结构包含了对存储设备具体的读写位置和长度等信息。</li>
</ul>
<p>接下来将单独对三者关系进行深入描述。</p>
<h2 id="biorequestrequest_queue">bio,request,request_queue</h2>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/12/wp_editor_md_6e9f2cd13fec0f8325a29151ea196e01.jpg"><img alt="" src="../assets/doc/01-linux/文件系统/一切皆文件之块设备/images/wp_editor_md_6e9f2cd13fec0f8325a29151ea196e01.jpg"/></a></p>
<h3 id="generic-block-layer">Generic Block layer</h3>
<p>文件系统向下就是Generic Block Layer，文件系统请求读写的文件位置需要被转换到对应的存储介质的位置（如磁盘的扇区号）。如下是文件系统写过程，将写请求根据文件的pos位转化为bio。</p>
<div class="codehilite"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">__block_write_begin</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">page</span><span class="w"> </span><span class="o">*</span><span class="n">page</span><span class="p">,</span><span class="w"> </span><span class="n">loff_t</span><span class="w"> </span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">len</span><span class="p">,</span>
<span class="w">        </span><span class="n">get_block_t</span><span class="w"> </span><span class="o">*</span><span class="n">get_block</span><span class="p">)</span>

<span class="w">    </span><span class="o">--&gt;</span><span class="k">return</span><span class="w"> </span><span class="n">__block_write_begin_int</span><span class="p">(</span><span class="n">page</span><span class="p">,</span><span class="w"> </span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="n">len</span><span class="p">,</span><span class="w"> </span><span class="n">get_block</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>

<span class="w">        </span><span class="o">--&gt;</span><span class="n">ll_rw_block</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">op_flags</span><span class="p">,</span><span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">nr</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">buffer_head</span><span class="w"> </span><span class="o">*</span><span class="n">bhs</span><span class="p">[])</span>

<span class="w">            </span><span class="o">--&gt;</span><span class="kt">int</span><span class="w"> </span><span class="n">submit_bh</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">op_flags</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">buffer_head</span><span class="w"> </span><span class="o">*</span><span class="n">bh</span><span class="p">)</span>

<span class="w">                    </span><span class="o">--&gt;</span><span class="n">submit_bio</span><span class="p">(</span><span class="n">bio</span><span class="p">)</span>
</code></pre></div>
<p>bio是块设备数据传输最小单元，下面是struct bio的数据结构。</p>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/12/wp_editor_md_fef97739b4f80ac0b84dbf1e1518686b.jpg"><img alt="" src="../assets/doc/01-linux/文件系统/一切皆文件之块设备/images/wp_editor_md_fef97739b4f80ac0b84dbf1e1518686b.jpg"/></a></p>
<ul>
<li>bio_vec:标识存储设备中数据缓存在page的位置，描述IO请求在内存段的数据位置属性（page地址，页内偏移，长度）。</li>
<li>bvec_iter：标识操作数据在存储设备的位置，描述IO请求在存储器段的数据位置属性（起始sector，长度）。</li>
</ul>
<h3 id="io-scheduler-layer">I/O Scheduler Layer</h3>
<p>从submit_bio调用开始，bio被block层抽象为request进行管理，request会被组织到request queue中。IO调度器的目的是在现有请求下，让尽可能少操作存储设备，提高存储设备的读写效率。在IO调度器中，从文件系统提交下来的bio被构造成request结构，一个request结构包含了多个bio，而物理存储设备都会有对应的request queue，里面存放着相关的request，新的bio可能被合并到request queue现有的request结构中，也有可能生成新的request，如何合并、插入等取决于设备驱动选择的IO调度算法。</p>
<h4 id="io">I/O请求</h4>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/12/wp_editor_md_2a74945cf47ccdb99af4b4756648d7b8.jpg"><img alt="" src="../assets/doc/01-linux/文件系统/一切皆文件之块设备/images/wp_editor_md_2a74945cf47ccdb99af4b4756648d7b8.jpg"/></a></p>
<p>早期阶段，只有一个单队列single-queue，随着多核体系结构的发展，单队列的暴露了较多劣势，如多核请求队列时，需要使用spinlock来做同步，锁的竞争带来比较高的额外开销，因此后来引入了multi-queue，将单个队列请求锁的竞争分散到多个队列中，这样就极大提高了并发IO的处理能力。</p>
<p>multi-queue结构分为两层队列设计，分别是Per-CPU级别的软件暂存队列（Software staging queue，Per CPU）和存储设备硬件派发队列（Hardware Dispatch queue，Per Disk Per channel）；</p>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/12/wp_editor_md_cdcee2f38ff80b89823cb696631b3762.jpg"><img alt="" src="../assets/doc/01-linux/文件系统/一切皆文件之块设备/images/wp_editor_md_cdcee2f38ff80b89823cb696631b3762.jpg"/></a></p>
<ul>
<li>
<p>软件暂存队列（ctx）：对应的数据结构blk_mq_ctx,为每个cpu分配一个软件队列，将bio生成一个新的request或合并到已有的request中。bio的提交/完成处理、IO请求合并/排序/标记、调度记账等block layer操作都在该队列中进行。队列是Per CPU，所以每个CPU io请求并发的时候不存在锁竞争问题。</p>
</li>
<li>
<p>硬件派发队列（hctx）：对应的数据结构blk_mq_hw_ctx,每个存储设备的每个硬件队列（通常为一个）分配一个硬件派发队列，用于处理上层软件暂存队列下发的io请求。在存储设备驱动初始化时，blk-mq会将一个或多个软件暂存队列固定映射到一个硬件派发队列，后续软件队列上的io请求就会直接往映射的硬件派发队列下发,最终下发到硬件存储设备。</p>
</li>
</ul>
<p><a href="https://blog.csdn.net/morecrazylove/article/details/128712522">https://blog.csdn.net/morecrazylove/article/details/128712522</a></p>
<p><a href="https://blog.csdn.net/juS3Ve/article/details/79890688">https://blog.csdn.net/juS3Ve/article/details/79890688</a></p>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/12/wp_editor_md_08f19f9823ab9bce38fb1c551f2671a8.jpg"><img alt="" src="../assets/doc/01-linux/文件系统/一切皆文件之块设备/images/wp_editor_md_08f19f9823ab9bce38fb1c551f2671a8.jpg"/></a></p></div>
  <div class="post-nav">
    <a class="prev" href="../内存管理概述.html">← 内存管理概述</a>
    <a class="next" href="../一切皆文件之字符设备.html">一切皆文件之字符设备 →</a>
  </div>
</article>

      </section>

      <aside class="right-panel">
        
      </aside>
    </main>

    <footer class="site-footer">
      <div class="container">Copyright ©2022-2025 laumy 版权所有</div>
    </footer>

    <script src="../assets/site.js"></script>
  </body>
  </html>

