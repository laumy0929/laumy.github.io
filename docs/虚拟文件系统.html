<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>虚拟文件系统 - Laumy的技术栈</title>
    <link rel="stylesheet" href="../assets/style.css">
    <!-- MathJax支持LaTeX数学公式 -->
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          ignoreHtmlClass: 'tex2jax_ignore',
          processHtmlClass: 'tex2jax_process'
        }
      };
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  </head>
  <body>
    <header class="site-header">
      <div class="container">
        <a class="logo" href="../">Laumy的技术栈</a>
        <div class="search">
          <input id="search-input" type="text" placeholder="输入关键词回车搜索">
        </div>
        <div class="theme-toggle" title="切换主题" id="theme-toggle">☾</div>
        <nav class="top-nav">
          <div class="nav-item"><a href="../">首页</a></div>
        </nav>
      </div>
    </header>

    <main class="container layout">
      <aside class="left-nav">
        
        <div class="card">
          <div class="card-title">文章目录</div>
          <nav id="toc"><ul><li><a href="#_1">四大对象数据结构</a><ul><li><a href="#_2">超级块对象</a></li><li><a href="#_3">索引节点对象</a></li><li><a href="#_4">目录项对象</a></li><li><a href="#_5">文件对象</a></li></ul></li><li><a href="#_6">其他数据结构</a><ul><li><a href="#_7">文件系统类型</a></li><li><a href="#_8">文件系统挂载</a></li></ul></li></ul></nav>
        </div>
        
      </aside>

      <section class="content">
        
<article class="card post">
  <h1>虚拟文件系统</h1>
  <div class="meta">2023-05-20 · linux</div>
  <div class="post-content"><p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_8268464056e615fff2c2c6028c3bf923.jpg"><img alt="" src="../assets/doc/01-linux/文件系统/虚拟文件系统/images/wp_editor_md_8268464056e615fff2c2c6028c3bf923.jpg"/></a></p>
<p>Linux系统中支持多种不同的文件系统，为了是用户可以通过一个文件系统操作界面，对各种不同的文件系统进行操作，在具体的文件系统（ext2/ext4等）之上增加了一层抽象一个统一的虚拟文件系统界面，向上提供归一化的文件操作，这个抽象层就称为虚拟文件系统。 为了实现抽象层，Linux内核定义了4个重要的数据结构对象。</p>
<ul>
<li>supper block: 管理文件系统的相关描述信息。</li>
<li>Inode:一个文件对应一个inode，包含文件的相关信息，包括文件大小、创建时间、块大小等。</li>
<li>Dentry:表示一个目录项。</li>
<li>File:进程打开的文件。</li>
</ul>
<p>上面4个对象都有对应的函数操作方法</p>
<ul>
<li>supper_operations:文件系统的操作方法，如read_inode</li>
<li>inode_operations:文件的操作方法，如create、link。</li>
<li>dentry_operations:目录项的操作方法，如d_compare、d_delete。</li>
<li>file:进程打开文件后的操作方法，如read、write。</li>
</ul>
<h2 id="_1">四大对象数据结构</h2>
<h3 id="_2">超级块对象</h3>
<p>超级块，用于描述设备上的文件系统的总体信息如块大小、文件大小上限、文件系统类型、挂载点信息等。在构建一个文件系统时，内核会从存储设备特定位置获取相关的控制信息来填充内存中的超级块对象，当构建完成一个文件系统时就会对应一个超级块对象。</p>
<p>struct super_block</p>
<div class="codehilite"><pre><span></span><code><span class="n">include</span><span class="o">/</span><span class="n">linux</span><span class="o">/</span><span class="n">fs</span><span class="p">.</span><span class="n">h</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">super_block</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w">    </span><span class="n">s_list</span><span class="p">;</span><span class="w">     </span><span class="cm">/* Keep this first */</span>
<span class="w">    </span><span class="kt">dev_t</span><span class="w">           </span><span class="n">s_dev</span><span class="p">;</span><span class="w">      </span><span class="cm">/* search index; _not_ kdev_t */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w">       </span><span class="n">s_blocksize_bits</span><span class="p">;</span>
<span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w">       </span><span class="n">s_blocksize</span><span class="p">;</span>
<span class="n">loff_t</span><span class="w">          </span><span class="n">s_maxbytes</span><span class="p">;</span><span class="w"> </span><span class="c1">//文件大小上限</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">file_system_type</span><span class="w"> </span><span class="o">*</span><span class="n">s_type</span><span class="p">;</span><span class="w"> </span><span class="c1">//文件系统类型</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">super_operations</span><span class="w">   </span><span class="o">*</span><span class="n">s_op</span><span class="p">;</span><span class="w"> </span><span class="c1">//超级块的方法</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">dquot_operations</span><span class="w">   </span><span class="o">*</span><span class="n">dq_op</span><span class="p">;</span><span class="c1">//磁盘限额的方法</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">quotactl_ops</span><span class="w">   </span><span class="o">*</span><span class="n">s_qcop</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">export_operations</span><span class="w"> </span><span class="o">*</span><span class="n">s_export_op</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w">       </span><span class="n">s_flags</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w">       </span><span class="n">s_iflags</span><span class="p">;</span><span class="w">   </span><span class="cm">/* internal SB_I_* flags */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w">       </span><span class="n">s_magic</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">dentry</span><span class="w">       </span><span class="o">*</span><span class="n">s_root</span><span class="p">;</span><span class="w"> </span><span class="c1">//文件系统目录挂载点</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">rw_semaphore</span><span class="w"> </span><span class="n">s_umount</span><span class="p">;</span>
<span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">dentry_operations</span><span class="w"> </span><span class="o">*</span><span class="n">s_d_op</span><span class="p">;</span><span class="w"> </span><span class="cm">/* default d_op for dentries */</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">block_device</span><span class="w"> </span><span class="o">*</span><span class="n">s_bdev</span><span class="p">;</span><span class="w"> </span><span class="c1">//对应的块设备，在文件系统mount调用mount_bdev时会根据设备的</span>
<span class="n">名称找到对应的bdev填充</span><span class="err">，</span><span class="n">得到块设备描述后后续就可以调用s_read</span><span class="o">/</span><span class="n">s_write等操作块设备</span><span class="err">。</span>
<span class="p">......</span>
<span class="p">}</span>
</code></pre></div>
<p>struct super_operations</p>
<div class="codehilite"><pre><span></span><code><span class="n">include</span><span class="o">/</span><span class="n">linux</span><span class="o">/</span><span class="n">fs</span><span class="p">.</span><span class="n">h</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">super_operations</span><span class="w"> </span><span class="p">{</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">alloc_inode</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">super_block</span><span class="w"> </span><span class="o">*</span><span class="n">sb</span><span class="p">);</span><span class="w"> </span>
<span class="c1">//在给定超级块下创建并初始化一个inode，inode即对应一个目录或文件的实例。</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">destroy_inode</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">free_inode</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">dirty_inode</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">write_inode</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">writeback_control</span><span class="w"> </span><span class="o">*</span><span class="n">wbc</span><span class="p">);</span><span class="w"> </span><span class="c1">//指定索引点写磁盘</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">drop_inode</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">evict_inode</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">put_super</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">super_block</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">sync_fs</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">super_block</span><span class="w"> </span><span class="o">*</span><span class="n">sb</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">wait</span><span class="p">);</span><span class="w"> </span><span class="c1">//文件系统与磁盘上的数据同步</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">freeze_super</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">super_block</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">freeze_fs</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">super_block</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">thaw_super</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">super_block</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">unfreeze_fs</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">super_block</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">statfs</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">kstatfs</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">remount_fs</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">super_block</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">umount_begin</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">super_block</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">show_options</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">seq_file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">show_devname</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">seq_file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">show_path</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">seq_file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">show_stats</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">seq_file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_QUOTA</span>
<span class="w">    </span><span class="kt">ssize_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">quota_read</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">super_block</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="p">,</span><span class="w"> </span><span class="n">loff_t</span><span class="p">);</span>
<span class="w">    </span><span class="kt">ssize_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">quota_write</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">super_block</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="p">,</span><span class="w"> </span><span class="n">loff_t</span><span class="p">);</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">dquot</span><span class="w"> </span><span class="o">**</span><span class="p">(</span><span class="o">*</span><span class="n">get_dquots</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">nr_cached_objects</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">super_block</span><span class="w"> </span><span class="o">*</span><span class="p">,</span>
<span class="w">                  </span><span class="k">struct</span><span class="w"> </span><span class="nc">shrink_control</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">free_cached_objects</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">super_block</span><span class="w"> </span><span class="o">*</span><span class="p">,</span>
<span class="w">                    </span><span class="k">struct</span><span class="w"> </span><span class="nc">shrink_control</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div>
<h3 id="_3">索引节点对象</h3>
<p>Inode对象代表了一个实际的文件，当文件被访问前需要先获取到该文件的inode，struct inode结构体包含了通用的属性和方法，如文件类型，文件大小，权限，创建时间等信息。</p>
<p>struct inode</p>
<div class="codehilite"><pre><span></span><code><span class="n">include</span><span class="o">/</span><span class="n">linux</span><span class="o">/</span><span class="n">fs</span><span class="p">.</span><span class="n">h</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">umode_t</span><span class="w">         </span><span class="n">i_mode</span><span class="p">;</span><span class="c1">//访问权限</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">short</span><span class="w">      </span><span class="n">i_opflags</span><span class="p">;</span>
<span class="w">    </span><span class="n">kuid_t</span><span class="w">          </span><span class="n">i_uid</span><span class="p">;</span>
<span class="w">    </span><span class="n">kgid_t</span><span class="w">          </span><span class="n">i_gid</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w">        </span><span class="n">i_flags</span><span class="p">;</span><span class="w"> </span><span class="c1">//文件系统标志</span>

<span class="cp">#ifdef CONFIG_FS_POSIX_ACL</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">posix_acl</span><span class="w">    </span><span class="o">*</span><span class="n">i_acl</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">posix_acl</span><span class="w">    </span><span class="o">*</span><span class="n">i_default_acl</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">inode_operations</span><span class="w">   </span><span class="o">*</span><span class="n">i_op</span><span class="p">;</span><span class="w"> </span><span class="c1">//索引节点的操作方法</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">super_block</span><span class="w">  </span><span class="o">*</span><span class="n">i_sb</span><span class="p">;</span><span class="w"> </span><span class="c1">//所属超级块</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">address_space</span><span class="w">    </span><span class="o">*</span><span class="n">i_mapping</span><span class="p">;</span><span class="w"> </span><span class="c1">//文件缓存</span>
<span class="p">......</span>
<span class="w">    </span><span class="k">union</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">file_operations</span><span class="w">    </span><span class="o">*</span><span class="n">i_fop</span><span class="p">;</span><span class="w"> </span><span class="cm">/* former -&gt;i_op-&gt;default_file_ops */</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">free_inode</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">file_lock_context</span><span class="w">    </span><span class="o">*</span><span class="n">i_flctx</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">address_space</span><span class="w">    </span><span class="n">i_data</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w">    </span><span class="n">i_devices</span><span class="p">;</span>
<span class="w">    </span><span class="p">......</span>
<span class="p">}</span>
</code></pre></div>
<p>struct inode_operations</p>
<div class="codehilite"><pre><span></span><code><span class="n">include</span><span class="o">/</span><span class="n">linux</span><span class="o">/</span><span class="n">fs</span><span class="p">.</span><span class="n">h</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">inode_operations</span><span class="w"> </span><span class="p">{</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">lookup</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="k">struct</span><span class="w"> </span><span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span>
<span class="c1">//在指定目录下搜索目录项，要获取inode，需要先获取dentry</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">get_link</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">delayed_call</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">permission</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">user_namespace</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">posix_acl</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">get_acl</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="p">);</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">readlink</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">__user</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="kt">int</span><span class="p">);</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">create</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">user_namespace</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="k">struct</span><span class="w"> </span><span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">,</span>
<span class="w">               </span><span class="n">umode_t</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="p">);</span>
<span class="w">    </span><span class="c1">//create或open系统调用创建或打开文件</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">link</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="k">struct</span><span class="w"> </span><span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">unlink</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="k">struct</span><span class="w"> </span><span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">symlink</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">user_namespace</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="k">struct</span><span class="w"> </span><span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">,</span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">mkdir</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">user_namespace</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="k">struct</span><span class="w"> </span><span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">,</span>
<span class="w">              </span><span class="n">umode_t</span><span class="p">);</span><span class="c1">//创建目录</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">rmdir</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="k">struct</span><span class="w"> </span><span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="c1">//删除目录</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">mknod</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">user_namespace</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="k">struct</span><span class="w"> </span><span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">,</span>
<span class="w">              </span><span class="n">umode_t</span><span class="p">,</span><span class="kt">dev_t</span><span class="p">);</span><span class="c1">//创建管道、设备等特殊文件</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">rename</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">user_namespace</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">,</span>
<span class="w">            </span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">setattr</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">user_namespace</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">,</span>
<span class="w">            </span><span class="k">struct</span><span class="w"> </span><span class="nc">iattr</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">getattr</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">user_namespace</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">path</span><span class="w"> </span><span class="o">*</span><span class="p">,</span>
<span class="w">            </span><span class="k">struct</span><span class="w"> </span><span class="nc">kstat</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">u32</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span>
<span class="w">    </span><span class="kt">ssize_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">listxattr</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">fiemap</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">fiemap_extent_info</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">u64</span><span class="w"> </span><span class="n">start</span><span class="p">,</span>
<span class="w">              </span><span class="n">u64</span><span class="w"> </span><span class="n">len</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">update_time</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">timespec64</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">atomic_open</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">,</span>
<span class="w">               </span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">open_flag</span><span class="p">,</span>
<span class="w">               </span><span class="n">umode_t</span><span class="w"> </span><span class="n">create_mode</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">tmpfile</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">user_namespace</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">,</span>
<span class="w">            </span><span class="k">struct</span><span class="w"> </span><span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">umode_t</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">set_acl</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">user_namespace</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">,</span>
<span class="w">               </span><span class="k">struct</span><span class="w"> </span><span class="nc">posix_acl</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">fileattr_set</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">user_namespace</span><span class="w"> </span><span class="o">*</span><span class="n">mnt_userns</span><span class="p">,</span>
<span class="w">                </span><span class="k">struct</span><span class="w"> </span><span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="n">dentry</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">fileattr</span><span class="w"> </span><span class="o">*</span><span class="n">fa</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">fileattr_get</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="n">dentry</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">fileattr</span><span class="w"> </span><span class="o">*</span><span class="n">fa</span><span class="p">);</span>

<span class="p">}</span><span class="w"> </span><span class="n">____cacheline_aligned</span><span class="p">;</span>
</code></pre></div>
<p>在VFS层定义了通用的struct inode，在具体的文件系统中可能还会定义属于具体文件系统的inode，如struct ext2_inode、struct ext4_inode，这些xxx_inode是对具体文件的描述如元数据相关信息即具体文件系统磁盘信息的描述，在分配struct inode时，会将xxx_inode的值赋值到struct inode中。其他像超级块，目录等对象也类似。</p>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_2f3638dedfafce8236f188ca95fc1076.jpg"><img alt="" src="../assets/doc/01-linux/文件系统/虚拟文件系统/images/wp_editor_md_2f3638dedfafce8236f188ca95fc1076.jpg"/></a></p>
<h3 id="_4">目录项对象</h3>
<p>dentry虽翻译为目录项，但和文件系统中的目录并不是同一个概念，dentry属于文件系统的对象，包括目录、文件等，反映的是文件系统对象在内核中所在文件系统树的位置。每个文件除了有inode，同时也会有一个dentry结构，记录了文件的名称，父目录，子目录等信息，形成我们看到的层级树状结构。与inode不同时，dentry只存在于内存，磁盘上并没有对应的实体文件，因此目录项目不会涉及回写磁盘的操作。   dentry其中重要的是对文件搜索找出对应的文件的inode。遍历目录时比较耗时的，为了加快遍历和查找，内核中使用hash表来缓存dentry。   一个路径的各个组成部分，不管目录还是普通的文件，都是一个dentry对象，如/home/test.c，/，home,test.c都是一个目录项。为了增加搜索效率，这些目录项目缓存到hash表中。</p>
<p>struct dentry</p>
<div class="codehilite"><pre><span></span><code><span class="n">include</span><span class="o">/</span><span class="n">linux</span><span class="o">/</span><span class="n">dcache</span><span class="p">.</span><span class="n">h</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">dentry</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* RCU lookup touched fields */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">d_flags</span><span class="p">;</span><span class="w">       </span><span class="cm">/* protected by d_lock */</span>
<span class="w">    </span><span class="n">seqcount_spinlock_t</span><span class="w"> </span><span class="n">d_seq</span><span class="p">;</span><span class="w">  </span><span class="cm">/* per dentry seqlock */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">hlist_bl_node</span><span class="w"> </span><span class="n">d_hash</span><span class="p">;</span><span class="w">  </span><span class="c1">//用于目录项目查找的hash表</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="n">d_parent</span><span class="p">;</span><span class="w">    </span><span class="c1">//父目录项</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">qstr</span><span class="w"> </span><span class="n">d_name</span><span class="p">;</span><span class="w"> </span><span class="c1">//目录项目名称</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="n">d_inode</span><span class="p">;</span><span class="w">  </span><span class="c1">//目录项关联的索引节点</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">d_iname</span><span class="p">[</span><span class="n">DNAME_INLINE_LEN</span><span class="p">];</span><span class="w">    </span><span class="cm">/* small names */</span>

<span class="w">    </span><span class="cm">/* Ref lookup also touches following */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">lockref</span><span class="w"> </span><span class="n">d_lockref</span><span class="p">;</span><span class="w">   </span><span class="cm">/* per-dentry lock and refcount */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">dentry_operations</span><span class="w"> </span><span class="o">*</span><span class="n">d_op</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">super_block</span><span class="w"> </span><span class="o">*</span><span class="n">d_sb</span><span class="p">;</span><span class="w">   </span><span class="cm">/* The root of the dentry tree */</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">d_time</span><span class="p">;</span><span class="w">       </span><span class="cm">/* used by d_revalidate */</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">d_fsdata</span><span class="p">;</span><span class="w">         </span><span class="cm">/* fs-specific data */</span><span class="w"> </span><span class="n">具体文件系统中内存目录项目</span><span class="err">。</span>

<span class="w">    </span><span class="k">union</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w"> </span><span class="n">d_lru</span><span class="p">;</span><span class="w">     </span><span class="cm">/* LRU list */</span>
<span class="w">        </span><span class="n">wait_queue_head_t</span><span class="w"> </span><span class="o">*</span><span class="n">d_wait</span><span class="p">;</span><span class="w">  </span><span class="cm">/* in-lookup ones only */</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w"> </span><span class="n">d_child</span><span class="p">;</span><span class="w">   </span><span class="cm">/* child of parent list */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">list_head</span><span class="w"> </span><span class="n">d_subdirs</span><span class="p">;</span><span class="w"> </span><span class="cm">/* our children */</span>
<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * d_alias and d_rcu can share memory</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="k">union</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">hlist_node</span><span class="w"> </span><span class="n">d_alias</span><span class="p">;</span><span class="w">  </span><span class="cm">/* inode alias list */</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">hlist_bl_node</span><span class="w"> </span><span class="n">d_in_lookup_hash</span><span class="p">;</span><span class="w">  </span><span class="cm">/* only for in-lookup ones */</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">rcu_head</span><span class="w"> </span><span class="n">d_rcu</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="n">d_u</span><span class="p">;</span>

<span class="w">    </span><span class="n">ANDROID_KABI_RESERVE</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="n">ANDROID_KABI_RESERVE</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="n">__randomize_layout</span><span class="p">;</span>
</code></pre></div>
<p>struct dentry</p>
<div class="codehilite"><pre><span></span><code><span class="n">include</span><span class="o">/</span><span class="n">linux</span><span class="o">/</span><span class="n">dcache</span><span class="p">.</span><span class="n">h</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">dentry_operations</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">d_revalidate</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">d_weak_revalidate</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">d_hash</span><span class="p">)(</span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">qstr</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"> </span><span class="c1">//为目录项目生成hash表</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">d_compare</span><span class="p">)(</span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">,</span>
<span class="w">            </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">qstr</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"> </span><span class="c1">//比较两个文件</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">d_delete</span><span class="p">)(</span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">d_init</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">d_release</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">d_prune</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">d_iput</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">d_dname</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">vfsmount</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">d_automount</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">path</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">d_manage</span><span class="p">)(</span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">path</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="p">);</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">d_real</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">d_canonical_path</span><span class="p">)(</span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">path</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">path</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="n">ANDROID_KABI_RESERVE</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="n">ANDROID_KABI_RESERVE</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="w">    </span><span class="n">ANDROID_KABI_RESERVE</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="w">    </span><span class="n">ANDROID_KABI_RESERVE</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="n">____cacheline_aligned</span><span class="p">;</span>
</code></pre></div>
<h3 id="_5">文件对象</h3>
<p>文件对象描述的是进程和文件直接的关系，对文件的操作都是由进程发起的，进程每打开一个文件，内核就创建一个文件对象，同一个文件可以被不同的进程打开，创建不同的文件对象。</p>
<p>struct file</p>
<div class="codehilite"><pre><span></span><code><span class="n">include</span><span class="o">/</span><span class="n">linux</span><span class="o">/</span><span class="n">fs</span><span class="p">.</span><span class="n">h</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">union</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">llist_node</span><span class="w">   </span><span class="n">fu_llist</span><span class="p">;</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">rcu_head</span><span class="w">     </span><span class="n">fu_rcuhead</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="n">f_u</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">path</span><span class="w">     </span><span class="n">f_path</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w">        </span><span class="o">*</span><span class="n">f_inode</span><span class="p">;</span><span class="w">   </span><span class="cm">/* cached value */</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">file_operations</span><span class="w">    </span><span class="o">*</span><span class="n">f_op</span><span class="p">;</span><span class="w"> </span><span class="c1">//文件的操作方法</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Protects f_ep, f_flags.</span>
<span class="cm">     * Must not be taken from IRQ context.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="n">spinlock_t</span><span class="w">      </span><span class="n">f_lock</span><span class="p">;</span>
<span class="w">    </span><span class="k">enum</span><span class="w"> </span><span class="n">rw_hint</span><span class="w">        </span><span class="n">f_write_hint</span><span class="p">;</span>
<span class="w">    </span><span class="n">atomic_long_t</span><span class="w">       </span><span class="n">f_count</span><span class="p">;</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w">        </span><span class="n">f_flags</span><span class="p">;</span>
<span class="w">    </span><span class="n">fmode_t</span><span class="w">         </span><span class="n">f_mode</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">mutex</span><span class="w">        </span><span class="n">f_pos_lock</span><span class="p">;</span>
<span class="w">    </span><span class="n">loff_t</span><span class="w">          </span><span class="n">f_pos</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">fown_struct</span><span class="w">  </span><span class="n">f_owner</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">cred</span><span class="w">   </span><span class="o">*</span><span class="n">f_cred</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">file_ra_state</span><span class="w">    </span><span class="n">f_ra</span><span class="p">;</span>

<span class="w">    </span><span class="n">u64</span><span class="w">         </span><span class="n">f_version</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_SECURITY</span>
<span class="w">    </span><span class="kt">void</span><span class="w">            </span><span class="o">*</span><span class="n">f_security</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="w">    </span><span class="cm">/* needed for tty driver, and maybe others */</span>
<span class="w">    </span><span class="kt">void</span><span class="w">            </span><span class="o">*</span><span class="n">private_data</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_EPOLL</span>
<span class="w">    </span><span class="cm">/* Used by fs/eventpoll.c to link all the hooks to this file */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">hlist_head</span><span class="w">   </span><span class="o">*</span><span class="n">f_ep</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* #ifdef CONFIG_EPOLL */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">address_space</span><span class="w">    </span><span class="o">*</span><span class="n">f_mapping</span><span class="p">;</span>
<span class="w">    </span><span class="n">errseq_t</span><span class="w">        </span><span class="n">f_wb_err</span><span class="p">;</span>
<span class="w">    </span><span class="n">errseq_t</span><span class="w">        </span><span class="n">f_sb_err</span><span class="p">;</span><span class="w"> </span><span class="cm">/* for syncfs */</span>

<span class="w">    </span><span class="n">ANDROID_KABI_RESERVE</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="n">ANDROID_KABI_RESERVE</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="n">__randomize_layout</span>
</code></pre></div>
<p>struct file_operations</p>
<div class="codehilite"><pre><span></span><code><span class="n">include</span><span class="o">/</span><span class="n">linux</span><span class="o">/</span><span class="n">fs</span><span class="p">.</span><span class="n">h</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">file_operations</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">module</span><span class="w"> </span><span class="o">*</span><span class="n">owner</span><span class="p">;</span>
<span class="w">    </span><span class="n">loff_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">llseek</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">loff_t</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span>
<span class="w">    </span><span class="kt">ssize_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">read</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">__user</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="p">,</span><span class="w"> </span><span class="n">loff_t</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="kt">ssize_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">__user</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="p">,</span><span class="w"> </span><span class="n">loff_t</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="kt">ssize_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">read_iter</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kiocb</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">iov_iter</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="kt">ssize_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">write_iter</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kiocb</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">iov_iter</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">iopoll</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kiocb</span><span class="w"> </span><span class="o">*</span><span class="n">kiocb</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">spin</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">iterate</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">dir_context</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="w"> </span><span class="c1">//目录读取</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">iterate_shared</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">dir_context</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="n">__poll_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">poll</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">poll_table_struct</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">unlocked_ioctl</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">);</span>
<span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">compat_ioctl</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">mmap</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">vm_area_struct</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">mmap_supported_flags</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">open</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">flush</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">fl_owner_t</span><span class="w"> </span><span class="n">id</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">release</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">fsync</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">loff_t</span><span class="p">,</span><span class="w"> </span><span class="n">loff_t</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">datasync</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">fasync</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">lock</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">file_lock</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="kt">ssize_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">sendpage</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">page</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="p">,</span><span class="w"> </span><span class="n">loff_t</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="nf">long</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">get_unmapped_area</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">check_flags</span><span class="p">)(</span><span class="kt">int</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">flock</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">file_lock</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="kt">ssize_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">splice_write</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">pipe_inode_info</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">loff_t</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span>
<span class="w">    </span><span class="kt">ssize_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">splice_read</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">loff_t</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">pipe_inode_info</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">setlease</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">long</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">file_lock</span><span class="w"> </span><span class="o">**</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">**</span><span class="p">);</span>
<span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">fallocate</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="n">file</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">mode</span><span class="p">,</span><span class="w"> </span><span class="n">loff_t</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span>
<span class="w">              </span><span class="n">loff_t</span><span class="w"> </span><span class="n">len</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">show_fdinfo</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">seq_file</span><span class="w"> </span><span class="o">*</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="n">f</span><span class="p">);</span>
<span class="cp">#ifndef CONFIG_MMU</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">mmap_capabilities</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="w">    </span><span class="kt">ssize_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">copy_file_range</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">loff_t</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span>
<span class="w">            </span><span class="n">loff_t</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span>
<span class="w">    </span><span class="n">loff_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">remap_file_range</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="n">file_in</span><span class="p">,</span><span class="w"> </span><span class="n">loff_t</span><span class="w"> </span><span class="n">pos_in</span><span class="p">,</span>
<span class="w">                   </span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="n">file_out</span><span class="p">,</span><span class="w"> </span><span class="n">loff_t</span><span class="w"> </span><span class="n">pos_out</span><span class="p">,</span>
<span class="w">                   </span><span class="n">loff_t</span><span class="w"> </span><span class="n">len</span><span class="p">,</span><span class="w"> </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">remap_flags</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">fadvise</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="n">loff_t</span><span class="p">,</span><span class="w"> </span><span class="n">loff_t</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span>

<span class="w">    </span><span class="n">ANDROID_KABI_RESERVE</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="n">ANDROID_KABI_RESERVE</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="w">    </span><span class="n">ANDROID_KABI_RESERVE</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="w">    </span><span class="n">ANDROID_KABI_RESERVE</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="n">__randomize_layout</span><span class="p">;</span>
</code></pre></div>
<p>下面描述进程与文件操作联系</p>
<p><a href="https://www.laumy.tech/wp-content/uploads/2023/11/wp_editor_md_6a9e7e989e90e2de4e489a3195122885.jpg"><img alt="" src="../assets/doc/01-linux/文件系统/虚拟文件系统/images/wp_editor_md_6a9e7e989e90e2de4e489a3195122885.jpg"/></a></p>
<p>每个进程打开一个文件后，都有一个文件描述符fd。struct file *fd_array存储的就是这个进程打开的所有文件，称为文件描述符表，文件描述表的每一项都是一个指针，指向一个用于描述打开的struct file对象，struct file对象描述了文件的打开模式，当进程打开一个文件是，内核就会创建一个file对象，但是需要注意的是file对象不是专属某个进程，fd才是专属于某个进程，不同的文件描述符指针可以指向相同的file对象，表示共享打开的文件，struct file中有一个引用计数，描述了被多个进程引用的次数，只有引入计数为0时，内核才会销毁file对象。</p>
<h2 id="_6">其他数据结构</h2>
<h3 id="_7">文件系统类型</h3>
<p>Linux支持多种文件系统，内部用一个特殊的数据结构来描述每种文件系统的功能和行为。</p>
<div class="codehilite"><pre><span></span><code><span class="n">include</span><span class="o">/</span><span class="n">linux</span><span class="o">/</span><span class="n">fs</span><span class="p">.</span><span class="n">h</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">file_system_type</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p">;</span><span class="w"> </span><span class="c1">//文件系统名称</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">fs_flags</span><span class="p">;</span>
<span class="cp">#define FS_REQUIRES_DEV     1</span>
<span class="cp">#define FS_BINARY_MOUNTDATA 2</span>
<span class="cp">#define FS_HAS_SUBTYPE      4</span>
<span class="cp">#define FS_USERNS_MOUNT     8   </span><span class="cm">/* Can be mounted by userns root */</span>
<span class="cp">#define FS_DISALLOW_NOTIFY_PERM 16  </span><span class="cm">/* Disable fanotify permission events */</span>
<span class="cp">#define FS_ALLOW_IDMAP         32      </span><span class="cm">/* FS has been updated to handle vfs idmappings. */</span>
<span class="cp">#define FS_THP_SUPPORT      8192    </span><span class="cm">/* Remove once all fs converted */</span>
<span class="cp">#define FS_RENAME_DOES_D_MOVE   32768   </span><span class="cm">/* FS will handle d_move() during rename() internally. */</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">init_fs_context</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">fs_context</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">fs_parameter_spec</span><span class="w"> </span><span class="o">*</span><span class="n">parameters</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">mount</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">file_system_type</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">,</span>
<span class="w">               </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">);</span><span class="c1">//挂载文件系统</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">kill_sb</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">super_block</span><span class="w"> </span><span class="o">*</span><span class="p">);</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">module</span><span class="w"> </span><span class="o">*</span><span class="n">owner</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">file_system_type</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">next</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">hlist_head</span><span class="w"> </span><span class="n">fs_supers</span><span class="p">;</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">lock_class_key</span><span class="w"> </span><span class="n">s_lock_key</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">lock_class_key</span><span class="w"> </span><span class="n">s_umount_key</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">lock_class_key</span><span class="w"> </span><span class="n">s_vfs_rename_key</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">lock_class_key</span><span class="w"> </span><span class="n">s_writers_key</span><span class="p">[</span><span class="n">SB_FREEZE_LEVELS</span><span class="p">];</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">lock_class_key</span><span class="w"> </span><span class="n">i_lock_key</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">lock_class_key</span><span class="w"> </span><span class="n">i_mutex_key</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">lock_class_key</span><span class="w"> </span><span class="n">invalidate_lock_key</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">lock_class_key</span><span class="w"> </span><span class="n">i_mutex_dir_key</span><span class="p">;</span>

<span class="p">};</span>
</code></pre></div>
<h3 id="_8">文件系统挂载</h3>
<p>Linux文件系统只有被挂载上，才能进行访问，使用一个vfsmount来描述一个挂载点。</p>
<div class="codehilite"><pre><span></span><code><span class="n">include</span><span class="o">/</span><span class="n">linux</span><span class="o">/</span><span class="n">fs</span><span class="p">.</span><span class="n">h</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">vfsmount</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">dentry</span><span class="w"> </span><span class="o">*</span><span class="n">mnt_root</span><span class="p">;</span><span class="w">    </span><span class="cm">/* root of the mounted tree */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">super_block</span><span class="w"> </span><span class="o">*</span><span class="n">mnt_sb</span><span class="p">;</span><span class="w"> </span><span class="cm">/* pointer to superblock */</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">mnt_flags</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">user_namespace</span><span class="w"> </span><span class="o">*</span><span class="n">mnt_userns</span><span class="p">;</span>

<span class="w">    </span><span class="n">ANDROID_KABI_RESERVE</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="n">ANDROID_KABI_RESERVE</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="w">    </span><span class="n">ANDROID_KABI_RESERVE</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="w">    </span><span class="n">ANDROID_KABI_RESERVE</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="n">__randomize_layout</span><span class="p">;</span>
</code></pre></div></div>
  <div class="post-nav">
    <a class="prev" href="../实现简单文件系统.html">← 实现简单文件系统</a>
    <a class="next" href="../文件系统磁盘管理.html">文件系统磁盘管理 →</a>
  </div>
</article>

      </section>

      <aside class="right-panel">
        
      </aside>
    </main>

    <footer class="site-footer">
      <div class="container">Copyright ©2022-2025 laumy 版权所有</div>
    </footer>

    <script src="../assets/site.js"></script>
  </body>
  </html>

